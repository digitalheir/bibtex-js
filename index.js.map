{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap 925cb01ca0e269f2d3e2","webpack:///./src/util.ts","webpack:///./src/bibfile/datatype/string/QuotedString.ts","webpack:///./src/bibfile/datatype/string/BracedString.ts","webpack:///./src/bibfile/bib-entry/BibStringEntry.ts","webpack:///./src/bibfile/datatype/string/StringRef.ts","webpack:///./src/bibfile/datatype/KeyVal.ts","webpack:///./src/bibfile/datatype/string/BibStringComponent.ts","webpack:///./src/bibfile/datatype/string/bib-string-utils.ts","webpack:///./src/bibfile/BibFile.ts","webpack:///./src/bibfile/bib-entry/BibComment.ts","webpack:///./src/bibfile/bib-entry/BibEntry.ts","webpack:///./src/bibfile/bib-entry/BibPreamble.ts","webpack:///./src/lexer/NumericToken.ts","webpack:///./src/lexer/Token.ts","webpack:///./src/lexer/WhitespaceToken.ts","webpack:///./src/bibfile/bib-entry/bibliographic-entity/Authors.ts","webpack:///./src/bibfile/bib-entry/bibliographic-entity/mandatory-and-optional-fields.ts","webpack:///./src/index.ts","webpack:///./src/lexer/BibBlockTypes.ts","webpack:///./src/lexer/IdToken.ts","webpack:///./src/lexer/Lexer.ts","webpack:///./src/parser/ts-parser.ts","webpack:///./~/nearley/lib/nearley.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","mustBeString","str","Error","JSON","stringify","mustBeDefined","t","undefined","mustBeArray","isArray","data","constructor","Array","isNumber","isString","flattenMyArray","arr","result","length","_i","_length","value2","push","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","writable","setPrototypeOf","__proto__","isOuterQuotedString","x","type","isQuotedString","BibStringComponent_1","QuotedString","_BibStringComponent_","braceDepth","getPrototypeOf","BibStringComponent","OuterQuotedString","_BibStringComponent_2","BibOuterStringComponent","isOuterBracedString","isBracedString","BracedString","_this","isSpecialCharacter","OuterBracedString","_defineProperty","obj","key","newStringEntry","_convertToKeyVal","convertToKeyVal","BibStringEntry","KeyVal_1","isKeyVal","newKeyVal","resolveStrings","strings","resolved","keys","forEach","resolveStringReference","resolveStringReferences","seenBeforeStack","alreadyResolved","refs","map","datum","util_1","StringRef_1","isStringRef","resolveStringRef","bib_string_utils_1","isBibStringComponent","copyWithResolvedStringReferences","BracedString_1","QuotedString_1","copyOuterWithResolvedStringReferences","refName","stringref","assign","newData","copied","StringRef","parseFieldValue","e","parseStringComponent","_BibStringComponent","isContiguousSimpleString","joinContiguousSimpleStrings","join","string","flattened","toStringBibStringDatum","toStringBibStringData","flattenQuotedStrings","hideQuotes","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","flattenned","flattenQuotedString","concat","err","return","flattenedQuotedString","doubleQuotes","globContiguousStrings","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","element","contiguousSimpleString","lastElement","_contiguousSimpleString","splitOnAnd","splitOnPattern","splitOnComma","arguments","pattern","stopAfter","splitted","buffer","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","match","exec","end","prevEnd","index","substring","parseNonEntry","nonEntry","BibComment_1","BibComment","flattenPlainText","parseEntry","entry","_typeof","BibEntry_1","BibEntry","_id","parseEntryFields","fields","BibStringEntry_1","BibPreamble_1","newPreambleNode","parseBibFile","input","nearley","Parser","ts_parser_1","grammar","ParserRules","ParserStart","feed","Lexer_1","default","readTokens","res","results","parse","BibFile","parseBibEntriesAndNonEntries","_createClass","defineProperties","target","props","descriptor","protoProps","staticProps","content","comments","filter","isBibComment","preambles_raw","isPreamble","preamble$","toString","strings_raw","strings$","entries_raw","isBibEntry","entryMap","toLowerCase","processEntry","entries$","id","entity","flattenO","CommentEntry","wrapper","fieldz","mandatory_and_optional_fields_1","hasMandatoryFields","mandatoryFields","findError","console","warn","message","processedFields","fields$","field$","Authors_1","Authors","sortkey$","title$","field","mustBeAuthors","BibFile_1","Preamble","newNumber","isNum","numericChars","0","1","2","3","4","5","6","7","8","9","newToken","isSpecialChar","specialChars","isEscapableChar","escapableChars","@","(",")","{","}","#","=",",","\\","\"","newWhitespace","isWhitespace","token","WS","isSingleWhiteSpaceCharacter","singleWhitespaces"," ","\t","\r","\n","parseAuthor","determineAuthorNames$","determineAuthorNames","globbed","normalizedString","isAuthors","fieldValue","authorNames","authors$","hasOptionalFields","optionalFields","getMandatoryFields","getOptionalFields","address","author","booktitle","chapter","edition","editor","howpublished","institution","journal","month","note","number","organization","pages","publisher","school","series","title","volume","year","book","booklet","conference","inproceedings","inbook","incollection","manual","mastersthesis","misc","phdthesis","proceedings","techreport","unpublished","article","hasAllFields","reduce","acc","fieldName","__export","bibTypes","preamble","comment","bib","isBibType","newIdToken","isIdToken","isIdChar","Token_1","NumericToken_1","WhitespaceToken_1","IdToken_1","BibBlockTypes_1","Lexer","len","pos","terminalRegex","chars","charAt","tokens","nextToken","readNextToken","currentChar","eatWhiteSpace","eatSpecialChars","eatNumericString","eatIdString","pos2","charAtI","trim","startAt","nums","nextPos","newPos","newChar","numericString","Number","parseInt","isFinite","getStringUntilNonEscapedChar","addToObj","keyval","log","joinTokens","strs","tok_id","test","entry_type_bib","entry_type_string","entry_type_preamble","entry_type_comment","ws","num","pound","literal","eq","esc","paren_l","paren_r","brace_l","brace_r","quote_dbl","comma","symbols","postprocess","topLevelObjects","toeknz","tk","keyvals","kv","tkz","tks","tokenz","Ti","Rule","highestId","State","rule","dot","reference","wantedBy","isComplete","Column","states","wants","scannable","completed","Grammar","rules","start","byName","StreamLexer","reset","options","fromCompiled","keepHistory","lexer","lexerState","column","table","predict","process","current","withCursorAt","stringifySymbolSequence","symbolSequence","slice","nextState","child","state","left","right","build","children","node","reverse","finish","fail","nextColumn","w","complete","exp","nulls","r","inp","copy","g","line","lastLineBreak","col","ch","save","formatError","nextLineBreak","indexOf","chunk","expect","isToken","offset","restore","splice","rewind","considerations"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rechtspraak\"] = factory();\n\telse\n\t\troot[\"rechtspraak\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rechtspraak\"] = factory();\n\telse\n\t\troot[\"rechtspraak\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 17);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction mustBeString(str, o) {\n    if (typeof str !== \"string\") throw new Error(\"Expected to be string: \" + JSON.stringify(o ? o : str));\n    return str;\n}\nexports.mustBeString = mustBeString;\nfunction mustBeDefined(t, o) {\n    if (t === undefined) throw new Error(\"Expected to be defined: \" + JSON.stringify(o ? o : t));\n    return t;\n}\nexports.mustBeDefined = mustBeDefined;\nfunction mustBeArray(str, o) {\n    if (!isArray(str)) throw new Error(\"Expected to be array: \" + JSON.stringify(o ? o : str));\n    return str;\n}\nexports.mustBeArray = mustBeArray;\nfunction isArray(data) {\n    return !!data && data.constructor === Array;\n}\nexports.isArray = isArray;\nfunction isNumber(data) {\n    return typeof data === \"number\";\n}\nexports.isNumber = isNumber;\nfunction isString(data) {\n    return typeof data === \"string\";\n}\nexports.isString = isString;\nexports.flattenMyArray = function (arr, result) {\n    if (!result) result = [];\n    for (var i = 0, length = arr.length; i < length; i++) {\n        var value = arr[i];\n        if (Array.isArray(value)) {\n            for (var _i = 0, _length = value.length; _i < _length; _i++) {\n                var value2 = value[_i];\n                if (Array.isArray(value2)) {\n                    exports.flattenMyArray(value2, result);\n                } else {\n                    result.push(value2);\n                }\n            }\n        } else {\n            result.push(value);\n        }\n    }\n    return result;\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BibStringComponent_1 = __webpack_require__(6);\n\nvar QuotedString = function (_BibStringComponent_) {\n    _inherits(QuotedString, _BibStringComponent_);\n\n    function QuotedString(braceDepth, data) {\n        _classCallCheck(this, QuotedString);\n\n        return _possibleConstructorReturn(this, (QuotedString.__proto__ || Object.getPrototypeOf(QuotedString)).call(this, \"quotedstring\", braceDepth, data));\n    }\n\n    return QuotedString;\n}(BibStringComponent_1.BibStringComponent);\n\nexports.QuotedString = QuotedString;\n\nvar OuterQuotedString = function (_BibStringComponent_2) {\n    _inherits(OuterQuotedString, _BibStringComponent_2);\n\n    function OuterQuotedString(data) {\n        _classCallCheck(this, OuterQuotedString);\n\n        return _possibleConstructorReturn(this, (OuterQuotedString.__proto__ || Object.getPrototypeOf(OuterQuotedString)).call(this, \"quotedstringwrapper\", data));\n    }\n\n    return OuterQuotedString;\n}(BibStringComponent_1.BibOuterStringComponent);\n\nexports.OuterQuotedString = OuterQuotedString;\nfunction isOuterQuotedString(x) {\n    return x.type === \"quotedstringwrapper\";\n}\nexports.isOuterQuotedString = isOuterQuotedString;\nfunction isQuotedString(x) {\n    return x.type === \"quotedstring\";\n}\nexports.isQuotedString = isQuotedString;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BibStringComponent_1 = __webpack_require__(6);\n\nvar BracedString = function (_BibStringComponent_) {\n    _inherits(BracedString, _BibStringComponent_);\n\n    function BracedString(braceDepth, data) {\n        _classCallCheck(this, BracedString);\n\n        var _this = _possibleConstructorReturn(this, (BracedString.__proto__ || Object.getPrototypeOf(BracedString)).call(this, \"bracedstring\", braceDepth, data));\n\n        _this.isSpecialCharacter = braceDepth === 0 && data[0] === \"\\\\\";\n        return _this;\n    }\n\n    return BracedString;\n}(BibStringComponent_1.BibStringComponent);\n\nexports.BracedString = BracedString;\n\nvar OuterBracedString = function (_BibStringComponent_2) {\n    _inherits(OuterBracedString, _BibStringComponent_2);\n\n    function OuterBracedString(data) {\n        _classCallCheck(this, OuterBracedString);\n\n        return _possibleConstructorReturn(this, (OuterBracedString.__proto__ || Object.getPrototypeOf(OuterBracedString)).call(this, \"bracedstringwrapper\", data));\n    }\n\n    return OuterBracedString;\n}(BibStringComponent_1.BibOuterStringComponent);\n\nexports.OuterBracedString = OuterBracedString;\nfunction isOuterBracedString(x) {\n    return x.type === \"bracedstringwrapper\";\n}\nexports.isOuterBracedString = isOuterBracedString;\nfunction isBracedString(x) {\n    return x.type === \"bracedstring\";\n}\nexports.isBracedString = isBracedString;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar KeyVal_1 = __webpack_require__(5);\nvar StringRef_1 = __webpack_require__(4);\nvar QuotedString_1 = __webpack_require__(1);\nvar BracedString_1 = __webpack_require__(2);\nvar util_1 = __webpack_require__(0);\nvar bib_string_utils_1 = __webpack_require__(7);\n\nvar BibStringEntry = function BibStringEntry(key, value) {\n    _classCallCheck(this, BibStringEntry);\n\n    this.type = \"string\";\n    this.key = key;\n    this.value = value;\n};\n\nexports.BibStringEntry = BibStringEntry;\nfunction newStringEntry(data) {\n    var _convertToKeyVal = convertToKeyVal(data),\n        key = _convertToKeyVal.key,\n        value = _convertToKeyVal.value;\n\n    return new BibStringEntry(key, value);\n}\nexports.newStringEntry = newStringEntry;\nfunction convertToKeyVal(data) {\n    if (KeyVal_1.isKeyVal(data)) {\n        return KeyVal_1.newKeyVal(data);\n    } else {\n        if (data.type !== \"string\") {\n            throw new Error(\"Unexpected node: \" + JSON.stringify(data));\n        }\n        return convertToKeyVal(data.data);\n    }\n}\nfunction resolveStrings(strings) {\n    var resolved = {};\n    Object.keys(strings).forEach(function (key) {\n        if (!resolved[key]) resolved[key] = resolveStringReference({}, resolved, strings, strings[key]);\n    });\n    return resolved;\n}\nexports.resolveStrings = resolveStrings;\nfunction resolveStringReferences(o, seenBeforeStack, alreadyResolved, refs) {\n    return o.data.map(function (datum) {\n        if (util_1.isString(datum) || util_1.isNumber(datum)) return datum;else if (StringRef_1.isStringRef(datum)) return resolveStringRef(seenBeforeStack, refs, datum, alreadyResolved);else if (bib_string_utils_1.isBibStringComponent(datum)) return copyWithResolvedStringReferences(datum, seenBeforeStack, alreadyResolved, refs);else throw new Error();\n    });\n}\nexports.resolveStringReferences = resolveStringReferences;\nfunction resolveStringReference(seenBeforeStack, alreadyResolved, refs, data) {\n    if (util_1.isNumber(data)) {\n        return data;\n    } else if (BracedString_1.isOuterBracedString(data) || QuotedString_1.isOuterQuotedString(data)) {\n        return copyOuterWithResolvedStringReferences(data, seenBeforeStack, alreadyResolved, refs);\n    }\n    if (StringRef_1.isStringRef(data)) {\n        return resolveStringRef(seenBeforeStack, refs, data, alreadyResolved);\n    }\n    return data;\n}\nexports.resolveStringReference = resolveStringReference;\nfunction resolveStringRef(seenBeforeStack, refs, data, alreadyResolved) {\n    var refName = data.stringref;\n    if (seenBeforeStack[refName]) throw new Error(\"Cycle detected: \" + refName);\n    if (alreadyResolved[refName]) {\n        return alreadyResolved[refName];\n    }\n    if (!refs[refName]) throw new Error(\"Unresolved reference: \\\"\" + data.stringref + \"\\\" (\" + JSON.stringify(data) + \")\");\n    alreadyResolved[refName] = resolveStringReference(Object.assign({}, seenBeforeStack, _defineProperty({}, refName, true)), alreadyResolved, refs, refs[refName]);\n    return alreadyResolved[refName];\n}\nfunction copyWithResolvedStringReferences(obj, seenBeforeStack, alreadyResolved, refs) {\n    var newData = resolveStringReferences(obj, seenBeforeStack, alreadyResolved, refs);\n    var braceDepth = obj.braceDepth;\n    if (QuotedString_1.isQuotedString(obj)) return new QuotedString_1.QuotedString(braceDepth, newData);\n    if (BracedString_1.isBracedString(obj)) return new BracedString_1.BracedString(braceDepth, newData);\n    if (QuotedString_1.isOuterQuotedString(obj)) return new QuotedString_1.OuterQuotedString(newData);\n    if (BracedString_1.isOuterBracedString(obj)) return new BracedString_1.OuterBracedString(newData);else throw new Error();\n}\nexports.copyWithResolvedStringReferences = copyWithResolvedStringReferences;\nfunction copyOuterWithResolvedStringReferences(obj, seenBeforeStack, alreadyResolved, refs) {\n    var copied = copyWithResolvedStringReferences(obj, seenBeforeStack, alreadyResolved, refs);\n    if (!BracedString_1.isOuterBracedString(copied) && !QuotedString_1.isOuterQuotedString(copied)) throw new Error();\n    return copied;\n}\nexports.copyOuterWithResolvedStringReferences = copyOuterWithResolvedStringReferences;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar StringRef = function StringRef(braceDepth, stringref) {\n    _classCallCheck(this, StringRef);\n\n    this.braceDepth = braceDepth;\n    this.stringref = stringref;\n};\n\nexports.StringRef = StringRef;\nfunction isStringRef(stringref) {\n    return typeof stringref.stringref === \"string\";\n}\nexports.isStringRef = isStringRef;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BracedString_1 = __webpack_require__(2);\nvar QuotedString_1 = __webpack_require__(1);\nvar util_1 = __webpack_require__(0);\nvar bib_string_utils_1 = __webpack_require__(7);\nfunction isKeyVal(data) {\n    return typeof data.key === \"string\" && data.value !== undefined;\n}\nexports.isKeyVal = isKeyVal;\nfunction newKeyVal(data) {\n    if (isKeyVal(data)) {\n        return {\n            key: data.key,\n            value: parseFieldValue(data.value)\n        };\n    } else {\n        throw new Error(\"Was not a KeyVal: \" + JSON.stringify(data));\n    }\n}\nexports.newKeyVal = newKeyVal;\nfunction parseFieldValue(value) {\n    if (util_1.isNumber(value)) {\n        return value;\n    }\n    var data = util_1.mustBeArray(value.data);\n    switch (value.type) {\n        case \"quotedstringwrapper\":\n            if (data.length === 1 && util_1.isNumber(data[0])) return data[0];\n            return new QuotedString_1.OuterQuotedString(data.map(function (e) {\n                return bib_string_utils_1.parseStringComponent(0, e);\n            }));\n        case \"bracedstringwrapper\":\n            return new BracedString_1.OuterBracedString(data.map(function (e) {\n                return bib_string_utils_1.parseStringComponent(0, e);\n            }));\n        default:\n            throw new Error(\"Unexpected value: \" + JSON.stringify(value));\n    }\n}\nexports.parseFieldValue = parseFieldValue;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar BibStringComponent = function BibStringComponent(type, braceDepth, data) {\n    _classCallCheck(this, BibStringComponent);\n\n    this.type = type;\n    this.braceDepth = braceDepth;\n    this.data = data;\n};\n\nexports.BibStringComponent = BibStringComponent;\n\nvar BibOuterStringComponent = function (_BibStringComponent) {\n    _inherits(BibOuterStringComponent, _BibStringComponent);\n\n    function BibOuterStringComponent(type, data) {\n        _classCallCheck(this, BibOuterStringComponent);\n\n        return _possibleConstructorReturn(this, (BibOuterStringComponent.__proto__ || Object.getPrototypeOf(BibOuterStringComponent)).call(this, type, 0, data));\n    }\n\n    return BibOuterStringComponent;\n}(BibStringComponent);\n\nexports.BibOuterStringComponent = BibOuterStringComponent;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar StringRef_1 = __webpack_require__(4);\nvar BracedString_1 = __webpack_require__(2);\nvar QuotedString_1 = __webpack_require__(1);\nvar util_1 = __webpack_require__(0);\nfunction isBibStringComponent(x) {\n    return typeof x.braceDepth === \"number\" && typeof x.type === \"string\";\n}\nexports.isBibStringComponent = isBibStringComponent;\nfunction isContiguousSimpleString(x) {\n    return x.type === \"ContiguousSimpleString\" && util_1.isArray(x.data);\n}\nexports.isContiguousSimpleString = isContiguousSimpleString;\nfunction joinContiguousSimpleStrings(x) {\n    return x.data.join(\"\");\n}\nexports.joinContiguousSimpleStrings = joinContiguousSimpleStrings;\nfunction parseStringComponent(braceDepth, obj) {\n    if (util_1.isNumber(obj) || util_1.isString(obj)) return obj;\n    if (StringRef_1.isStringRef(obj)) return new StringRef_1.StringRef(0, obj.stringref);\n    switch (util_1.mustBeString(obj.type, obj)) {\n        case \"id\":\n        case \"ws\":\n        case \"number\":\n            return util_1.mustBeString(obj.string);\n        case \"bracedstring\":\n        case \"braced\":\n            if (!util_1.isArray(obj.data)) {\n                throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n            }\n            return new BracedString_1.BracedString(braceDepth, util_1.flattenMyArray(obj.data).map(function (e) {\n                return parseStringComponent(braceDepth + 1, e);\n            }));\n        case \"quotedstring\":\n            if (!util_1.isArray(obj.data)) {\n                throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n            }\n            var flattened = util_1.flattenMyArray(obj.data);\n            return new QuotedString_1.QuotedString(braceDepth, flattened.map(function (e) {\n                return parseStringComponent(braceDepth, e);\n            }));\n        default:\n            throw new Error(\"Unexpected complex string type: \" + obj.type);\n    }\n}\nexports.parseStringComponent = parseStringComponent;\nfunction toStringBibStringDatum(data) {\n    if (util_1.isString(data)) return data;\n    if (util_1.isNumber(data)) return data + \"\";\n    if (BracedString_1.isBracedString(data) || QuotedString_1.isQuotedString(data) || QuotedString_1.isOuterQuotedString(data) || BracedString_1.isOuterBracedString(data)) return toStringBibStringData(data.data);\n    throw new Error(JSON.stringify(data));\n}\nexports.toStringBibStringDatum = toStringBibStringDatum;\nfunction toStringBibStringData(data) {\n    return data.map(toStringBibStringDatum).join(\"\");\n}\nexports.toStringBibStringData = toStringBibStringData;\nfunction flattenQuotedStrings(data, hideQuotes) {\n    var result = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var datum = _step.value;\n\n            var flattenned = flattenQuotedString(datum, hideQuotes);\n            if (util_1.isArray(flattenned)) {\n                result = result.concat(flattenned);\n            } else {\n                result.push(flattenned);\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return result;\n}\nexports.flattenQuotedStrings = flattenQuotedStrings;\nvar doubleQuotes = [\"\\\"\"];\nfunction flattenQuotedString(data, hideQuotes) {\n    if (BracedString_1.isBracedString(data)) return data;\n    if (QuotedString_1.isQuotedString(data)) {\n        var flattenedQuotedString = flattenQuotedStrings(data.data, true);\n        if (util_1.isArray(flattenedQuotedString)) {\n            return hideQuotes ? flattenedQuotedString : doubleQuotes.concat(flattenedQuotedString).concat(doubleQuotes);\n        } else if (hideQuotes) return flattenedQuotedString;else return [\"\\\"\", flattenedQuotedString, \"\\\"\"];\n    }\n    if (QuotedString_1.isOuterQuotedString(data)) return flattenQuotedStrings(data.data, true);\n    if (BracedString_1.isOuterBracedString(data)) return flattenQuotedStrings(data.data, false);\n    if (util_1.isString(data) || util_1.isNumber(data)) return data;\n    if (StringRef_1.isStringRef(data)) throw new Error(\"StringRef should be resolved at this point!\");else throw new Error();\n}\nfunction globContiguousStrings(data) {\n    var result = [];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var element = _step2.value;\n\n            if (util_1.isString(element) || util_1.isNumber(element)) {\n                if (result.length <= 0) {\n                    var contiguousSimpleString = {\n                        type: \"ContiguousSimpleString\",\n                        data: [element]\n                    };\n                    result.push(contiguousSimpleString);\n                } else {\n                    var lastElement = result[result.length - 1];\n                    if (isContiguousSimpleString(lastElement)) {\n                        lastElement.data.push(element);\n                    } else {\n                        var _contiguousSimpleString = {\n                            type: \"ContiguousSimpleString\",\n                            data: [element]\n                        };\n                        result.push(_contiguousSimpleString);\n                    }\n                }\n            } else {\n                result.push(element);\n            }\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n\n    return result;\n}\nexports.globContiguousStrings = globContiguousStrings;\nfunction splitOnAnd(data) {\n    return splitOnPattern(data, /\\s+and\\s+/g);\n}\nexports.splitOnAnd = splitOnAnd;\nfunction splitOnComma(data) {\n    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n\n    return splitOnPattern(data, /\\s*,\\s*/g, limit);\n}\nexports.splitOnComma = splitOnComma;\nfunction splitOnPattern(data, pattern, stopAfter) {\n    var splitted = [];\n    var buffer = [];\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var datum = _step3.value;\n\n            if (util_1.isString(datum) && (stopAfter === undefined || stopAfter > 0)) {\n                var match = pattern.exec(datum);\n                var end = 0;\n                if (match) {\n                    do {\n                        var prevEnd = end;\n                        end = match.index + match[0].length;\n                        buffer.push(datum.substring(prevEnd, match.index));\n                        if (stopAfter === undefined || stopAfter > 0) {\n                            splitted.push(buffer);\n                            buffer = [];\n                            if (stopAfter !== undefined && stopAfter > 0) stopAfter--;\n                        }\n                        if (stopAfter === undefined || stopAfter > 0) match = pattern.exec(datum);else match = undefined;\n                    } while (match);\n                    if (end > 0 && end < datum.length) buffer.push(datum.substring(end));\n                } else {\n                    buffer.push(datum);\n                }\n            } else buffer.push(datum);\n        }\n    } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n            }\n        } finally {\n            if (_didIteratorError3) {\n                throw _iteratorError3;\n            }\n        }\n    }\n\n    if (buffer.length > 0) splitted.push(buffer);\n    return splitted;\n}\nexports.splitOnPattern = splitOnPattern;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar nearley = __webpack_require__(22);\nvar ts_parser_1 = __webpack_require__(21);\nvar util_1 = __webpack_require__(0);\nvar KeyVal_1 = __webpack_require__(5);\nvar BibEntry_1 = __webpack_require__(10);\nvar BibComment_1 = __webpack_require__(9);\nvar BibPreamble_1 = __webpack_require__(11);\nvar BibStringEntry_1 = __webpack_require__(3);\nvar Lexer_1 = __webpack_require__(20);\n\nvar BibFile = function () {\n    function BibFile(content) {\n        var _this = this;\n\n        _classCallCheck(this, BibFile);\n\n        this.content = content;\n        this.comments = content.filter(BibComment_1.isBibComment).map(function (c) {\n            if (BibComment_1.isBibComment(c)) return c;else throw new Error();\n        });\n        this.preambles_raw = content.filter(function (c) {\n            return BibPreamble_1.isPreamble(c);\n        }).map(function (c) {\n            if (BibPreamble_1.isPreamble(c)) return c;else throw new Error();\n        });\n        this.preamble$ = this.preambles_raw.map(function (p) {\n            return p.toString();\n        }).join(\"\\n\");\n        var strings = {};\n        this.content.forEach(function (entry) {\n            if (KeyVal_1.isKeyVal(entry)) {\n                if (!!strings[entry.key]) throw new Error(\"String with id \" + entry.key + \" was defined more than once\");\n                strings[entry.key] = entry.value;\n            }\n        });\n        this.strings_raw = strings;\n        this.strings$ = BibStringEntry_1.resolveStrings(strings);\n        this.entries_raw = content.filter(function (c) {\n            return BibEntry_1.isBibEntry(c);\n        }).map(function (c) {\n            if (BibEntry_1.isBibEntry(c)) return c;else throw new Error();\n        });\n        var entryMap = {};\n        this.entries_raw.forEach(function (entry) {\n            var key = entry._id.toLowerCase();\n            if (!!entryMap[key]) throw new Error(\"Entry with id \" + key + \" was defined more than once\");\n            entryMap[key] = BibEntry_1.processEntry(entry, _this.strings$);\n        });\n        this.entries$ = entryMap;\n    }\n\n    _createClass(BibFile, [{\n        key: \"getEntry\",\n        value: function getEntry(id) {\n            return this.entries$[id.toLowerCase()];\n        }\n    }]);\n\n    return BibFile;\n}();\n\nexports.BibFile = BibFile;\nfunction parseNonEntry(nonEntry) {\n    if (!util_1.isArray(nonEntry.data) || nonEntry.type !== \"NON_ENTRY\") throw new Error();\n    return new BibComment_1.BibComment(BibComment_1.flattenPlainText(nonEntry.data));\n}\nfunction parseEntry(entry) {\n    switch (typeof entry === \"undefined\" ? \"undefined\" : _typeof(entry)) {\n        case \"object\":\n            var data = entry.data;\n            if (typeof data[\"@type\"] === \"string\") {\n                return new BibEntry_1.BibEntry(data[\"@type\"], data._id, BibEntry_1.parseEntryFields(data.fields));\n            }\n            var type = util_1.mustBeString(data.type);\n            switch (type) {\n                case \"string\":\n                    return BibStringEntry_1.newStringEntry(data);\n                case \"preamble\":\n                    return BibPreamble_1.newPreambleNode(data);\n                default:\n                    throw new Error(\"Unexpected entry parsed: \" + data.type);\n            }\n        default:\n            throw new Error(\"Expected object as data for entry\");\n    }\n}\nexports.parseBibEntriesAndNonEntries = function (parse) {\n    return parse.map(function (entity) {\n        switch (entity.type) {\n            case \"NON_ENTRY\":\n                return parseNonEntry(entity);\n            case \"ENTRY\":\n                return parseEntry(entity);\n            default:\n                throw new Error(\"Expected ENTRY or NON_ENTRY\");\n        }\n    });\n};\nfunction parseBibFile(input) {\n    var p = new nearley.Parser(ts_parser_1.grammar.ParserRules, ts_parser_1.grammar.ParserStart);\n    p.feed(new Lexer_1.default(input).readTokens());\n    var res = p.results;\n    var parse = res[0];\n    return new BibFile(exports.parseBibEntriesAndNonEntries(parse));\n}\nexports.parseBibFile = parseBibFile;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(0);\n\nvar BibComment = function () {\n    function BibComment(data) {\n        _classCallCheck(this, BibComment);\n\n        this.type = \"comment\";\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    _createClass(BibComment, [{\n        key: \"toString\",\n        value: function toString() {\n            return this.string;\n        }\n    }]);\n\n    return BibComment;\n}();\n\nexports.BibComment = BibComment;\n\nvar CommentEntry = function () {\n    function CommentEntry(type, data) {\n        _classCallCheck(this, CommentEntry);\n\n        this.type = type;\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    _createClass(CommentEntry, [{\n        key: \"toString\",\n        value: function toString() {\n            return this.string;\n        }\n    }]);\n\n    return CommentEntry;\n}();\n\nexports.CommentEntry = CommentEntry;\nfunction isBibComment(n) {\n    return n.type === \"comment\" && util_1.isArray(n.data);\n}\nexports.isBibComment = isBibComment;\nvar flattenO = function flattenO(wrapper) {\n    return util_1.isString(wrapper) ? wrapper : typeof wrapper === \"number\" ? wrapper.toString() : wrapper[\"type\"] === \"@bib\" ? \"@\" + util_1.mustBeString(wrapper.string) : wrapper[\"type\"] === \"escapedEntry\" ? \"\\\\\" + flattenO(wrapper.data) : util_1.mustBeString(wrapper.string);\n};\nfunction flattenPlainText(data) {\n    return util_1.flattenMyArray(data).map(flattenO);\n}\nexports.flattenPlainText = flattenPlainText;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Authors_1 = __webpack_require__(15);\nvar mandatory_and_optional_fields_1 = __webpack_require__(16);\nvar BibStringEntry_1 = __webpack_require__(3);\nvar KeyVal_1 = __webpack_require__(5);\n\nvar BibEntry = function () {\n    function BibEntry(type, id, fields) {\n        _classCallCheck(this, BibEntry);\n\n        this.type = type;\n        this._id = id;\n        this.fields = fields;\n        this.sortkey$ = \"\";\n        this.title$ = \"\";\n    }\n\n    _createClass(BibEntry, [{\n        key: \"getField\",\n        value: function getField(key) {\n            return this.fields[key.toLowerCase()];\n        }\n    }, {\n        key: \"getAuthors\",\n        value: function getAuthors() {\n            var field = this.fields[\"author\"];\n            if (field === undefined) return field;\n            return Authors_1.mustBeAuthors(field);\n        }\n    }]);\n\n    return BibEntry;\n}();\n\nexports.BibEntry = BibEntry;\nfunction parseEntryFields(fields) {\n    var fieldz = {};\n    Object.keys(fields).forEach(function (key) {\n        switch (key) {\n            default:\n                fieldz[key] = KeyVal_1.parseFieldValue(fields[key]);\n                break;\n        }\n    });\n    return fieldz;\n}\nexports.parseEntryFields = parseEntryFields;\nfunction isBibEntry(x) {\n    return typeof x[\"type\"] === \"string\" && typeof x[\"_id\"] === \"string\" && !!x[\"fields\"];\n}\nexports.isBibEntry = isBibEntry;\nfunction processEntry(entry, strings$) {\n    if (mandatory_and_optional_fields_1.hasMandatoryFields(entry.type)) mandatory_and_optional_fields_1.mandatoryFields[entry.type].map(function (e) {\n        return mandatory_and_optional_fields_1.findError(entry, e);\n    }).forEach(function (e) {\n        if (!!e) console.warn(e.message);\n    });\n    var processedFields = {};\n    var fields$ = entry.fields;\n    Object.keys(entry.fields).forEach(function (key) {\n        var field$ = BibStringEntry_1.resolveStringReference({}, processedFields, strings$, fields$[key]);\n        switch (key) {\n            case \"author\":\n                processedFields[key] = new Authors_1.Authors(field$);\n                break;\n            case \"title\":\n                processedFields[key] = field$;\n                break;\n            case \"incollection\":\n            default:\n                processedFields[key] = field$;\n                break;\n        }\n    });\n    return new BibEntry(entry.type, entry._id, processedFields);\n}\nexports.processEntry = processEntry;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(0);\nvar BibFile_1 = __webpack_require__(8);\n\nvar Preamble = function () {\n    function Preamble(data) {\n        _classCallCheck(this, Preamble);\n\n        this.type = \"preamble\";\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    _createClass(Preamble, [{\n        key: \"toString\",\n        value: function toString() {\n            return this.string;\n        }\n    }]);\n\n    return Preamble;\n}();\n\nexports.Preamble = Preamble;\nfunction isPreamble(x) {\n    return x.type === \"preamble\" && !!x.data;\n}\nexports.isPreamble = isPreamble;\nfunction newPreambleNode(data) {\n    var flattened = BibFile_1.parseBibEntriesAndNonEntries(util_1.mustBeArray(data.data));\n    return new Preamble(flattened);\n}\nexports.newPreambleNode = newPreambleNode;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction newNumber(string) {\n    return {\n        type: \"number\",\n        string: string\n    };\n}\nexports.newNumber = newNumber;\nexports.numericChars = {\n    \"0\": true,\n    \"1\": true,\n    \"2\": true,\n    \"3\": true,\n    \"4\": true,\n    \"5\": true,\n    \"6\": true,\n    \"7\": true,\n    \"8\": true,\n    \"9\": true\n};\nfunction isNum(c) {\n    return exports.numericChars.hasOwnProperty(c);\n}\nexports.isNum = isNum;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction newToken(type, string) {\n    return {\n        type: type,\n        string: string\n    };\n}\nexports.newToken = newToken;\nexports.specialChars = {\n    \"@\": true,\n    \"(\": true,\n    \")\": true,\n    \"{\": true,\n    \"}\": true,\n    \"#\": true,\n    \"=\": true,\n    \",\": true,\n    \"\\\\\": true,\n    \"\\\"\": true\n};\nfunction isSpecialChar(c) {\n    return exports.specialChars.hasOwnProperty(c);\n}\nexports.isSpecialChar = isSpecialChar;\nexports.escapableChars = {\n    \"\\\\\": true,\n    \"@\": true,\n    \"{\": true,\n    \"}\": true\n};\nfunction isEscapableChar(c) {\n    return exports.escapableChars.hasOwnProperty(c);\n}\nexports.isEscapableChar = isEscapableChar;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WS = \"ws\";\nfunction newWhitespace(string) {\n    return {\n        type: \"ws\",\n        string: string\n    };\n}\nexports.newWhitespace = newWhitespace;\nfunction isWhitespace(token) {\n    return typeof token.string === \"string\" && token.type === exports.WS;\n}\nexports.isWhitespace = isWhitespace;\nexports.singleWhitespaces = {\n    \" \": true,\n    \"\\t\": true,\n    \"\\r\": true,\n    \"\\n\": true\n};\nfunction isSingleWhiteSpaceCharacter(c) {\n    return exports.singleWhitespaces.hasOwnProperty(c);\n}\nexports.isSingleWhiteSpaceCharacter = isSingleWhiteSpaceCharacter;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(0);\nvar QuotedString_1 = __webpack_require__(1);\nvar BibStringComponent_1 = __webpack_require__(6);\nvar bib_string_utils_1 = __webpack_require__(7);\n\nvar Authors = function (_BibStringComponent_) {\n    _inherits(Authors, _BibStringComponent_);\n\n    function Authors(fieldValue) {\n        _classCallCheck(this, Authors);\n\n        var data = util_1.isNumber(fieldValue) ? [fieldValue] : fieldValue.data;\n\n        var _this = _possibleConstructorReturn(this, (Authors.__proto__ || Object.getPrototypeOf(Authors)).call(this, \"authors\", data));\n\n        var authorNames = determineAuthorNames$(fieldValue);\n        _this.authors$ = authorNames.map(function (name) {\n            return parseAuthor(name);\n        });\n        return _this;\n    }\n\n    return Authors;\n}(BibStringComponent_1.BibOuterStringComponent);\n\nexports.Authors = Authors;\nfunction parseAuthor(data) {\n    return data;\n}\nfunction determineAuthorNames$(data) {\n    if (util_1.isNumber(data)) {\n        return determineAuthorNames([data]);\n    } else {\n        return determineAuthorNames(data.data, QuotedString_1.isOuterQuotedString(data));\n    }\n}\nexports.determineAuthorNames$ = determineAuthorNames$;\nfunction determineAuthorNames(data, hideQuotes) {\n    var globbed = bib_string_utils_1.globContiguousStrings(bib_string_utils_1.flattenQuotedStrings(data, hideQuotes));\n    var normalizedString = globbed.map(function (e) {\n        return bib_string_utils_1.isContiguousSimpleString(e) ? bib_string_utils_1.joinContiguousSimpleStrings(e) : e;\n    });\n    return bib_string_utils_1.splitOnAnd(normalizedString);\n}\nfunction mustBeAuthors(x) {\n    if (!isAuthors(x)) throw new Error();\n    return x;\n}\nexports.mustBeAuthors = mustBeAuthors;\nfunction isAuthors(x) {\n    return util_1.isArray(x[\"authors$\"]) && x.type === \"authors\";\n}\nexports.isAuthors = isAuthors;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(0);\nexports.address = \"address\";\nexports.author = \"author\";\nexports.booktitle = \"booktitle\";\nexports.chapter = \"chapter\";\nexports.edition = \"edition\";\nexports.editor = \"editor\";\nexports.howpublished = \"howpublished\";\nexports.institution = \"institution\";\nexports.journal = \"journal\";\nexports.month = \"month\";\nexports.note = \"note\";\nexports.number = \"number\";\nexports.organization = \"organization\";\nexports.pages = \"pages\";\nexports.publisher = \"publisher\";\nexports.school = \"school\";\nexports.series = \"series\";\nexports.title = \"title\";\nexports.type = \"type\";\nexports.volume = \"volume\";\nexports.year = \"year\";\nexports.optionalFields = {\n    \"book\": [[\"volume\", \"number\"], \"series\", \"address\", \"edition\", \"month\", \"note\"],\n    \"booklet\": [\"author\", \"howpublished\", \"address\", \"address\", \"month\", \"year\", \"note\"],\n    \"conference\": [\"editor\", [\"volume\", \"number\"], \"series\", \"pages\", \"address\", \"month\", \"organization\", \"publisher\", \"note\"],\n    \"inproceedings\": [\"editor\", [\"volume\", \"number\"], exports.series, \"pages\", \"address\", \"month\", \"organization\", \"publisher\", \"note\"],\n    \"inbook\": [\"volume\", \"number\", \"series\", \"type\", \"address\", \"edition\", \"month\", \"note\"],\n    \"incollection\": [\"editor\", [\"volume\", \"number\"], \"series\", \"type\", \"chapter\", \"pages\", \"address\", \"edition\", \"month\", \"note\"],\n    \"manual\": [\"author\", \"organization\", \"year\", \"address\", \"edition\", \"month\", \"note\"],\n    \"mastersthesis\": [\"type\", \"address\", \"month\", \"note\"],\n    \"misc\": [],\n    \"phdthesis\": [\"type\", \"address\", \"month\", \"note\"],\n    \"proceedings\": [\"editor\", [\"volume\", \"number\"], \"series\", \"address\", \"month\", \"organization\", \"publisher\", \"note\"],\n    \"techreport\": [\"type\", \"address\", \"number\", \"month\", \"note\"],\n    \"unpublished\": [\"month\", \"year\"]\n};\nexports.mandatoryFields = {\n    \"article\": [\"author\", \"title\", \"year\", \"journal\"],\n    \"book\": [[\"author\", \"editor\"], \"title\", \"publisher\", \"year\"],\n    \"booklet\": [\"title\"],\n    \"conference\": [\"author\", \"title\", \"booktitle\", \"year\"],\n    \"inproceedings\": [\"author\", \"title\", \"booktitle\", \"year\"],\n    \"inbook\": [[\"author\", \"editor\"], \"title\", [\"chapter\", \"pages\"]],\n    \"incollection\": [\"author\", \"title\", \"booktitle\", \"publisher\", \"year\"],\n    \"manual\": [\"title\"],\n    \"mastersthesis\": [\"author\", \"title\", \"school\", \"year\"],\n    \"misc\": [[\"author\", \"title\", \"howpublished\", \"year\", \"month\", \"note\"]],\n    \"phdthesis\": [\"author\", \"title\", \"school\", \"year\"],\n    \"proceedings\": [\"year\", \"title\"],\n    \"techreport\": [\"author\", \"title\", \"institution\", \"year\"],\n    \"unpublished\": [\"author\", \"title\", \"note\"]\n};\nfunction hasOptionalFields(s) {\n    return exports.optionalFields.hasOwnProperty(s);\n}\nexports.hasOptionalFields = hasOptionalFields;\nfunction hasMandatoryFields(s) {\n    return exports.mandatoryFields.hasOwnProperty(s);\n}\nexports.hasMandatoryFields = hasMandatoryFields;\nfunction getMandatoryFields(s) {\n    if (hasMandatoryFields(s)) {\n        return exports.mandatoryFields[s];\n    } else {\n        return [];\n    }\n}\nexports.getMandatoryFields = getMandatoryFields;\nfunction getOptionalFields(s) {\n    if (hasOptionalFields(s)) {\n        return exports.optionalFields[s];\n    } else {\n        return [];\n    }\n}\nexports.getOptionalFields = getOptionalFields;\nexports.findError = function (entry, field) {\n    var fields = entry.fields;\n    if (util_1.isString(field)) {\n        if (!fields[field]) return new Error(\"Warning: expected \" + entry.type + \" with id \" + entry._id + \" to have the field: \" + field);\n    } else if (util_1.isArray(field)) {\n        var hasAllFields = field.reduce(function (acc, fieldName) {\n            if (util_1.isString(fieldName)) {\n                return acc && fields.hasOwnProperty(fieldName);\n            } else throw new Error();\n        }, true);\n        if (!hasAllFields) {\n            return new Error(\"Expected \" + entry.type + \" with id \" + entry._id + \" to have one of the following fields: \" + field);\n        }\n    }\n};\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction __export(m) {\n    for (var p in m) {\n        if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(8));\n__export(__webpack_require__(10));\n__export(__webpack_require__(9));\n__export(__webpack_require__(11));\n__export(__webpack_require__(1));\n__export(__webpack_require__(2));\n__export(__webpack_require__(3));\n__export(__webpack_require__(4));\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bibTypes = {\n    string: \"@string\",\n    preamble: \"@preamble\",\n    comment: \"@comment\",\n    bib: \"@bib\"\n};\nexports.isBibType = function (c) {\n    return exports.bibTypes.hasOwnProperty(c);\n};\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Token_1 = __webpack_require__(13);\nvar WhitespaceToken_1 = __webpack_require__(14);\nvar NumericToken_1 = __webpack_require__(12);\nfunction newIdToken(string) {\n    return {\n        type: \"id\",\n        string: string\n    };\n}\nexports.newIdToken = newIdToken;\nfunction isIdToken(string) {\n    return string.type === \"id\" && typeof string.string === \"string\";\n}\nexports.isIdToken = isIdToken;\nfunction isIdChar(c) {\n    return !(Token_1.isSpecialChar(c) || NumericToken_1.isNum(c) || WhitespaceToken_1.isSingleWhiteSpaceCharacter(c));\n}\nexports.isIdChar = isIdChar;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Token_1 = __webpack_require__(13);\nvar WhitespaceToken_1 = __webpack_require__(14);\nvar NumericToken_1 = __webpack_require__(12);\nvar IdToken_1 = __webpack_require__(19);\nvar BibBlockTypes_1 = __webpack_require__(18);\n\nvar Lexer = function () {\n    function Lexer(string) {\n        _classCallCheck(this, Lexer);\n\n        this.str = string;\n        this.len = string.length;\n        this.pos = 0;\n    }\n\n    _createClass(Lexer, [{\n        key: \"getStringUntilNonEscapedChar\",\n        value: function getStringUntilNonEscapedChar(terminalRegex) {\n            var chars = [];\n            for (var i = this.pos; i < this.len + 1; i++) {\n                this.pos = i;\n                if (this.str.charAt(i) == \"\\\\\" && this.str.charAt(i + 1).match(terminalRegex)) {\n                    i++;\n                    this.pos = i;\n                } else if (this.str.charAt(i).match(terminalRegex)) {\n                    break;\n                }\n                chars.push(this.str.charAt(i));\n            }\n            return chars.join(\"\");\n        }\n    }, {\n        key: \"readTokens\",\n        value: function readTokens() {\n            var tokens = [];\n            var nextToken = void 0;\n            while (nextToken = this.readNextToken()) {\n                tokens.push(nextToken);\n            }return tokens;\n        }\n    }, {\n        key: \"readNextToken\",\n        value: function readNextToken() {\n            if (this.pos >= this.str.length) return undefined;\n            var currentChar = this.str.charAt(this.pos);\n            if (WhitespaceToken_1.isSingleWhiteSpaceCharacter(currentChar)) return this.eatWhiteSpace();else if (Token_1.isSpecialChar(currentChar)) {\n                return this.eatSpecialChars(currentChar);\n            } else if (NumericToken_1.isNum(currentChar)) {\n                return this.eatNumericString(currentChar);\n            } else {\n                return this.eatIdString();\n            }\n        }\n    }, {\n        key: \"eatIdString\",\n        value: function eatIdString() {\n            var chars = [];\n            var pos2 = this.pos;\n            for (var i = pos2; i < this.len + 1; i++) {\n                this.pos = i;\n                var charAtI = this.str.charAt(i);\n                if (!IdToken_1.isIdChar(charAtI)) {\n                    break;\n                } else {\n                    chars.push(charAtI);\n                }\n            }\n            return IdToken_1.newIdToken(chars.join(\"\").trim());\n        }\n    }, {\n        key: \"eatNumericString\",\n        value: function eatNumericString(startAt) {\n            var nums = [startAt];\n            var nextPos = this.pos + 1;\n            for (var newPos = nextPos; newPos < this.len + 1; newPos++) {\n                this.pos = newPos;\n                var newChar = this.str.charAt(newPos);\n                if (NumericToken_1.isNum(newChar)) nums.push(newChar);else break;\n            }\n            var numericString = nums.join(\"\");\n            if (nums[0] === \"0\") return NumericToken_1.newNumber(numericString);else {\n                var number = Number.parseInt(numericString);\n                return Number.isFinite(number) ? number : NumericToken_1.newNumber(numericString);\n            }\n        }\n    }, {\n        key: \"eatSpecialChars\",\n        value: function eatSpecialChars(startAt) {\n            this.pos++;\n            if (startAt === \"@\") {\n                var type = this.getStringUntilNonEscapedChar(\"{\").trim().toLowerCase();\n                if (BibBlockTypes_1.isBibType(type)) return Token_1.newToken(BibBlockTypes_1.bibTypes[type], type);else return Token_1.newToken(\"@bib\", type);\n            }\n            return startAt;\n        }\n    }, {\n        key: \"eatWhiteSpace\",\n        value: function eatWhiteSpace() {\n            var chars = [];\n            while (this.pos < this.len + 1) {\n                var c = this.str.charAt(this.pos);\n                if (WhitespaceToken_1.isSingleWhiteSpaceCharacter(c)) {\n                    chars.push(c);\n                    this.pos++;\n                } else break;\n            }\n            return WhitespaceToken_1.newWhitespace(chars.join(\"\"));\n        }\n    }]);\n\n    return Lexer;\n}();\n\nexports.default = Lexer;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction id(x) {\n    return x[0];\n}\nvar isNumber = function isNumber(x) {\n    return x.constructor === Number || (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"number\";\n};\nvar tok_id = {\n    test: function test(x) {\n        return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"id\";\n    }\n};\nvar entry_type_bib = {\n    test: function test(x) {\n        return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"@bib\";\n    }\n};\nvar entry_type_string = {\n    test: function test(x) {\n        return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"@string\";\n    }\n};\nvar entry_type_preamble = {\n    test: function test(x) {\n        return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"@preamble\";\n    }\n};\nvar entry_type_comment = {\n    test: function test(x) {\n        return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"@comment\";\n    }\n};\nvar ws = {\n    test: function test(x) {\n        return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"ws\";\n    }\n};\nvar num = { test: isNumber };\nvar pound = { literal: \"#\" };\nvar eq = { literal: \"=\" };\nvar esc = { literal: \"\\\\\" };\nvar paren_l = { literal: \"(\" };\nvar paren_r = { literal: \")\" };\nvar brace_l = { literal: \"{\" };\nvar brace_r = { literal: \"}\" };\nvar quote_dbl = { literal: \"\\\"\" };\nvar comma = { literal: \",\" };\nfunction addToObj(obj, keyval) {\n    if (keyval.type !== \"keyval\") throw new Error(\"Expected a keyval object\");\n    var key = keyval.key.toLowerCase();\n    if (obj.fields[key]) {\n        console.log(\"WARNING: field '\" + key + \"' was already defined on \" + obj[\"@type\"] + \" object with id '\" + obj._id + \"'. Ignoring this value.\");\n        return;\n    } else {\n        obj.fields[key] = keyval.value;\n        return obj;\n    }\n}\nfunction joinTokens(arr) {\n    var strs = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (_typeof(arr[i]) === \"object\") {\n            if (!arr[i].string) throw new Error(\"Expected token to have a string field called 'string' in object \" + JSON.stringify(arr[i]));\n            strs.push(arr[i].string);\n        } else if (typeof arr[i] === \"string\" || typeof arr[i] === \"number\") {\n            strs.push(arr[i]);\n        } else throw new Error(\"Could not handle token \" + JSON.stringify(arr[i]) + \" in array \" + JSON.stringify(arr));\n    }\n    return strs.join(\"\");\n}\nexports.grammar = {\n    Lexer: undefined,\n    ParserRules: [{ \"name\": \"main$ebnf$1\", \"symbols\": [\"non_entry\"], \"postprocess\": id }, {\n        \"name\": \"main$ebnf$1\", \"symbols\": [], \"postprocess\": function postprocess() {\n            return undefined;\n        }\n    }, { \"name\": \"main$ebnf$2\", \"symbols\": [] }, { \"name\": \"main$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [\"non_entry\"], \"postprocess\": id }, {\n        \"name\": \"main$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function postprocess() {\n            return undefined;\n        }\n    }, { \"name\": \"main$ebnf$2$subexpression$1\", \"symbols\": [\"entry\", \"main$ebnf$2$subexpression$1$ebnf$1\"] }, {\n        \"name\": \"main$ebnf$2\",\n        \"symbols\": [\"main$ebnf$2\", \"main$ebnf$2$subexpression$1\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"main\",\n        \"symbols\": [\"main$ebnf$1\", \"main$ebnf$2\"],\n        \"postprocess\": function postprocess(data) {\n            var topLevelObjects = [];\n            if (data[0]) topLevelObjects.push({ type: \"NON_ENTRY\", data: data[0] });\n            for (var i = 0; i < data[1].length; i++) {\n                topLevelObjects.push({ type: \"ENTRY\", data: data[1][i][0] });\n                if (data[1][i][1]) topLevelObjects.push({ type: \"NON_ENTRY\", data: data[1][i][1] });\n            }\n            return topLevelObjects;\n        }\n    }, { \"name\": \"_$ebnf$1\", \"symbols\": [] }, {\n        \"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", ws], \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, { \"name\": \"_\", \"symbols\": [\"_$ebnf$1\"] }, { \"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_bib] }, { \"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_string] }, { \"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_preamble] }, { \"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_comment] }, {\n        \"name\": \"entry_decl\",\n        \"symbols\": [\"entry_decl$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0];\n        }\n    }, { \"name\": \"entry$subexpression$1\", \"symbols\": [\"bib_entry\"] }, { \"name\": \"entry$subexpression$1\", \"symbols\": [\"string_entry\"] }, { \"name\": \"entry$subexpression$1\", \"symbols\": [\"preamble_entry\"] }, { \"name\": \"entry$subexpression$1\", \"symbols\": [\"comment_entry\"] }, {\n        \"name\": \"entry\", \"symbols\": [\"entry$subexpression$1\"], \"postprocess\": function postprocess(data) {\n            return data[0][0];\n        }\n    }, {\n        \"name\": \"comment\", \"symbols\": [\"main\"], \"postprocess\": function postprocess(data) {\n            return data[0];\n        }\n    }, { \"name\": \"comment_liberal$ebnf$1\", \"symbols\": [] }, { \"name\": \"comment_liberal$ebnf$1$subexpression$1\", \"symbols\": [/./] }, {\n        \"name\": \"comment_liberal$ebnf$1\",\n        \"symbols\": [\"comment_liberal$ebnf$1\", \"comment_liberal$ebnf$1$subexpression$1\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"comment_liberal\",\n        \"symbols\": [\"comment_liberal$ebnf$1\"],\n        \"postprocess\": function postprocess(data) {\n            var toeknz = [];\n            for (var tk = 0; tk < data[0].length; tk++) {\n                toeknz.push(data[0][tk][0]);\n            }return toeknz;\n        }\n    }, { \"name\": \"entry_body_comment$subexpression$1$macrocall$2\", \"symbols\": [\"comment\"] }, {\n        \"name\": \"entry_body_comment$subexpression$1$macrocall$1\",\n        \"symbols\": [paren_l, \"entry_body_comment$subexpression$1$macrocall$2\", paren_r],\n        \"postprocess\": function postprocess(data) {\n            return data[1];\n        }\n    }, { \"name\": \"entry_body_comment$subexpression$1\", \"symbols\": [\"entry_body_comment$subexpression$1$macrocall$1\"] }, { \"name\": \"entry_body_comment$subexpression$1$macrocall$4\", \"symbols\": [\"comment\"] }, {\n        \"name\": \"entry_body_comment$subexpression$1$macrocall$3\",\n        \"symbols\": [brace_l, \"entry_body_comment$subexpression$1$macrocall$4\", brace_r],\n        \"postprocess\": function postprocess(data) {\n            return data[1];\n        }\n    }, { \"name\": \"entry_body_comment$subexpression$1\", \"symbols\": [\"entry_body_comment$subexpression$1$macrocall$3\"] }, {\n        \"name\": \"entry_body_comment\",\n        \"symbols\": [\"entry_body_comment$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0][0];\n        }\n    }, { \"name\": \"entry_body_string$subexpression$1$macrocall$2\", \"symbols\": [\"keyval\"] }, {\n        \"name\": \"entry_body_string$subexpression$1$macrocall$1\",\n        \"symbols\": [paren_l, \"_\", \"entry_body_string$subexpression$1$macrocall$2\", \"_\", paren_r],\n        \"postprocess\": function postprocess(data) {\n            return data[2];\n        }\n    }, { \"name\": \"entry_body_string$subexpression$1\", \"symbols\": [\"entry_body_string$subexpression$1$macrocall$1\"] }, { \"name\": \"entry_body_string$subexpression$1$macrocall$4\", \"symbols\": [\"keyval\"] }, {\n        \"name\": \"entry_body_string$subexpression$1$macrocall$3\",\n        \"symbols\": [brace_l, \"_\", \"entry_body_string$subexpression$1$macrocall$4\", \"_\", brace_r],\n        \"postprocess\": function postprocess(data) {\n            return data[2];\n        }\n    }, { \"name\": \"entry_body_string$subexpression$1\", \"symbols\": [\"entry_body_string$subexpression$1$macrocall$3\"] }, {\n        \"name\": \"entry_body_string\",\n        \"symbols\": [\"entry_body_string$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0][0];\n        }\n    }, { \"name\": \"entry_body_bib$subexpression$1$macrocall$2\", \"symbols\": [\"bib_content\"] }, {\n        \"name\": \"entry_body_bib$subexpression$1$macrocall$1\",\n        \"symbols\": [paren_l, \"_\", \"entry_body_bib$subexpression$1$macrocall$2\", \"_\", paren_r],\n        \"postprocess\": function postprocess(data) {\n            return data[2];\n        }\n    }, { \"name\": \"entry_body_bib$subexpression$1\", \"symbols\": [\"entry_body_bib$subexpression$1$macrocall$1\"] }, { \"name\": \"entry_body_bib$subexpression$1$macrocall$4\", \"symbols\": [\"bib_content\"] }, {\n        \"name\": \"entry_body_bib$subexpression$1$macrocall$3\",\n        \"symbols\": [brace_l, \"_\", \"entry_body_bib$subexpression$1$macrocall$4\", \"_\", brace_r],\n        \"postprocess\": function postprocess(data) {\n            return data[2];\n        }\n    }, { \"name\": \"entry_body_bib$subexpression$1\", \"symbols\": [\"entry_body_bib$subexpression$1$macrocall$3\"] }, {\n        \"name\": \"entry_body_bib\",\n        \"symbols\": [\"entry_body_bib$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0][0];\n        }\n    }, { \"name\": \"bib_content$ebnf$1\", \"symbols\": [] }, { \"name\": \"bib_content$ebnf$1$subexpression$1\", \"symbols\": [\"keyval\", \"_\", comma, \"_\"] }, {\n        \"name\": \"bib_content$ebnf$1\",\n        \"symbols\": [\"bib_content$ebnf$1\", \"bib_content$ebnf$1$subexpression$1\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, { \"name\": \"bib_content$ebnf$2$subexpression$1\", \"symbols\": [\"_\", comma] }, { \"name\": \"bib_content$ebnf$2\", \"symbols\": [\"bib_content$ebnf$2$subexpression$1\"], \"postprocess\": id }, {\n        \"name\": \"bib_content$ebnf$2\", \"symbols\": [], \"postprocess\": function postprocess() {\n            return undefined;\n        }\n    }, {\n        \"name\": \"bib_content\",\n        \"symbols\": [\"key_string\", \"_\", comma, \"_\", \"bib_content$ebnf$1\", \"keyval\", \"bib_content$ebnf$2\"],\n        \"postprocess\": function postprocess(data) {\n            var obj = {\n                _id: data[0],\n                fields: []\n            };\n            var keyvals = data[4];\n            for (var kv = 0; kv < keyvals.length; kv++) {\n                obj.fields.push(keyvals[kv][0]);\n            }\n            obj.fields.push(data[5]);\n            return obj;\n        }\n    }, {\n        \"name\": \"bib_entry\",\n        \"symbols\": [entry_type_bib, \"_\", \"entry_body_bib\"],\n        \"postprocess\": function postprocess(data) {\n            var obj = {\n                _id: data[2]._id\n            };\n            obj[\"@type\"] = data[0].string;\n            obj.fields = {};\n            var keyvals = data[2].fields;\n            for (var kv = 0; kv < keyvals.length; kv++) {\n                addToObj(obj, keyvals[kv]);\n            }\n            return obj;\n        }\n    }, {\n        \"name\": \"string_entry\",\n        \"symbols\": [entry_type_string, \"_\", \"entry_body_string\"],\n        \"postprocess\": function postprocess(data) {\n            return { type: \"string\", data: data[2] };\n        }\n    }, {\n        \"name\": \"preamble_entry\",\n        \"symbols\": [entry_type_preamble, \"_\", \"entry_body_comment\"],\n        \"postprocess\": function postprocess(data) {\n            return { type: \"preamble\", data: data[2] };\n        }\n    }, {\n        \"name\": \"comment_entry\",\n        \"symbols\": [entry_type_comment, \"_\", \"entry_body_comment\"],\n        \"postprocess\": function postprocess(data) {\n            return { type: \"comment\", data: data[2] };\n        }\n    }, {\n        \"name\": \"keyval\",\n        \"symbols\": [\"key_string\", \"_\", eq, \"_\", \"value_string\"],\n        \"postprocess\": function postprocess(data) {\n            return { type: \"keyval\", key: data[0], value: data[4] };\n        }\n    }, { \"name\": \"braced_string$ebnf$1\", \"symbols\": [] }, { \"name\": \"braced_string$ebnf$1$subexpression$1\", \"symbols\": [\"non_brace\"] }, { \"name\": \"braced_string$ebnf$1$subexpression$1\", \"symbols\": [\"braced_string\"] }, {\n        \"name\": \"braced_string$ebnf$1\",\n        \"symbols\": [\"braced_string$ebnf$1\", \"braced_string$ebnf$1$subexpression$1\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"braced_string\",\n        \"symbols\": [brace_l, \"braced_string$ebnf$1\", brace_r],\n        \"postprocess\": function postprocess(data) {\n            var tkz = [];\n            for (var i in data[1]) {\n                tkz.push(data[1][i][0]);\n            }return { type: \"braced\", data: tkz };\n        }\n    }, { \"name\": \"quoted_string$ebnf$1\", \"symbols\": [] }, { \"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_quote\"] }, { \"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"non_quote_non_brace\"] }, { \"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"braced_string\"] }, {\n        \"name\": \"quoted_string$ebnf$1\",\n        \"symbols\": [\"quoted_string$ebnf$1\", \"quoted_string$ebnf$1$subexpression$1\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"quoted_string\",\n        \"symbols\": [quote_dbl, \"quoted_string$ebnf$1\", quote_dbl],\n        \"postprocess\": function postprocess(data) {\n            var tks = [];\n            for (var i in data[1]) {\n                tks.push(data[1][i][0]);\n            }return { type: \"quotedstring\", data: tks };\n        }\n    }, { \"name\": \"escaped_quote\", \"symbols\": [esc, quote_dbl] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [tok_id] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_bib] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_string] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_preamble] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_comment] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [ws] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [num] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [pound] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [eq] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [esc] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [paren_l] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [paren_r] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [comma] }, { \"name\": \"non_quote_non_brace\", \"symbols\": [\"non_quote_non_brace$subexpression$1\"] }, { \"name\": \"key_string$ebnf$1\", \"symbols\": [\"stringreftoken\"] }, {\n        \"name\": \"key_string$ebnf$1\",\n        \"symbols\": [\"key_string$ebnf$1\", \"stringreftoken\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"key_string\", \"symbols\": [\"key_string$ebnf$1\"], \"postprocess\": function postprocess(data) {\n            return joinTokens(data[0]).toLowerCase();\n        }\n    }, { \"name\": \"value_string$subexpression$1$ebnf$1\", \"symbols\": [] }, {\n        \"name\": \"value_string$subexpression$1$ebnf$1$subexpression$1\",\n        \"symbols\": [\"_\", pound, \"_\", \"quoted_string_or_ref\"]\n    }, {\n        \"name\": \"value_string$subexpression$1$ebnf$1\",\n        \"symbols\": [\"value_string$subexpression$1$ebnf$1\", \"value_string$subexpression$1$ebnf$1$subexpression$1\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"value_string$subexpression$1\",\n        \"symbols\": [\"quoted_string_or_ref\", \"value_string$subexpression$1$ebnf$1\"]\n    }, { \"name\": \"value_string$subexpression$1\", \"symbols\": [\"braced_string\"] }, {\n        \"name\": \"value_string\",\n        \"symbols\": [\"value_string$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            var match = data[0];\n            if (match.length === 2) {\n                var tokenz = [];\n                tokenz.push(match[0]);\n                for (var i = 0; i < match[1].length; i++) {\n                    tokenz.push(match[1][i][3]);\n                }return { type: \"quotedstringwrapper\", data: tokenz };\n            } else if (match[0].type === \"braced\") return { type: \"bracedstringwrapper\", data: match[0].data };else throw new Error(\"Don't know how to handle value \" + JSON.stringify(match[0]));\n        }\n    }, { \"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [\"quoted_string\"] }, { \"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [\"string_ref\"] }, { \"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [num] }, {\n        \"name\": \"quoted_string_or_ref\",\n        \"symbols\": [\"quoted_string_or_ref$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            if (data[0][0].type === \"quotedstring\") return data[0][0];else {\n                return data[0][0];\n            }\n        }\n    }, { \"name\": \"string_ref$subexpression$1$ebnf$1\", \"symbols\": [] }, {\n        \"name\": \"string_ref$subexpression$1$ebnf$1\",\n        \"symbols\": [\"string_ref$subexpression$1$ebnf$1\", \"stringreftoken\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"string_ref$subexpression$1\",\n        \"symbols\": [\"stringreftoken_n_num\", \"string_ref$subexpression$1$ebnf$1\"]\n    }, {\n        \"name\": \"string_ref\",\n        \"symbols\": [\"string_ref$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            var str = data[0][0] + joinTokens(data[0][1]);\n            return { stringref: str };\n        }\n    }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [esc] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [paren_l] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [paren_r] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [tok_id] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [num] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_bib] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_string] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_preamble] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_comment] }, {\n        \"name\": \"stringreftoken\",\n        \"symbols\": [\"stringreftoken$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            if (_typeof(data[0][0]) === \"object\") {\n                if (!data[0][0].string) throw new Error(\"Expected \" + data[0] + \"to have a 'string' field\");\n                return data[0][0].string;\n            } else {\n                if (!(typeof data[0][0] === \"string\" || typeof data[0][0] === \"number\")) throw new Error(\"Expected \" + data[0][0] + \" to be a string\");\n                return data[0][0];\n            }\n        }\n    }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [esc] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [paren_l] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [paren_r] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [tok_id] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_bib] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_string] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_preamble] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_comment] }, {\n        \"name\": \"stringreftoken_n_num\",\n        \"symbols\": [\"stringreftoken_n_num$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            if (_typeof(data[0][0]) === \"object\") {\n                if (!data[0][0].string) throw new Error(\"Expected \" + data[0] + \"to have a 'string' field\");\n                return data[0][0].string;\n            } else {\n                if (!(typeof data[0][0] === \"string\" || typeof data[0][0] === \"number\")) throw new Error(\"Expected \" + data[0][0] + \" to be a string\");\n                return data[0][0];\n            }\n        }\n    }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [esc] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [paren_l] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [paren_r] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [tok_id] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [quote_dbl] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [ws] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [num] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [comma] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_bib] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_string] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_preamble] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_comment] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [pound] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [eq] }, {\n        \"name\": \"non_brace\",\n        \"symbols\": [\"non_brace$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0];\n        }\n    }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [esc] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [tok_id] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [quote_dbl] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [ws] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [num] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [comma] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_bib] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_string] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_preamble] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_comment] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [pound] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [eq] }, {\n        \"name\": \"non_bracket\",\n        \"symbols\": [\"non_bracket$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0];\n        }\n    }, { \"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_entry\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_escape\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_non_esc_outside_entry\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"non_esc_outside_entry\"] }, { \"name\": \"non_entry$ebnf$1\", \"symbols\": [\"non_entry$ebnf$1$subexpression$1\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_entry\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_escape\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_non_esc_outside_entry\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"non_esc_outside_entry\"] }, {\n        \"name\": \"non_entry$ebnf$1\",\n        \"symbols\": [\"non_entry$ebnf$1\", \"non_entry$ebnf$1$subexpression$2\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"non_entry\", \"symbols\": [\"non_entry$ebnf$1\"], \"postprocess\": function postprocess(data) {\n            var tokens = [];\n            for (var Ti = 0; Ti < data[0].length; Ti++) {\n                tokens.push(data[0][Ti][0]);\n            }return tokens;\n        }\n    }, {\n        \"name\": \"escaped_escape\", \"symbols\": [esc, esc], \"postprocess\": function postprocess() {\n            return \"\\\\\";\n        }\n    }, {\n        \"name\": \"escaped_entry\", \"symbols\": [esc, \"entry_decl\"], \"postprocess\": function postprocess(data) {\n            return { type: \"escapedEntry\", data: data[1] };\n        }\n    }, {\n        \"name\": \"escaped_non_esc_outside_entry\",\n        \"symbols\": [esc, \"non_esc_outside_entry\"],\n        \"postprocess\": function postprocess(data) {\n            return data;\n        }\n    }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [tok_id] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [ws] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [num] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [pound] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [eq] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [paren_l] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [paren_r] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [brace_l] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [brace_r] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [quote_dbl] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [comma] }, {\n        \"name\": \"non_esc_outside_entry\",\n        \"symbols\": [\"non_esc_outside_entry$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0];\n        }\n    }],\n    ParserStart: \"main\"\n};\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\nfunction Rule(name, symbols, postprocess) {\n    this.id = ++Rule.highestId;\n    this.name = name;\n    this.symbols = symbols;        // a list of literal | regex class | nonterminal\n    this.postprocess = postprocess;\n    return this;\n}\nRule.highestId = 0;\n\nRule.prototype.toString = function(withCursorAt) {\n    function stringifySymbolSequence (e) {\n        return e.literal ? JSON.stringify(e.literal) :\n               e.type ? '%' + e.type : e.toString();\n    }\n    var symbolSequence = (typeof withCursorAt === \"undefined\")\n                         ? this.symbols.map(stringifySymbolSequence).join(' ')\n                         : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                             + \"  \"\n                             + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n    return this.name + \"  \" + symbolSequence;\n}\n\n\n// a State is a rule at a position from a given starting point in the input stream (reference)\nfunction State(rule, dot, reference, wantedBy) {\n    this.rule = rule;\n    this.dot = dot;\n    this.reference = reference;\n    this.data = [];\n    this.wantedBy = wantedBy;\n    this.isComplete = this.dot === rule.symbols.length;\n}\n\nState.prototype.toString = function() {\n    return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n};\n\nState.prototype.nextState = function(child) {\n    var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n    state.left = this;\n    state.right = child;\n    if (state.isComplete) {\n        state.data = state.build();\n    }\n    return state;\n};\n\nState.prototype.build = function() {\n    var children = [];\n    var node = this;\n    do {\n        children.push(node.right.data);\n        node = node.left;\n    } while (node.left);\n    children.reverse();\n    return children;\n};\n\nState.prototype.finish = function() {\n    if (this.rule.postprocess) {\n        this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n    }\n};\n\n\nfunction Column(grammar, index) {\n    this.grammar = grammar;\n    this.index = index;\n    this.states = [];\n    this.wants = {}; // states indexed by the non-terminal they expect\n    this.scannable = []; // list of states that expect a token\n    this.completed = {}; // states that are nullable\n}\n\n\nColumn.prototype.process = function(nextColumn) {\n    var states = this.states;\n    var wants = this.wants;\n    var completed = this.completed;\n\n    for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n        var state = states[w];\n\n        if (state.isComplete) {\n            state.finish();\n            if (state.data !== Parser.fail) {\n                // complete\n                var wantedBy = state.wantedBy;\n                for (var i = wantedBy.length; i--; ) { // this line is hot\n                    var left = wantedBy[i];\n                    this.complete(left, state);\n                }\n\n                // special-case nullables\n                if (state.reference === this.index) {\n                    // make sure future predictors of this rule get completed.\n                    var exp = state.rule.name;\n                    (this.completed[exp] = this.completed[exp] || []).push(state);\n                }\n            }\n\n        } else {\n            // queue scannable states\n            var exp = state.rule.symbols[state.dot];\n            if (typeof exp !== 'string') {\n                this.scannable.push(state);\n                continue;\n            }\n\n            // predict\n            if (wants[exp]) {\n                wants[exp].push(state);\n\n                if (completed.hasOwnProperty(exp)) {\n                    var nulls = completed[exp];\n                    for (var i = 0; i < nulls.length; i++) {\n                        var right = nulls[i];\n                        this.complete(state, right);\n                    }\n                }\n            } else {\n                wants[exp] = [state];\n                this.predict(exp);\n            }\n        }\n    }\n}\n\nColumn.prototype.predict = function(exp) {\n    var rules = this.grammar.byName[exp] || [];\n\n    for (var i = 0; i < rules.length; i++) {\n        var r = rules[i];\n        var wantedBy = this.wants[exp];\n        var s = new State(r, 0, this.index, wantedBy);\n        this.states.push(s);\n    }\n}\n\nColumn.prototype.complete = function(left, right) {\n    var inp = right.rule.name;\n    if (left.rule.symbols[left.dot] === inp) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n}\n\n\nfunction Grammar(rules, start) {\n    this.rules = rules;\n    this.start = start || this.rules[0].name;\n    var byName = this.byName = {};\n    this.rules.forEach(function(rule) {\n        if (!byName.hasOwnProperty(rule.name)) {\n            byName[rule.name] = [];\n        }\n        byName[rule.name].push(rule);\n    });\n}\n\n// So we can allow passing (rules, start) directly to Parser for backwards compatibility\nGrammar.fromCompiled = function(rules, start) {\n    var lexer = rules.Lexer;\n    if (rules.ParserStart) {\n      start = rules.ParserStart;\n      rules = rules.ParserRules;\n    }\n    var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n    var g = new Grammar(rules, start);\n    g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n    return g;\n}\n\n\nfunction StreamLexer() {\n  this.reset(\"\");\n}\n\nStreamLexer.prototype.reset = function(data, state) {\n    this.buffer = data;\n    this.index = 0;\n    this.line = state ? state.line : 1;\n    this.lastLineBreak = state ? -state.col : 0;\n}\n\nStreamLexer.prototype.next = function() {\n    if (this.index < this.buffer.length) {\n        var ch = this.buffer[this.index++];\n        if (ch === '\\n') {\n          this.line += 1;\n          this.lastLineBreak = this.index;\n        }\n        return {value: ch};\n    }\n}\n\nStreamLexer.prototype.save = function() {\n  return {\n    line: this.line,\n    col: this.index - this.lastLineBreak,\n  }\n}\n\nStreamLexer.prototype.formatError = function(token, message) {\n    // nb. this gets called after consuming the offending token,\n    // so the culprit is index-1\n    var buffer = this.buffer;\n    if (typeof buffer === 'string') {\n        var nextLineBreak = buffer.indexOf('\\n', this.index);\n        if (nextLineBreak === -1) nextLineBreak = buffer.length;\n        var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n        var col = this.index - this.lastLineBreak;\n        message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n        message += \"  \" + line + \"\\n\"\n        message += \"  \" + Array(col).join(\" \") + \"^\"\n        return message;\n    } else {\n        return message + \" at index \" + (this.index - 1);\n    }\n}\n\n\nfunction Parser(rules, start, options) {\n    if (rules instanceof Grammar) {\n        var grammar = rules;\n        var options = start;\n    } else {\n        var grammar = Grammar.fromCompiled(rules, start);\n    }\n    this.grammar = grammar;\n\n    // Read options\n    this.options = {\n        keepHistory: false,\n        lexer: grammar.lexer || new StreamLexer,\n    };\n    for (var key in (options || {})) {\n        this.options[key] = options[key];\n    }\n\n    // Setup lexer\n    this.lexer = this.options.lexer;\n    this.lexerState = undefined;\n\n    // Setup a table\n    var column = new Column(grammar, 0);\n    var table = this.table = [column];\n\n    // I could be expecting anything.\n    column.wants[grammar.start] = [];\n    column.predict(grammar.start);\n    // TODO what if start rule is nullable?\n    column.process();\n    this.current = 0; // token index\n}\n\n// create a reserved token for indicating a parse fail\nParser.fail = {};\n\nParser.prototype.feed = function(chunk) {\n    var lexer = this.lexer;\n    lexer.reset(chunk, this.lexerState);\n\n    var token;\n    while (token = lexer.next()) {\n        // We add new states to table[current+1]\n        var column = this.table[this.current];\n\n        // GC unused states\n        if (!this.options.keepHistory) {\n            delete this.table[this.current - 1];\n        }\n\n        var n = this.current + 1;\n        var nextColumn = new Column(this.grammar, n);\n        this.table.push(nextColumn);\n\n        // Advance all tokens that expect the symbol\n        var literal = token.value;\n        var value = lexer.constructor === StreamLexer ? token.value : token;\n        var scannable = column.scannable;\n        for (var w = scannable.length; w--; ) {\n            var state = scannable[w];\n            var expect = state.rule.symbols[state.dot];\n            // Try to consume the token\n            // either regex or literal\n            if (expect.test ? expect.test(value) :\n                expect.type ? expect.type === token.type\n                            : expect.literal === literal) {\n                // Add it\n                var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                nextColumn.states.push(next);\n            }\n        }\n\n        // Next, for each of the rules, we either\n        // (a) complete it, and try to see if the reference row expected that\n        //     rule\n        // (b) predict the next nonterminal it expects by adding that\n        //     nonterminal's start state\n        // To prevent duplication, we also keep track of rules we have already\n        // added\n\n        nextColumn.process();\n\n        // If needed, throw an error:\n        if (nextColumn.states.length === 0) {\n            // No states at all! This is not good.\n            var message = this.lexer.formatError(token, \"invalid syntax\") + \"\\n\";\n            message += \"Unexpected \" + (token.type ? token.type + \" token: \" : \"\");\n            message += JSON.stringify(token.value !== undefined ? token.value : token) + \"\\n\";\n            var err = new Error(message);\n            err.offset = this.current;\n            err.token = token;\n            throw err;\n        }\n\n        // maybe save lexer state\n        if (this.options.keepHistory) {\n          column.lexerState = lexer.save()\n        }\n\n        this.current++;\n    }\n    if (column) {\n      this.lexerState = lexer.save()\n    }\n\n    // Incrementally keep track of results\n    this.results = this.finish();\n\n    // Allow chaining, for whatever it's worth\n    return this;\n};\n\nParser.prototype.save = function() {\n    var column = this.table[this.current];\n    column.lexerState = this.lexerState;\n    return column;\n};\n\nParser.prototype.restore = function(column) {\n    var index = column.index;\n    this.current = index;\n    this.table[index] = column;\n    this.table.splice(index + 1);\n    this.lexerState = column.lexerState;\n\n    // Incrementally keep track of results\n    this.results = this.finish();\n};\n\n// nb. deprecated: use save/restore instead!\nParser.prototype.rewind = function(index) {\n    if (!this.options.keepHistory) {\n        throw new Error('set option `keepHistory` to enable rewinding')\n    }\n    // nb. recall column (table) indicies fall between token indicies.\n    //        col 0   --   token 0   --   col 1\n    this.restore(this.table[index]);\n};\n\nParser.prototype.finish = function() {\n    // Return the possible parsings\n    var considerations = [];\n    var start = this.grammar.start;\n    var column = this.table[this.table.length - 1]\n    column.states.forEach(function (t) {\n        if (t.rule.name === start\n                && t.dot === t.rule.symbols.length\n                && t.reference === 0\n                && t.data !== Parser.fail) {\n            considerations.push(t);\n        }\n    });\n    return considerations.map(function(c) {return c.data; });\n};\n\nreturn {\n    Parser: Parser,\n    Grammar: Grammar,\n    Rule: Rule,\n};\n\n}));\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 17);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 925cb01ca0e269f2d3e2","\nexport function mustBeString(str: any, o?: any): string {\n    if (typeof str !== \"string\")\n        throw new Error(\"Expected to be string: \" + JSON.stringify(o ? o : str));\n    return str;\n}\n\nexport function mustBeDefined<T>(t?: T, o?: any): T {\n    if (t === undefined)\n        throw new Error(\"Expected to be defined: \" + JSON.stringify(o ? o : t));\n    return t;\n}\n\nexport function mustBeArray(str: any, o?: any): any[] {\n    if (!isArray(str))\n        throw new Error(\"Expected to be array: \" + JSON.stringify(o ? o : str));\n    return str;\n}\n\nexport function isArray(data: any): data is any[] {\n    return !!data && data.constructor === Array;\n}\n\nexport function isNumber(data: any): data is number {\n    return typeof data === \"number\";\n}\n\n\nexport function isString(data: any): data is string {\n    return typeof data === \"string\";\n}\n\nexport const flattenMyArray = function (arr: any[], result?: any[]): any[] {\n    if (!result) result = [];\n    for (let i = 0, length = arr.length; i < length; i++) {\n        const value: any = arr[i];\n        if (Array.isArray(value)) {\n            for (let i = 0, length = value.length; i < length; i++) {\n                const value2: any = value[i];\n                if (Array.isArray(value2)) {\n                    flattenMyArray(value2, result);\n                } else {\n                    result.push(value2);\n                }\n            }\n        } else {\n            result.push(value);\n        }\n    }\n    return result;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/util.ts","import {\n    BibOuterStringComponent,\n    BibStringComponent\n} from \"./BibStringComponent\";\n\nimport {BibStringData} from \"./BibStringData\";\n\n/**\n * thisObject = \"A string between quotes\"\n */\nexport class QuotedString extends BibStringComponent {\n    constructor(braceDepth: number, data: BibStringData) {\n        super(\"quotedstring\", braceDepth, data);\n    }\n}\n\nexport class OuterQuotedString extends BibOuterStringComponent {\n    constructor(data: BibStringData) {\n        super(\"quotedstringwrapper\", data);\n    }\n}\n\nexport function isOuterQuotedString(x: any): x is OuterQuotedString {\n    return x.type === \"quotedstringwrapper\";\n}\n\nexport function isQuotedString(x: any): x is QuotedString {\n    return x.type === \"quotedstring\";\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/datatype/string/QuotedString.ts","\nimport {BibOuterStringComponent, BibStringComponent} from \"./BibStringComponent\";\nimport {BibStringData} from \"./BibStringData\";\n\n/**\n * thisObject = {A string between braces}\n */\nexport class BracedString extends BibStringComponent {\n\n    /**\n     * A special character is a\n     * part of a field starting with a left brace being at brace depth 0 immediately followed with a backslash,\n     * and ending with the corresponding right brace.\n     * It should be noticed that anything in a special character is\n     * considered as being at brace depth 0, even if it is placed between another pair of braces.\n     */\n    readonly isSpecialCharacter: boolean;\n\n    constructor(braceDepth: number, data: BibStringData) {\n        super(\"bracedstring\", braceDepth, data);\n\n        // TODO braced strings inside a special character is treated as if it has brace depth 0. Maybe it's a good idea to mark these nested braces?\n        this.isSpecialCharacter = braceDepth === 0 && data[0] === \"\\\\\";\n    }\n\n}\n\nexport class OuterBracedString extends BibOuterStringComponent {\n    constructor(data: BibStringData) {\n        super(\"bracedstringwrapper\", data);\n    }\n}\n\nexport function isOuterBracedString(x: any): x is OuterBracedString {\n    return x.type === \"bracedstringwrapper\";\n}\n\nexport function isBracedString(x: any): x is BracedString {\n    return x.type === \"bracedstring\";\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/datatype/string/BracedString.ts","import {KeyVal, isKeyVal, newKeyVal, FieldValue} from \"../datatype/KeyVal\";\nimport {isStringRef, StringRef} from \"../datatype/string/StringRef\";\nimport {isOuterQuotedString, isQuotedString, OuterQuotedString, QuotedString} from \"../datatype/string/QuotedString\";\nimport {BracedString, isBracedString, isOuterBracedString, OuterBracedString} from \"../datatype/string/BracedString\";\nimport {isNumber, isString} from \"../../util\";\nimport {BibStringComponent} from \"../datatype/string/BibStringComponent\";\nimport {BibStringData} from \"../datatype/string/BibStringData\";\nimport {isBibStringComponent} from \"../datatype/string/bib-string-utils\";\n\n/**\n * An \"@string{}\" entry\n */\nexport class BibStringEntry {\n    readonly type: string;\n\n    readonly key: string;\n    readonly value: FieldValue;\n\n    public constructor(key: string, value: FieldValue) {\n        this.type = \"string\";\n        this.key = key;\n        this.value = value;\n    }\n}\n\nexport function newStringEntry(data: any): BibStringEntry {\n    const {key, value}: KeyVal = convertToKeyVal(data);\n    return new BibStringEntry(key, value);\n}\n\nfunction convertToKeyVal(data: any): KeyVal {\n    if (isKeyVal(data)) {\n        return newKeyVal(data);\n    } else {\n        if (data.type !== \"string\") {\n            throw new Error(\"Unexpected node: \" + JSON.stringify(data));\n        }\n        return convertToKeyVal(data.data);\n    }\n}\n\n// function resolveStringDeclarations(wrapper: FieldValue,\n//                                    compiledSoFar: { [key: string]: FieldValue },\n//                                    rawStrings: { [key: string]: FieldValue }) {\n//     if (isNumber(wrapper))\n//         return wrapper;\n//\n//     return copyWithResolvedStringReferences(wrapper, compiledSoFar, rawStrings);\n//\n//     //  else\n//     //    throw new Error(\"Unexpected object to resolve: \" + JSON.stringify(wrapper));\n// }\n\nexport function resolveStrings(strings: { [key: string]: FieldValue }): { [key: string]: FieldValue } {\n    const resolved: { [key: string]: FieldValue } = {};\n    Object.keys(strings).forEach(key => {\n        if (!resolved[key])\n            resolved[key] = resolveStringReference({}, resolved, strings, strings[key]);\n    });\n    return resolved;\n}\n\nexport function resolveStringReferences(o: BibStringComponent, seenBeforeStack: { [key: string]: boolean },\n                                        alreadyResolved: { [key: string]: /*Resolved*/FieldValue },\n                                        refs: { [key: string]: FieldValue }): BibStringData {\n    return o.data.map(datum => {\n        if (isString(datum) || isNumber(datum)) return datum;\n        else if (isStringRef(datum)) return resolveStringRef(seenBeforeStack, refs, datum, alreadyResolved);\n        else if (isBibStringComponent(datum)) return copyWithResolvedStringReferences(datum, seenBeforeStack, alreadyResolved, refs);\n        else throw new Error();\n    });\n}\n\nexport function resolveStringReference(seenBeforeStack: { [key: string]: boolean },\n                                       alreadyResolved: { [p: string]: FieldValue },\n                                       refs: { [p: string]: FieldValue },\n                                       data: FieldValue): FieldValue {\n    if (isNumber(data)) {\n        return data;\n    } else if (isOuterBracedString(data) || isOuterQuotedString(data)) {\n        return copyOuterWithResolvedStringReferences(data, seenBeforeStack, alreadyResolved, refs);\n    }\n    if (isStringRef(data)) {\n        return resolveStringRef(seenBeforeStack, refs, data, alreadyResolved);\n    }\n\n    // else if (isBibStringComponent(data))\n    //     return data.copyWithResolvedStringReferences(alreadyResolved, refs);\n    // else throw new Error();\n    return data;\n}\n\nfunction resolveStringRef(seenBeforeStack: { [key: string]: boolean },\n                          refs: { [key: string]: FieldValue },\n                          data: StringRef,\n                          alreadyResolved: { [key: string]: FieldValue }): FieldValue {\n    const refName = data.stringref;\n    if (seenBeforeStack[refName])\n        throw new Error(\"Cycle detected: \" + refName);\n    if (alreadyResolved[refName]) {\n        return alreadyResolved[refName];\n    }\n    if (!refs[refName])\n        throw new Error(`Unresolved reference: \"${data.stringref}\" (${JSON.stringify(data)})`);\n\n    alreadyResolved[refName] = resolveStringReference(\n        Object.assign({}, seenBeforeStack, {[refName]: true}),\n        alreadyResolved,\n        refs,\n        refs[refName]\n    );\n    return alreadyResolved[refName];\n}\n\n\nexport function copyWithResolvedStringReferences(obj: BibStringComponent,\n                                                 seenBeforeStack: { [key: string]: boolean },\n                                                 alreadyResolved: { [key: string]: /*Resolved*/FieldValue },\n                                                 refs: { [key: string]: FieldValue }): OuterQuotedString | OuterBracedString {\n    const newData = resolveStringReferences(obj, seenBeforeStack, alreadyResolved, refs);\n\n    const braceDepth: number = obj.braceDepth;\n    if (isQuotedString(obj))\n        return new QuotedString(braceDepth, newData);\n    if (isBracedString(obj))\n        return new BracedString(braceDepth, newData);\n    if (isOuterQuotedString(obj))\n        return new OuterQuotedString(newData);\n    if (isOuterBracedString(obj))\n        return new OuterBracedString(newData);\n    else\n        throw new Error();\n}\n\nexport function copyOuterWithResolvedStringReferences(obj: OuterQuotedString | OuterBracedString,\n                                                      seenBeforeStack: { [key: string]: boolean },\n                                                      alreadyResolved: { [key: string]: /*Resolved*/FieldValue },\n                                                      refs: { [key: string]: FieldValue }): OuterQuotedString | OuterBracedString {\n    const copied = copyWithResolvedStringReferences(\n        obj,\n        seenBeforeStack,\n        alreadyResolved,\n        refs\n    );\n    if (!isOuterBracedString(copied) && !isOuterQuotedString(copied)) throw new Error();\n    return copied;\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/bib-entry/BibStringEntry.ts","/**\n * A named reference to a string, eg. `{string1} # stringRef # {string2}`\n */\nexport class StringRef {\n    readonly stringref: string;\n    readonly braceDepth: number;\n\n    constructor(braceDepth: number, stringref: string) {\n        this.braceDepth = braceDepth;\n        this.stringref = stringref;\n    }\n}\n\nexport function isStringRef(stringref: any): stringref is StringRef {\n    return typeof stringref.stringref === \"string\";\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/datatype/string/StringRef.ts","import {OuterBracedString} from \"./string/BracedString\";\nimport {OuterQuotedString} from \"./string/QuotedString\";\nimport {isNumber, mustBeArray} from \"../../util\";\nimport {parseStringComponent} from \"./string/bib-string-utils\";\nimport {BibOuterStringComponent} from \"./string/BibStringComponent\";\n\n/**\n * A key to value mapping such as `field = {name}`.\n */\nexport interface KeyVal {\n    readonly key: string;\n    readonly value: FieldValue;\n}\n\nexport function isKeyVal(data: any): data is KeyVal {\n    return typeof data.key === \"string\"\n        && data.value !== undefined;\n}\n\nexport function newKeyVal(data: any): KeyVal {\n    if (isKeyVal(data)) {\n        return {\n            key: data.key,\n            value: parseFieldValue(data.value),\n        };\n    } else {\n        throw new Error(\"Was not a KeyVal: \" + JSON.stringify(data));\n    }\n}\n\nexport function parseFieldValue(value: any): FieldValue {\n    if (isNumber(value)) {\n        return value;\n    }\n\n    const data = mustBeArray(value.data);\n    switch (value.type) {\n        case \"quotedstringwrapper\":\n            if (data.length === 1 && isNumber(data[0]))\n            // A single number is in a quoted string wrapper\n            // because the parser considered it part of a\n            // concatenated string\n                return data[0];\n\n            return new OuterQuotedString(data.map(e => parseStringComponent(0, e)));\n\n        case \"bracedstringwrapper\":\n            return new OuterBracedString(data.map(e => parseStringComponent(0, e)));\n\n        default:\n            throw new Error(\"Unexpected value: \" + JSON.stringify(value));\n    }\n}\n\n/**\n * Values (i.e. right hand sides of each assignment) can be either between curly braces or between\n * double quotes. The main difference is that you can write double quotes in the first case, and not\n * in the second case.\n *\n * For numerical values, curly braces and double quotes can be omitted.\n */\nexport type FieldValue = number | BibOuterStringComponent;\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/datatype/KeyVal.ts","import {BibStringData} from \"./BibStringData\";\n\n/**\n * A fully formed string (between {braces} or \"quotes\").\n * Consists of 0 or many BibStringDatum\n */\nexport class BibStringComponent {\n    readonly data: BibStringData;\n    readonly type: string;\n\n    /**\n     * The brace depth of an item is the number of braces surrounding it (surrounding the field with braces instead of quotes does not modify the brace depth)\n     */\n    readonly braceDepth: number;\n\n    constructor(type: string, braceDepth: number, data: BibStringData) {\n        this.type = type;\n        this.braceDepth = braceDepth;\n        this.data = data;\n    }\n}\n\nexport class BibOuterStringComponent extends BibStringComponent {\n    constructor(type: string, data: BibStringData) {\n        super(type, 0, data);\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/datatype/string/BibStringComponent.ts","import {isStringRef, StringRef} from \"./StringRef\";\nimport {isBracedString, isOuterBracedString, BracedString} from \"./BracedString\";\nimport {isOuterQuotedString, isQuotedString, QuotedString} from \"./QuotedString\";\nimport {flattenMyArray, isArray, isNumber, isString, mustBeString} from \"../../../util\";\nimport {BibStringComponent} from \"./BibStringComponent\";\nimport {BibStringData, BibStringDatum} from \"./BibStringData\";\n\nexport function isBibStringComponent(x: any): x is BibStringComponent {\n    return typeof x.braceDepth === \"number\" && typeof x.type === \"string\";\n}\n\nexport interface ContiguousSimpleString {\n    type: \"ContiguousSimpleString\";\n    data: (number | string)[];\n}\n\nexport function isContiguousSimpleString(x: any): x is ContiguousSimpleString {\n    return x.type === \"ContiguousSimpleString\" && isArray(x.data);\n}\n\nexport function joinContiguousSimpleStrings(x: ContiguousSimpleString): string {\n    return x.data.join(\"\");\n}\n\n\nexport function parseStringComponent(braceDepth: number, obj: any): BibStringComponent | string | number | StringRef {\n    if (isNumber(obj) || isString(obj))\n        return /*new BibStringComponent(typeof obj, braceDepth, [*/obj/*])*/;\n\n    if (isStringRef(obj))\n        return new StringRef(0, obj.stringref);\n    // if (isWhitespace(obj)) return obj;\n    // if (isIdToken(obj)) return obj.string;\n\n    switch (mustBeString(obj.type, obj)) {\n        case \"id\":\n        case \"ws\":\n        case \"number\":\n            return mustBeString(obj.string);\n        case \"bracedstring\":\n        case \"braced\":\n            if (!isArray(obj.data)) {\n                throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n            }\n            return new BracedString(braceDepth, flattenMyArray(obj.data).map(e => parseStringComponent(braceDepth + 1, e)));\n        case \"quotedstring\":\n            if (!isArray(obj.data)) {\n                throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n            }\n            const flattened = flattenMyArray(obj.data);\n            return new QuotedString(braceDepth, flattened.map(e => parseStringComponent(braceDepth, e)));\n        default:\n            throw new Error(\"Unexpected complex string type: \" + obj.type);\n    }\n}\n\nexport function toStringBibStringDatum(data: BibStringDatum): string {\n    if (isString(data))\n        return data;\n    if (isNumber(data))\n        return data + \"\";\n    if (\n        isBracedString(data)\n        || isQuotedString(data)\n        || isOuterQuotedString(data)\n        || isOuterBracedString(data)\n    )\n        return toStringBibStringData(data.data);\n\n    throw new Error(JSON.stringify(data));\n}\n\nexport function toStringBibStringData(data: BibStringData) {\n    return data.map(toStringBibStringDatum).join(\"\");\n}\n\nexport function flattenQuotedStrings(data: BibStringData, hideQuotes?: boolean): BibStringData {\n    let result: BibStringData = [];\n    for (const datum of data) {\n        const flattenned = flattenQuotedString(datum, hideQuotes);\n        if (isArray(flattenned)) {\n            result = result.concat(flattenned);\n        } else {\n            result.push(flattenned);\n        }\n    }\n    return result;\n}\n\nconst doubleQuotes: BibStringDatum[] = [\"\\\"\"];\n\nfunction flattenQuotedString(data: BibStringDatum, hideQuotes?: boolean): BibStringDatum | BibStringData {\n    if (isBracedString(data))\n        return data;\n    if (isQuotedString(data)) {\n        const flattenedQuotedString: BibStringData = flattenQuotedStrings(data.data, true);\n        if (isArray(flattenedQuotedString)) {\n            return hideQuotes\n                ? flattenedQuotedString\n                : doubleQuotes.concat(flattenedQuotedString).concat(doubleQuotes);\n        } else if (hideQuotes)\n            return flattenedQuotedString;\n        else\n            return [\"\\\"\", flattenedQuotedString, \"\\\"\"];\n    }\n    if (isOuterQuotedString(data))\n        return flattenQuotedStrings(data.data, true);\n    if (isOuterBracedString(data))\n        return flattenQuotedStrings(data.data, false);\n    if (isString(data) || isNumber(data))\n        return data;\n    if (isStringRef(data))\n        throw new Error(\"StringRef should be resolved at this point!\");\n    else\n        throw new Error();\n}\n\nexport function globContiguousStrings(data: BibStringData): (BibStringDatum | ContiguousSimpleString)[] {\n    const result: (BibStringDatum | ContiguousSimpleString)[] = [];\n    for (const element of data) {\n        if (isString(element) || isNumber(element)) {\n            if (result.length <= 0) {\n                const contiguousSimpleString: ContiguousSimpleString = {\n                    type: \"ContiguousSimpleString\",\n                    data: [element]\n                };\n                result.push(contiguousSimpleString);\n            }\n            else {\n                const lastElement = result[result.length - 1];\n                if (isContiguousSimpleString(lastElement)) {\n                    lastElement.data.push(element);\n                } else {\n                    const contiguousSimpleString: ContiguousSimpleString = {\n                        type: \"ContiguousSimpleString\",\n                        data: [element]\n                    };\n                    result.push(contiguousSimpleString);\n                }\n            }\n        } else {\n            result.push(element);\n        }\n    }\n    return result;\n}\n\nexport function splitOnAnd(data: BibStringData): BibStringData[] {\n    return splitOnPattern(data, /\\s+and\\s+/g);\n}\n\nexport function splitOnComma(data: BibStringData, limit = 2): BibStringData[] {\n    return splitOnPattern(data, /\\s*,\\s*/g, limit);\n}\n\nexport function splitOnPattern(data: BibStringData, pattern: RegExp, stopAfter?: number): BibStringData[] {\n    const splitted: BibStringData[] = [];\n\n    let buffer: BibStringData = [];\n    for (const datum of data) {\n        if (isString(datum) && (stopAfter === undefined || stopAfter > 0)) {\n            let match: RegExpExecArray | null | undefined = pattern.exec(datum);\n            let end = 0;\n            if (match) {\n                do {\n                    const prevEnd = end;\n                    end = match.index + match[0].length;\n                    // if(prevEnd !== match.index)\n                    buffer.push(datum.substring(prevEnd, match.index));\n\n                    if (stopAfter === undefined || stopAfter > 0) {\n                        splitted.push(buffer);\n                        buffer = [];\n                        if (stopAfter !== undefined && stopAfter > 0) stopAfter--;\n                    }\n\n                    if (stopAfter === undefined || stopAfter > 0)\n                        match = pattern.exec(datum);\n                    else\n                        match = undefined;\n                } while (match);\n\n                if (end > 0 && end < datum.length)\n                    buffer.push(datum.substring(end));\n            } else {\n                buffer.push(datum);\n            }\n        }\n        else\n            buffer.push(datum);\n    }\n\n    if (buffer.length > 0) splitted.push(buffer);\n    return splitted;\n}\n\n// TODO\n// /**\n//  * A special character is a\n//  part of a field starting with a left brace being at brace depth 0 immediately followed with a backslash,\n//  and ending with the corresponding right brace. For instance, in the above example, there is no special\n//  character, since \\LaTeX is at depth 2. It should be noticed that anything in a special character is\n//  considered as being at brace depth 0, even if it is placed between another pair of braces.\n//  */\n// export class SpecialCharacter extends BibStringComponent {\n//     constructor(data: BibStringData) {\n//         super(\"specialCharacter\", 0, data);\n//     }\n//\n//     copyWithResolvedStringReferences(alreadyResolved, refs): BibStringComponent {\n//         return new SpecialCharacter(resolveStringReferences(this,(alreadyResolved, refs));\n//     }\n// }\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/datatype/string/bib-string-utils.ts","import * as nearley from \"nearley\";\n\nimport {grammar} from \"../parser/ts-parser\";\n\nimport {isArray, mustBeString} from \"../util\";\nimport {FieldValue, isKeyVal} from \"./datatype/KeyVal\";\nimport {BibEntry, isBibEntry, parseEntryFields, processEntry} from \"./bib-entry/BibEntry\";\nimport {BibComment, CommentEntry, flattenPlainText, isBibComment} from \"./bib-entry/BibComment\";\nimport {isPreamble, Preamble, newPreambleNode} from \"./bib-entry/BibPreamble\";\nimport {newStringEntry, resolveStrings, BibStringEntry} from \"./bib-entry/BibStringEntry\";\nimport Lexer from \"../lexer/Lexer\";\n\n\nexport type NonBibComment = BibEntry | CommentEntry | BibStringEntry | Preamble;\n\n/**\n * A bibfile is a sequence of entries, with comments interspersed\n */\nexport class BibFile {\n    readonly content: (NonBibComment | BibComment)[];\n    readonly comments: BibComment[];\n\n    readonly entries_raw: BibEntry[];\n    readonly entries$: { [key: string]: BibEntry };\n\n    /**\n     * Anything declared in a @preamble command will be concatenated and put in a variable\n     named preamble$, for being used in the bibliography style and, generally, inserted at the beginning of\n     the .bbl file, just before the thebibliography environment. This is useful for defining new commands\n     used in the bibliography. Here is a small example:\n\n     \\@preamble{ \"\\makeatletter\" }\n     \\@preamble{ \"\\@ifundefined{url}{\\def\\url#1{\\texttt{#1}}}{}\" }\n     \\@preamble{ \"\\makeatother\" }\n\n     This way, you may safely use the \\url command in your entries. If it is not defined at the beginning\n     of the bibliography, the default command defined in the @preamble will be used.\n     Please note that you should never define style settings in the @preamble of a bibliography database,\n     since it would be applied to any bibliography built from this database.\n     */\n    readonly preambles_raw: Preamble[];\n    readonly preamble$: string;\n\n    readonly strings_raw: { [k: string]: FieldValue };\n    /**\n     * `strings`, but with all references resolved\n     */\n    readonly strings$: { [k: string]: FieldValue };\n\n\n    constructor(content: (NonBibComment | BibComment)[]) {\n        this.content = content;\n        this.comments = content.filter(isBibComment).map(c => {\n            if (isBibComment(c))return c; else throw new Error();\n        });\n\n\n\n        this.preambles_raw = content.filter(c => isPreamble(c)).map(c => {\n            if (isPreamble(c)) return c; else throw new Error();\n        });\n        this.preamble$ = this.preambles_raw.map(p => p.toString()).join(\"\\n\");\n\n        const strings: { [k: string]: FieldValue } = {};\n        this.content.forEach(entry => {\n                if (isKeyVal(entry)) {\n                    if (!!strings[entry.key])\n                        throw new Error(\"String with id \" + entry.key + \" was defined more than once\");\n                    strings[entry.key] = entry.value;\n                }\n            }\n        );\n\n        this.strings_raw = strings;\n        this.strings$ = resolveStrings(strings);\n\n        this.entries_raw = content.filter(c => isBibEntry(c)).map(c => {\n            if (isBibEntry(c)) return c;\n            else throw new Error();\n        });\n\n        const entryMap: { [k: string]: BibEntry } = {};\n        this.entries_raw.forEach((entry: BibEntry) => {\n            const key = entry._id.toLowerCase();\n            /**\n             * BibTEX will complain if two entries have the same internal key, even if they arent capitalized in the same\n             * way. For instance, you cannot have two entries named Example and example.\n             * In the same way, if you cite both example and Example, BibTEX will complain. Indeed, it would\n             * have to include the same entry twice, which probably is not what you want\n             */\n            if (!!entryMap[key]) throw new Error(\"Entry with id \" + key + \" was defined more than once\");\n            entryMap[key] = processEntry(entry, this.strings$);\n        });\n        this.entries$ = entryMap;\n    }\n\n    getEntry(id: string): BibEntry | undefined {\n        return this.entries$[id.toLowerCase()];\n    }\n}\n\nfunction parseNonEntry(nonEntry: any): BibComment {\n    if (!isArray(nonEntry.data) || nonEntry.type !== \"NON_ENTRY\") throw new Error();\n    return new BibComment(flattenPlainText(nonEntry.data));\n}\n\n\nfunction parseEntry(entry: any): NonBibComment {\n    switch (typeof entry) {\n        case \"object\":\n            const data = entry.data;\n            if (typeof data[\"@type\"] === \"string\") {\n                return new BibEntry(\n                    data[\"@type\"],\n                    data._id,\n                    parseEntryFields(data.fields)\n                );\n            }\n\n            const type = mustBeString(data.type);\n            switch (type) {\n                case \"string\":\n                    return newStringEntry(data);\n                case \"preamble\":\n                    return newPreambleNode(data);\n                // case \"bracedstringwrapper\":\n                //     return new BracedString(parseComplexStringOuter(data));\n                // case \"quotedstringwrapper\":\n                //     return new QuotedString(parseComplexStringOuter(data));\n                // case \"braced\":\n                // case \"quotedstring\":\n                default:\n                    throw new Error(\"Unexpected entry parsed: \" + data.type);\n            }\n        default:\n            throw new Error(\"Expected object as data for entry\");\n    }\n}\n\nexport const parseBibEntriesAndNonEntries = function (parse: any): (BibComment | NonBibComment)[] {\n    return parse.map((entity: any) => {\n        switch (entity.type) {\n            case \"NON_ENTRY\":\n                return (parseNonEntry(entity));\n            case \"ENTRY\":\n                return (parseEntry(entity));\n            default:\n                throw new Error(\"Expected ENTRY or NON_ENTRY\");\n        }\n    });\n};\n\nexport function parseBibFile(input: string): BibFile {\n    const p = new nearley.Parser(grammar.ParserRules, grammar.ParserStart);\n    p.feed(new Lexer(input).readTokens());\n    const res = p.results;\n    const parse = res[0];\n\n    return new BibFile(parseBibEntriesAndNonEntries(parse));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/BibFile.ts","import {flattenMyArray, isArray, isString, mustBeString} from \"../../util\";\n\nexport class BibComment {\n    readonly type: string;\n    readonly data: string[];\n    readonly string: string;\n\n    constructor(data: string[]) {\n        this.type = \"comment\";\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    toString() {\n        return this.string;\n    }\n}\n\nexport class CommentEntry {\n    readonly type: string;\n    readonly data: string[];\n    readonly string: string;\n\n    constructor(type: string, data: string[]) {\n        this.type = type;\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    toString() {\n        return this.string;\n    }\n}\n\nexport function isBibComment(n: any): n is BibComment {\n    return n.type === \"comment\" && isArray(n.data);\n}\n\nconst flattenO = (wrapper: any): string => isString(wrapper) ? wrapper\n    : typeof wrapper === \"number\" ? wrapper.toString()\n        // : (isString(wrapper.type) && wrapper.type === \"@bib\" && isString(wrapper.string)) ? \"@\" + wrapper.string\n        : wrapper[\"type\"] === \"@bib\" ? \"@\" + mustBeString(wrapper.string)\n            : wrapper[\"type\"] === \"escapedEntry\" ? \"\\\\\" + flattenO(wrapper.data)\n                : mustBeString(wrapper.string)\n;\n\nexport function flattenPlainText(data: any[]): string[] {\n    return flattenMyArray(data).map(flattenO);\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/bib-entry/BibComment.ts","import {Authors, mustBeAuthors} from \"./bibliographic-entity/Authors\";\nimport {\n    findError,\n    hasMandatoryFields,\n    mandatoryFields\n} from \"./bibliographic-entity/mandatory-and-optional-fields\";\nimport {resolveStringReference} from \"./BibStringEntry\";\nimport {FieldValue, parseFieldValue} from \"../datatype/KeyVal\";\n\n/**\n * Represents a single \"@[entityName]\" entity, not a special entity such as @string\n */\nexport class BibEntry {\n    readonly type: string;\n    readonly _id: string;\n\n    readonly fields: EntryFields;\n    // noinspection JSUnusedGlobalSymbols\n    readonly fields$: EntryFields;\n\n    /**\n     * When sorting, BibTEX computes a string, named\n     sort.key$, for each entry. The sort.key$ string is an (often long) string defining the order\n     in which entries will be sorted. To avoid any ambiguity, sort.key$ should only contain alphanumeric\n     characters. Classical non-alphanumeric characters23, except special characters, will\n     be removed by a BibTEX function named purify$. For special characters, purify$ removes\n     spaces and LATEX commands (strings beginning with a backslash), even those placed between\n     brace pairs. Everything else is left unmodified. For instance, t\\^ete, t{\\^e}te and t{\\^{e}}te\n     are transformed into tete, while tte gives tte; Bib{\\TeX} gives Bib and Bib\\TeX becomes\n     BibTeX. There are thirteen LATEX commands that wont follow the above rules: \\OE, \\ae, \\AE,\n     \\aa, \\AA, \\o, \\O, \\l, \\L, \\ss. Those commands correspond to , , , , , , , , , , , ,\n     , and purify$ transforms them (if they are in a special character, in i, j, oe, OE, ae, AE, aa,\n     AA, o, O, l, L, ss, respectively.\n     */\n    readonly sortkey$: string;\n\n    /**\n     the second transformation applied to a title is to be turned to lower case (except the first character).\n     The function named change.case$ does this job. But it only applies to letters that are\n     a brace depth 0, except within a special character. In a special character, brace depth is always\n     0, and letters are switched to lower case, except LATEX commands, that are left unmodified.\n     */\n    readonly title$: string;\n\n    constructor(type: string, id: string, fields: EntryFields) {\n        this.type = type;\n        this._id = id;\n\n        this.fields = fields;\n\n\n        // TODO implement; see above\n        this.sortkey$ = \"\";\n        this.title$ = \"\";\n    }\n\n    getField(key: string): FieldValue | undefined {\n        return this.fields[key.toLowerCase()];\n    }\n\n    getAuthors(): Authors | undefined {\n        const field = this.fields[\"author\"];\n        if (field === undefined) return field;\n        return mustBeAuthors(field);\n    }\n}\n\n\nexport interface EntryFields {\n    [k: string]: FieldValue;\n}\n\nexport function parseEntryFields(fields: any): EntryFields {\n    const fieldz: EntryFields = {};\n    Object.keys(fields).forEach(key => {\n        switch (key) {\n            default:\n                fieldz[key] = parseFieldValue(fields[key]);\n                break;\n        }\n    });\n    return fieldz;\n}\n\n\n\n\n// export function parseComplexStringOuter(obj: any): OuterQuotedString | OuterBracedString | number {\n//     if (isString(obj)) return [obj];\n//\n//     switch (mustBeString(obj.type)) {\n//         case \"quotedstringwrapper\":\n//         case \"bracedstringwrapper\":\n//             if (!isArray(obj.data))\n//                 throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n//\n//             return obj.data.map(parseStringy);\n//         default:\n//             throw new Error(\"Unexpected complex string type: \" + obj.type);\n//     }\n// }\n\n\nexport function isBibEntry(x: any): x is BibEntry {\n    return typeof x[\"type\"] === \"string\"\n        && typeof x[\"_id\"] === \"string\"\n        && !!x[\"fields\"];\n}\n\nexport function processEntry(entry: BibEntry, strings$: { [p: string]: FieldValue }) {\n    if (hasMandatoryFields(entry.type))\n        mandatoryFields[entry.type]\n            .map(e => findError(entry, e))\n            .forEach(e => {\n                if (!!e) console.warn(e.message);\n            })\n        ;\n\n    const processedFields: EntryFields = {};\n\n    const fields$ = entry.fields;\n\n    Object.keys(entry.fields).forEach((key: string) => {\n        const field$ = resolveStringReference({}, processedFields, strings$, fields$[key]);\n        switch (key) {\n            case \"author\":\n                processedFields[key] = new Authors(field$);\n                break;\n            case \"title\":\n                processedFields[key] = (field$);\n                break;\n            case \"incollection\":\n                // TODO cross reference\n            default:\n                processedFields[key] = field$;\n                break;\n        }\n    });\n\n\n    return new BibEntry(\n        entry.type,\n        entry._id,\n        processedFields\n    );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/bib-entry/BibEntry.ts","import {mustBeArray} from \"../../util\";\nimport {parseBibEntriesAndNonEntries} from \"../BibFile\";\n\nexport class Preamble {\n    readonly type: string;\n    readonly data: any[];\n    readonly string: string;\n\n    // TODO\n    constructor(data: any[]) {\n        this.type = (\"preamble\");\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    toString() {\n        return this.string;\n    }\n}\n\nexport function isPreamble(x: any): x is Preamble {\n    return x.type === \"preamble\" && !!x.data;\n}\n\n\n// function parsePreambleContents(data: any) {\n//     if (isString(data)) return data;\n//     if (isString(data.type) && data.type === \"@bib\")\n//         return \"@\" + data.string;\n//     // if (isString(data.type) && data.type === \"NON_ENTRY\")\n//     //     return ;\n//     if (isString(data.string)) return data.string;\n//     return data;\n// }\n\nexport function newPreambleNode(data: any): Preamble {\n    const flattened = parseBibEntriesAndNonEntries(mustBeArray(data.data));\n    return new Preamble(flattened);\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/bib-entry/BibPreamble.ts","// export const NUMBER = \"number\";\n\nimport {TypedToken} from \"./Token\";\n\nexport function newNumber(string: string): NumberToken {\n    return {\n        type: \"number\",\n        string\n    };\n}\n\nexport interface NumberToken extends TypedToken {\n    type: \"number\";\n}\n\nexport const numericChars = {\n    \"0\": true,\n    \"1\": true,\n    \"2\": true,\n    \"3\": true,\n    \"4\": true,\n    \"5\": true,\n    \"6\": true,\n    \"7\": true,\n    \"8\": true,\n    \"9\": true\n};\n\nexport type NumericChar = keyof typeof numericChars;\n\nexport function isNum(c: string): c is NumericChar {\n    return numericChars.hasOwnProperty(c);\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/lexer/NumericToken.ts","export type Token = TypedToken | string | number;\n\nexport interface TypedToken {\n    type: string;\n    string?: string;\n}\n\nexport function newToken(type: string, string: string): TypedToken {\n    return {\n        type,\n        string\n    };\n}\n\n\nexport const specialChars = {\n    \"@\": true,\n    \"(\": true,\n    \")\": true,\n    \"{\": true,\n    \"}\": true,\n    \"#\": true,\n    \"=\": true,\n    \",\": true,\n    \"\\\\\": true,\n    \"\\\"\": true,\n};\n\nexport type SpecialChar = keyof typeof specialChars;\n\nexport function isSpecialChar(c: string): c is SpecialChar {\n    return specialChars.hasOwnProperty(c);\n}\n\n\nexport const escapableChars = {\n    \"\\\\\": true,\n    \"@\": true,\n    \"{\": true,\n    \"}\": true\n};\n\nexport type EscapableChar = keyof typeof escapableChars;\n\nexport function isEscapableChar(c: string): c is EscapableChar {\n    return escapableChars.hasOwnProperty(c);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/lexer/Token.ts","import {TypedToken} from \"./Token\";\n\nexport const WS = \"ws\";\n\nexport function newWhitespace(string: string): WhitespaceToken {\n    return {\n        type: \"ws\",\n        string\n    };\n}\n\n//noinspection JSUnusedGlobalSymbols\nexport function isWhitespace(token: any): token is WhitespaceToken {\n    return typeof token.string === \"string\" && token.type === WS;\n}\n\n\nexport interface WhitespaceToken extends TypedToken {\n    type: \"ws\";\n}\n\nexport const singleWhitespaces = {\n    \" \": true,\n    \"\\t\": true,\n    \"\\r\": true,\n    \"\\n\": true\n};\n\nexport type SingleWhitespace = keyof typeof singleWhitespaces;\n\nexport function isSingleWhiteSpaceCharacter(c: string): c is SingleWhitespace {\n    return singleWhitespaces.hasOwnProperty(c);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/lexer/WhitespaceToken.ts","import {isArray, isNumber} from \"../../../util\";\n// import {AuthorName} from \"./Author\";\nimport {isOuterQuotedString} from \"../../datatype/string/QuotedString\";\nimport {BibOuterStringComponent} from \"../../datatype/string/BibStringComponent\";\nimport {BibStringData} from \"../../datatype/string/BibStringData\";\nimport {\n    flattenQuotedStrings,\n    globContiguousStrings,\n    isContiguousSimpleString,\n    joinContiguousSimpleStrings,\n    splitOnAnd\n} from \"../../datatype/string/bib-string-utils\";\nimport {FieldValue} from \"../../datatype/KeyVal\";\n\n\n/**\n * Represents a list of authors\n */\nexport class Authors extends BibOuterStringComponent {\n    readonly authors$: any[];\n\n    constructor(fieldValue: FieldValue) {\n        const data = isNumber(fieldValue) ? [fieldValue] : fieldValue.data;\n        super(\"authors\", data);\n\n        // todo\n\n\n        const authorNames = determineAuthorNames$(fieldValue);\n        this.authors$ = authorNames.map(name => parseAuthor(name));\n    }\n}\n\n\nfunction parseAuthor(data: BibStringData) {\n    return data;\n//     return new Author();\n}\n\n\nexport function determineAuthorNames$(data: FieldValue): BibStringData[] {\n    if (isNumber(data)) {\n        return determineAuthorNames([data]);\n    } else {\n        return determineAuthorNames(data.data, isOuterQuotedString(data));\n    }\n}\n\n\nfunction determineAuthorNames(data: BibStringData, hideQuotes?: boolean): BibStringData[] {\n    const globbed = globContiguousStrings(\n        flattenQuotedStrings(data, hideQuotes)\n    );\n    const normalizedString: BibStringData = globbed.map(e => isContiguousSimpleString(e) ? joinContiguousSimpleStrings(e) : e);\n    return splitOnAnd(normalizedString);\n}\n\n\nexport function mustBeAuthors(x: any): Authors {\n    if (!isAuthors(x)) throw new Error();\n    return x;\n}\n\n\nexport function isAuthors(x: any): x is Authors {\n    return (isArray(x[\"authors$\"]) && x.type === \"authors\");\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/bib-entry/bibliographic-entity/Authors.ts","import {isArray, isString} from \"../../../util\";\nimport {BibEntry} from \"../BibEntry\";\n\n/**\n * From Taming the BeaST: http://ctan.cs.uu.nl/info/bibtex/tamethebeast/ttb_en.pdf\n *\n <dl>\n\n <dt>address</dt>\n <dd>Generally the city or complete address of the publisher.\n </dd>\n\n <dt>author</dt>\n <dd>For author names. The input format is quite special, since BibTEX has to be\n able to distinguish between the first and last names. Section 11 and 18 are\n completely dedicated to this topic.\n </dd>\n\n <dt>booktitle</dt>\n <dd>For the title of a book one part of which is cited.\n </dd>\n\n <dt>chapter</dt>\n <dd>The number of the chapter (or any part) of a book being cited. If not a chapter,\n the type field might be used for precising the type of sectioning.\n </dd>\n\n <dt>crossref</dt>\n <dd>This one is quite peculiar. Its used to cross-reference within the bibliography.\n For instance, you might cite a document, and a part of it. In that case, the\n second one can reference the first one, or at least inherit some of its fields from\n the first one. This deserves some more comments, see section 12.\n </dd>\n\n <dt>edition</dt>\n <dd>The edition number. Or in fact its ordinal, for instance edition = \"First\".\n This might raise problems when trying to export a bibliography into another\n language.\n </dd>\n\n <dt>editor</dt>\n <dd>The name of the editor(s) of the entry. The format is the same as for authors.\n </dd>\n\n <dt>howpublished</dt>\n <dd>Only used in rare cases where the document being cited is not a classical type\n such as a @book, an @article or an @inproceedings publication.\n </dd>\n\n <dt>institution</dt>\n <dd>For a technical report, the name of the institution that published it.\n </dd>\n\n <dt>journal</dt>\n <dd>The name of the journal in which the cited article has been published.\n key Used for defining the label, in case it cannot be computed by BibTEX. It does\n not force the label, but defines the label when BibTEX needs one but cant\n compute it.\n </dd>\n\n <dt>month</dt>\n <dd>Well... The month during which the document has been published. This also\n raises the problem of the translation of the bibliography: Its better having\n a numerical value, or an abbreviation, instead of the complete name of the\n month. Having the number would also allow BibTEX to sort the entries more\n precisely (even though, as far as I know, no bibliography style does this at the\n present time).\n </dd>\n\n <dt>note</dt>\n <dd>For any additional data you would want to add. Since classical styles were\n written in 1985, they dont have a url field, and note is often used for this\n purpose, together with the url.sty package.</dd>\n\n <dt>number</dt>\n <dd>A number... Not whichever, but the number of a report. For volume numbers,\n a special volume field exists.\n organization The organizing institution of a conference.\n </dd>\n\n <dt>pages</dt>\n <dd>The relevant pages of the document. Useful for the reader when you cite a huge\n book; Note that such a precision could be added through the optional argument\n of \\cite (see page 6), in which case it would appear in the document but not\n in the bibliography.\n </dd>\n\n <dt>publisher</dt>\n <dd>The institution that published the document.\n </dd>\n\n <dt>school</dt>\n <dd>For theses, the name of the school the thesis has been prepared in.\n </dd>\n\n <dt>series</dt>\n <dd>The name of a collection of series or books.\n </dd>\n\n <dt>title</dt>\n <dd>The title of the document being cited. There are some rules to be observed\n when entering this field, see section 10.\n </dd>\n\n <dt>type</dt>\n <dd>The type. Which type? It depends... The type of publication, if needed. For\n </dd>\n\n <dt>thesi</dt>\n <dd>s, for instance, in order to distinguish between a masters thesis and a PhD.\n Or the type of section being cited (see chapter above).\n </dd>\n\n <dt>volume</dt>\n <dd>The volume number in a series or collection of books.\n </dd>\n\n <dt>year</dt>\n <dd>The publication year.</dd>\n\n </dl>\n **/\nexport const address = \"address\";\nexport const author = \"author\";\nexport const booktitle = \"booktitle\";\nexport const chapter = \"chapter\";\nexport const edition = \"edition\";\nexport const editor = \"editor\";\nexport const howpublished = \"howpublished\";\nexport const institution = \"institution\";\nexport const journal = \"journal\";\nexport const month = \"month\";\nexport const note = \"note\";\nexport const number = \"number\";\nexport const organization = \"organization\";\nexport const pages = \"pages\";\nexport const publisher = \"publisher\";\nexport const school = \"school\";\nexport const series = \"series\";\nexport const title = \"title\";\nexport const type = \"type\";\nexport const volume = \"volume\";\nexport const year = \"year\";\n\nexport type KnownField = \"address\" |\n    \"author\" |\n    \"booktitle\" |\n    \"chapter\" |\n    \"edition\" |\n    \"editor\" |\n    \"howpublished\" |\n    \"institution\" |\n    \"journal\" |\n    \"month\" |\n    \"note\" |\n    \"number\" |\n    \"organization\" |\n    \"pages\" |\n    \"publisher\" |\n    \"school\" |\n    \"series\" |\n    \"title\" |\n    \"type\" |\n    \"volume\" |\n    \"year\";\n\nexport type MandatoryFields = KnownField | KnownField[];\nexport type OptionalFields = KnownField | KnownField[];\n\nexport const optionalFields: { [k: string]: (KnownField | KnownField[])[] } = {\n    \"book\": [[\"volume\", \"number\"], \"series\", \"address\", \"edition\", \"month\", \"note\"],\n    \"booklet\": [\"author\", \"howpublished\", \"address\", \"address\", \"month\", \"year\", \"note\"],\n    \"conference\": [\"editor\", [\"volume\", \"number\"], \"series\", \"pages\", \"address\", \"month\", \"organization\", \"publisher\", \"note\"],\n    \"inproceedings\": [\"editor\", [\"volume\", \"number\"], series, \"pages\", \"address\", \"month\", \"organization\", \"publisher\", \"note\"],\n    \"inbook\": [\"volume\", \"number\", \"series\", \"type\", \"address\", \"edition\", \"month\", \"note\"],\n    \"incollection\": [\"editor\", [\"volume\", \"number\"], \"series\", \"type\", \"chapter\", \"pages\", \"address\", \"edition\", \"month\", \"note\"],\n    \"manual\": [\"author\", \"organization\", \"year\", \"address\", \"edition\", \"month\", \"note\"],\n    \"mastersthesis\": [\"type\", \"address\", \"month\", \"note\"],\n    \"misc\": [],\n    \"phdthesis\": [\"type\", \"address\", \"month\", \"note\"],\n    \"proceedings\": [\"editor\", [\"volume\", \"number\"], \"series\", \"address\", \"month\", \"organization\", \"publisher\", \"note\"],\n    \"techreport\": [\"type\", \"address\", \"number\", \"month\", \"note\"],\n    \"unpublished\": [\"month\", \"year\"]\n};\n\nexport const mandatoryFields: { [k: string]: (KnownField | KnownField[])[] } = {\n    \"article\": [\"author\", \"title\", \"year\", \"journal\"],\n    \"book\": [[\"author\", \"editor\"], \"title\", \"publisher\", \"year\"],\n    \"booklet\": [\"title\"],\n    \"conference\": [\"author\", \"title\", \"booktitle\", \"year\"],\n    \"inproceedings\": [\"author\", \"title\", \"booktitle\", \"year\"],\n    \"inbook\": [[\"author\", \"editor\"], \"title\", [\"chapter\", \"pages\"]],\n    \"incollection\": [\"author\", \"title\", \"booktitle\", \"publisher\", \"year\"],\n    \"manual\": [\"title\"],\n    \"mastersthesis\": [\"author\", \"title\", \"school\", \"year\"],\n    \"misc\": [[\"author\", \"title\", \"howpublished\", \"year\", \"month\", \"note\"]],\n    \"phdthesis\": [\"author\", \"title\", \"school\", \"year\"],\n    \"proceedings\": [\"year\", \"title\"],\n    \"techreport\": [\"author\", \"title\", \"institution\", \"year\"],\n    \"unpublished\": [\"author\", \"title\", \"note\"]\n};\n\nexport function hasOptionalFields(s: string): s is (keyof typeof optionalFields) {\n    return optionalFields.hasOwnProperty(s);\n}\n\nexport function hasMandatoryFields(s: string): s is (keyof typeof mandatoryFields) {\n    return mandatoryFields.hasOwnProperty(s);\n}\n\nexport function getMandatoryFields(s: string): MandatoryFields[] {\n    if (hasMandatoryFields(s)) {\n        return mandatoryFields[s];\n    } else {\n        return [];\n    }\n}\n\nexport function getOptionalFields(s: string): OptionalFields[] {\n    if (hasOptionalFields(s)) {\n        return optionalFields[s];\n    } else {\n        return [];\n    }\n}\n\nexport const findError = (entry: BibEntry, field: MandatoryFields): (Error | undefined) => {\n    const fields = entry.fields;\n    if (isString(field)) {\n        if (!fields[field])\n            return new Error(\"Warning: expected \" + entry.type + \" with id \" + entry._id\n                + \" to have the field: \" + field);\n    } else if (isArray(field)) {\n        const hasAllFields: boolean = field.reduce(\n            (acc: boolean, fieldName: KnownField): boolean => {\n                if (isString(fieldName)) {\n                    return (acc && fields.hasOwnProperty(fieldName));\n                }\n                else\n                    throw new Error();\n            }, true\n        );\n        if (!hasAllFields) {\n            // not one of a list of options\n            return new Error(\"Expected \" + entry.type + \" with id \" + entry._id\n                + \" to have one of the following fields: \" + field);\n        }\n    }\n};\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/bib-entry/bibliographic-entity/mandatory-and-optional-fields.ts","export * from \"./bibfile/BibFile\";\nexport * from \"./bibfile/bib-entry/BibEntry\";\nexport * from \"./bibfile/bib-entry/BibComment\";\nexport * from \"./bibfile/bib-entry/BibPreamble\";\nexport * from \"./bibfile/datatype/string/QuotedString\";\nexport * from \"./bibfile/datatype/string/BracedString\";\nexport * from \"./bibfile/bib-entry/BibStringEntry\";\nexport * from \"./bibfile/datatype/string/StringRef\";\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/index.ts","export const bibTypes = {\n    string: \"@string\",\n    preamble: \"@preamble\",\n    comment: \"@comment\",\n    bib: \"@bib\"\n};\n\nexport type BibType = keyof typeof bibTypes;\n\nexport const isBibType = function (c: string): c is BibType {\n    return bibTypes.hasOwnProperty(c);\n};\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/lexer/BibBlockTypes.ts","import {TypedToken, SpecialChar, isSpecialChar} from \"./Token\";\n\nimport {SingleWhitespace, isSingleWhiteSpaceCharacter} from \"./WhitespaceToken\";\nimport {isNum, NumericChar} from \"./NumericToken\";\n\nexport interface IdToken extends TypedToken {\n    type: \"id\";\n    string: string;\n}\n\nexport function newIdToken(string: string): IdToken {\n    return {\n        type: \"id\",\n        string\n    };\n}\n\nexport function isIdToken(string: any): string is IdToken {\n    return string.type === \"id\" && typeof string.string === \"string\";\n}\n\nexport function isIdChar(c: string): c is IdChar {\n    return !(isSpecialChar(c) || isNum(c) || isSingleWhiteSpaceCharacter(c));\n}\n\nexport type IdChar = SpecialChar | NumericChar | SingleWhitespace;\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/lexer/IdToken.ts","import {TypedToken, isSpecialChar, newToken, Token} from \"./Token\";\nimport {isSingleWhiteSpaceCharacter, WhitespaceToken, SingleWhitespace, newWhitespace} from \"./WhitespaceToken\";\nimport {isNum, NumericChar, NumberToken, newNumber} from \"./NumericToken\";\nimport {IdToken, isIdChar, newIdToken} from \"./IdToken\";\nimport {isBibType, bibTypes} from \"./BibBlockTypes\";\n\nexport default class Lexer {\n    private str: string;\n    private len: number;\n    private pos: number;\n\n    constructor(string: string) {\n        this.str = string;\n        this.len = string.length;\n        this.pos = 0;\n    }\n\n    getStringUntilNonEscapedChar(terminalRegex: RegExp | string): string {\n        // if (typeof terminalRegex === 'string') {\n        // }\n        const chars: string[] = [];\n        for (let i = this.pos; i < this.len + 1; i++) {\n            this.pos = i;\n            if (this.str.charAt(i) == \"\\\\\" && this.str.charAt(i + 1).match(terminalRegex)) {\n                i++;\n                this.pos = i;\n            } else if (this.str.charAt(i).match(terminalRegex)) {\n                break;\n            }\n            chars.push(this.str.charAt(i));\n        }\n        return chars.join(\"\");\n    }\n    readTokens(): Token[] {\n        const tokens: Token[] = [];\n        let nextToken;\n        while (nextToken = this.readNextToken())\n            tokens.push(nextToken);\n        return tokens;\n    }\n\n    readNextToken(): Token | undefined {\n        if (this.pos >= this.str.length)\n            return undefined;\n\n        const currentChar: string = this.str.charAt(this.pos);\n\n        if (isSingleWhiteSpaceCharacter(currentChar))\n            return this.eatWhiteSpace();\n        else if (isSpecialChar(currentChar)) {\n            return this.eatSpecialChars(currentChar);\n        } else if (isNum(currentChar)) {\n            return this.eatNumericString(currentChar);\n        } else {\n            return this.eatIdString();\n        }\n    }\n\n    // NOTE: not needed? delete?\n    // isEscapeChar(i: number): boolean {\n    //     if (this.str.charAt(i) == '\\\\') {\n    //         // Might be an escaped character\n    //         const nextChar = this.str.charAt(i + 1);\n    //\n    //         // We've escaped a special character\n    //         return isEscapableChar(nextChar);\n    //     } else return false;\n    // }\n\n    private eatIdString(): IdToken {\n        // id\n        const chars: string[] = [];\n        const pos2 = this.pos;\n        for (let i = pos2; i < this.len + 1; i++) {\n            this.pos = i;\n            // console.log(this.pos, i);\n            // console.log(this.pos, this.str.charAt(i));\n            const charAtI = this.str.charAt(i);\n            if (!isIdChar(charAtI)) {\n                break;\n                // else if (charAtI == '\\\\' && (this.str.charAt(i + 1) == '\\\\' || isSpecialChar(this.str.charAt(i + 1)))) {\n                //  i++;\n                //  this.pos = i;\n                //  chars.push(this.str.charAt(i));\n            } else {\n                chars.push(charAtI);\n            }\n        }\n\n        return newIdToken(chars.join(\"\").trim());\n    }\n\n    private eatNumericString(startAt: NumericChar): number | NumberToken {\n        const nums: NumericChar[] = [startAt];\n\n        const nextPos = this.pos + 1;\n        for (let newPos = nextPos; newPos < this.len + 1; newPos++) {\n            this.pos = newPos;\n\n            const newChar = this.str.charAt(newPos);\n            if (isNum(newChar))\n                nums.push(newChar);\n            else\n                break;\n        }\n\n        const numericString: string = nums.join(\"\");\n\n        if (nums[0] === \"0\")  // If it starts with 0, return as a string\n            return newNumber(numericString);\n        else {\n            const number = Number.parseInt(numericString);\n            return Number.isFinite(number) ? number : newNumber(numericString);\n        }\n    }\n\n    private eatSpecialChars(startAt: string): string | TypedToken {\n        this.pos++;\n        if (startAt === \"@\") {\n            const type = this.getStringUntilNonEscapedChar(\"{\").trim().toLowerCase();\n            if (isBibType(type))\n                return newToken(bibTypes[type], type);\n            else\n                return newToken(\"@bib\", type);\n        }\n        return startAt;\n    }\n\n    private eatWhiteSpace(): WhitespaceToken {\n        const chars: SingleWhitespace[] = [];\n        while (this.pos < this.len + 1) {\n            const c = this.str.charAt(this.pos);\n            // ignore whitespaces\n            if (isSingleWhiteSpaceCharacter(c)) {\n                chars.push(c);\n                this.pos++;\n            } else break;\n        }\n        return newWhitespace(chars.join(\"\"));\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/lexer/Lexer.ts","function id(x) {\n    return x[0];\n}\n\nconst isNumber = function (x) {\n    return x.constructor === Number || (typeof x === \"object\" && x.type === \"number\");\n};\nconst tok_id = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"id\";\n    }\n};\nconst entry_type_bib = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"@bib\";\n    }\n};\nconst entry_type_string = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"@string\";\n    }\n};\nconst entry_type_preamble = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"@preamble\";\n    }\n};\nconst entry_type_comment = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"@comment\";\n    }\n};\nconst ws: any = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"ws\";\n    }\n};\nconst num: any = {test: isNumber};\nconst pound: any = {literal: \"#\"};\nconst eq: any = {literal: \"=\"};\nconst esc: any = {literal: \"\\\\\"};\nconst paren_l = {literal: \"(\"};\nconst paren_r = {literal: \")\"};\nconst brace_l = {literal: \"{\"};\nconst brace_r = {literal: \"}\"};\nconst quote_dbl = {literal: \"\\\"\"};\nconst comma: any = {literal: \",\"};\n\n\nfunction addToObj(obj, keyval) {\n    if (keyval.type !== \"keyval\") throw new Error(\"Expected a keyval object\");\n    const key = keyval.key.toLowerCase();\n    if (obj.fields[key]) {\n        console.log(\"WARNING: field '\" + key + \"' was already defined on \" + obj[\"@type\"] + \" object with id '\" + obj._id + \"'. Ignoring this value.\");\n        return;\n    } else {\n        obj.fields[key] = keyval.value;\n        return obj;\n    }\n}\n\nfunction joinTokens(arr) {\n    const strs: any = [];\n    for (let i = 0; i < arr.length; i++) {\n        if (typeof arr[i] === \"object\") {\n            if (!arr[i].string) throw new Error(\"Expected token to have a string field called 'string' in object \" + JSON.stringify(arr[i]));\n            strs.push(arr[i].string);\n        } else if (typeof arr[i] === \"string\" || typeof arr[i] === \"number\") {\n            strs.push(arr[i]);\n        } else throw new Error(\"Could not handle token \" + JSON.stringify(arr[i]) + \" in array \" + JSON.stringify(arr));\n    }\n    return strs.join(\"\");\n}\n\nexport const grammar: any = {\n    Lexer: undefined,\n    ParserRules: [\n        {\"name\": \"main$ebnf$1\", \"symbols\": [\"non_entry\"], \"postprocess\": id},\n        {\n            \"name\": \"main$ebnf$1\", \"symbols\": [], \"postprocess\": function () {\n            return undefined;\n        }\n        },\n        {\"name\": \"main$ebnf$2\", \"symbols\": []},\n        {\"name\": \"main$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [\"non_entry\"], \"postprocess\": id},\n        {\n            \"name\": \"main$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function () {\n            return undefined;\n        }\n        },\n        {\"name\": \"main$ebnf$2$subexpression$1\", \"symbols\": [\"entry\", \"main$ebnf$2$subexpression$1$ebnf$1\"]},\n        {\n            \"name\": \"main$ebnf$2\",\n            \"symbols\": [\"main$ebnf$2\", \"main$ebnf$2$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"main\",\n            \"symbols\": [\"main$ebnf$1\", \"main$ebnf$2\"],\n            \"postprocess\": function (data) {\n                const topLevelObjects: any = [];\n                // console.log(JSON.stringify(data));\n                if (data[0])\n                    topLevelObjects.push({type: \"NON_ENTRY\", data: data[0]});\n\n                for (let i = 0; i < data[1].length; i++) {\n\n                    topLevelObjects.push({type: \"ENTRY\", data: data[1][i][0]});\n\n                    if (data[1][i][1])\n                        topLevelObjects.push({type: \"NON_ENTRY\", data: data[1][i][1]});\n                }\n                return topLevelObjects;\n            }\n        },\n        {\"name\": \"_$ebnf$1\", \"symbols\": []},\n        {\n            \"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", ws], \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n        },\n        {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"]},\n        {\"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\n            \"name\": \"entry_decl\",\n            \"symbols\": [\"entry_decl$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0];\n            }\n        },\n        {\"name\": \"entry$subexpression$1\", \"symbols\": [\"bib_entry\"]},\n        {\"name\": \"entry$subexpression$1\", \"symbols\": [\"string_entry\"]},\n        {\"name\": \"entry$subexpression$1\", \"symbols\": [\"preamble_entry\"]},\n        {\"name\": \"entry$subexpression$1\", \"symbols\": [\"comment_entry\"]},\n        {\n            \"name\": \"entry\", \"symbols\": [\"entry$subexpression$1\"], \"postprocess\": function (data) {\n            return data[0][0];\n        }\n        },\n        {\n            \"name\": \"comment\", \"symbols\": [\"main\"], \"postprocess\": function (data) {\n            return data[0];\n        }\n        },\n        {\"name\": \"comment_liberal$ebnf$1\", \"symbols\": []},\n        {\"name\": \"comment_liberal$ebnf$1$subexpression$1\", \"symbols\": [/./]},\n        {\n            \"name\": \"comment_liberal$ebnf$1\",\n            \"symbols\": [\"comment_liberal$ebnf$1\", \"comment_liberal$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"comment_liberal\",\n            \"symbols\": [\"comment_liberal$ebnf$1\"],\n            \"postprocess\": function (data) {\n                const toeknz: any = [];\n                for (let tk = 0; tk < data[0].length; tk++)\n                    toeknz.push(data[0][tk][0]);\n                return toeknz;\n            }\n        },\n        {\"name\": \"entry_body_comment$subexpression$1$macrocall$2\", \"symbols\": [\"comment\"]},\n        {\n            \"name\": \"entry_body_comment$subexpression$1$macrocall$1\",\n            \"symbols\": [paren_l, \"entry_body_comment$subexpression$1$macrocall$2\", paren_r],\n            \"postprocess\": function (data) {\n                return data[1];\n            }\n        },\n        {\"name\": \"entry_body_comment$subexpression$1\", \"symbols\": [\"entry_body_comment$subexpression$1$macrocall$1\"]},\n        {\"name\": \"entry_body_comment$subexpression$1$macrocall$4\", \"symbols\": [\"comment\"]},\n        {\n            \"name\": \"entry_body_comment$subexpression$1$macrocall$3\",\n            \"symbols\": [brace_l, \"entry_body_comment$subexpression$1$macrocall$4\", brace_r],\n            \"postprocess\": function (data) {\n                return data[1];\n            }\n        },\n        {\"name\": \"entry_body_comment$subexpression$1\", \"symbols\": [\"entry_body_comment$subexpression$1$macrocall$3\"]},\n        {\n            \"name\": \"entry_body_comment\",\n            \"symbols\": [\"entry_body_comment$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0][0];\n            }\n        },\n        {\"name\": \"entry_body_string$subexpression$1$macrocall$2\", \"symbols\": [\"keyval\"]},\n        {\n            \"name\": \"entry_body_string$subexpression$1$macrocall$1\",\n            \"symbols\": [paren_l, \"_\", \"entry_body_string$subexpression$1$macrocall$2\", \"_\", paren_r],\n            \"postprocess\": function (data) {\n                return data[2];\n            }\n        },\n        {\"name\": \"entry_body_string$subexpression$1\", \"symbols\": [\"entry_body_string$subexpression$1$macrocall$1\"]},\n        {\"name\": \"entry_body_string$subexpression$1$macrocall$4\", \"symbols\": [\"keyval\"]},\n        {\n            \"name\": \"entry_body_string$subexpression$1$macrocall$3\",\n            \"symbols\": [brace_l, \"_\", \"entry_body_string$subexpression$1$macrocall$4\", \"_\", brace_r],\n            \"postprocess\": function (data) {\n                return data[2];\n            }\n        },\n        {\"name\": \"entry_body_string$subexpression$1\", \"symbols\": [\"entry_body_string$subexpression$1$macrocall$3\"]},\n        {\n            \"name\": \"entry_body_string\",\n            \"symbols\": [\"entry_body_string$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0][0];\n            }\n        },\n        {\"name\": \"entry_body_bib$subexpression$1$macrocall$2\", \"symbols\": [\"bib_content\"]},\n        {\n            \"name\": \"entry_body_bib$subexpression$1$macrocall$1\",\n            \"symbols\": [paren_l, \"_\", \"entry_body_bib$subexpression$1$macrocall$2\", \"_\", paren_r],\n            \"postprocess\": function (data) {\n                return data[2];\n            }\n        },\n        {\"name\": \"entry_body_bib$subexpression$1\", \"symbols\": [\"entry_body_bib$subexpression$1$macrocall$1\"]},\n        {\"name\": \"entry_body_bib$subexpression$1$macrocall$4\", \"symbols\": [\"bib_content\"]},\n        {\n            \"name\": \"entry_body_bib$subexpression$1$macrocall$3\",\n            \"symbols\": [brace_l, \"_\", \"entry_body_bib$subexpression$1$macrocall$4\", \"_\", brace_r],\n            \"postprocess\": function (data) {\n                return data[2];\n            }\n        },\n        {\"name\": \"entry_body_bib$subexpression$1\", \"symbols\": [\"entry_body_bib$subexpression$1$macrocall$3\"]},\n        {\n            \"name\": \"entry_body_bib\",\n            \"symbols\": [\"entry_body_bib$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0][0];\n            }\n        },\n        {\"name\": \"bib_content$ebnf$1\", \"symbols\": []},\n        {\"name\": \"bib_content$ebnf$1$subexpression$1\", \"symbols\": [\"keyval\", \"_\", comma, \"_\"]},\n        {\n            \"name\": \"bib_content$ebnf$1\",\n            \"symbols\": [\"bib_content$ebnf$1\", \"bib_content$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\"name\": \"bib_content$ebnf$2$subexpression$1\", \"symbols\": [\"_\", comma]},\n        {\"name\": \"bib_content$ebnf$2\", \"symbols\": [\"bib_content$ebnf$2$subexpression$1\"], \"postprocess\": id},\n        {\n            \"name\": \"bib_content$ebnf$2\", \"symbols\": [], \"postprocess\": function () {\n            return undefined;\n        }\n        },\n        {\n            \"name\": \"bib_content\",\n            \"symbols\": [\"key_string\", \"_\", comma, \"_\", \"bib_content$ebnf$1\", \"keyval\", \"bib_content$ebnf$2\"],\n            \"postprocess\": function (data) {\n                const obj: any = {\n                    _id: data[0],\n                    fields: []\n                };\n                const keyvals = data[4];\n                for (let kv = 0; kv < keyvals.length; kv++) {\n                    obj.fields.push(keyvals[kv][0]);\n                }\n                obj.fields.push(data[5]);\n                return obj;\n            }\n        },\n        {\n            \"name\": \"bib_entry\",\n            \"symbols\": [entry_type_bib, \"_\", \"entry_body_bib\"],\n            \"postprocess\": function (data) {\n                const obj: any = {\n                    _id: data[2]._id\n                };\n                obj[\"@type\"] = data[0].string;\n                obj.fields = {};\n\n                const keyvals = data[2].fields;\n                for (let kv = 0; kv < keyvals.length; kv++) {\n                    addToObj(obj, keyvals[kv]);\n                }\n                return obj;\n            }\n        },\n        {\n            \"name\": \"string_entry\",\n            \"symbols\": [entry_type_string, \"_\", \"entry_body_string\"],\n            \"postprocess\": function (data) {\n                return {type: \"string\", data: data[2]};\n            }\n        },\n        {\n            \"name\": \"preamble_entry\",\n            \"symbols\": [entry_type_preamble, \"_\", \"entry_body_comment\"],\n            \"postprocess\": function (data) {\n                return {type: \"preamble\", data: data[2]};\n            }\n        },\n        {\n            \"name\": \"comment_entry\",\n            \"symbols\": [entry_type_comment, \"_\", \"entry_body_comment\"],\n            \"postprocess\": function (data) {\n                return {type: \"comment\", data: data[2]};\n            }\n        },\n        {\n            \"name\": \"keyval\",\n            \"symbols\": [\"key_string\", \"_\", eq, \"_\", \"value_string\"],\n            \"postprocess\": function (data) {\n                return {type: \"keyval\", key: data[0], value: data[4]};\n            }\n        },\n        {\"name\": \"braced_string$ebnf$1\", \"symbols\": []},\n        {\"name\": \"braced_string$ebnf$1$subexpression$1\", \"symbols\": [\"non_brace\"]},\n        {\"name\": \"braced_string$ebnf$1$subexpression$1\", \"symbols\": [\"braced_string\"]},\n        {\n            \"name\": \"braced_string$ebnf$1\",\n            \"symbols\": [\"braced_string$ebnf$1\", \"braced_string$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"braced_string\",\n            \"symbols\": [brace_l, \"braced_string$ebnf$1\", brace_r],\n            \"postprocess\": function (data) {\n                const tkz: any = [];\n                for (const i in data[1]) tkz.push(data[1][i][0]);\n                return {type: \"braced\", data: tkz};\n            }\n\n        },\n        {\"name\": \"quoted_string$ebnf$1\", \"symbols\": []},\n        {\"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_quote\"]},\n        {\"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"non_quote_non_brace\"]},\n        {\"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"braced_string\"]},\n        {\n            \"name\": \"quoted_string$ebnf$1\",\n            \"symbols\": [\"quoted_string$ebnf$1\", \"quoted_string$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"quoted_string\",\n            \"symbols\": [quote_dbl, \"quoted_string$ebnf$1\", quote_dbl],\n            \"postprocess\": function (data) {\n                const tks: any = [];\n                for (const i in data[1]) tks.push(data[1][i][0]);\n                return {type: \"quotedstring\", data: tks};\n            }\n        },\n        {\"name\": \"escaped_quote\", \"symbols\": [esc, quote_dbl]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [ws]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [pound]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [eq]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [comma]},\n        {\"name\": \"non_quote_non_brace\", \"symbols\": [\"non_quote_non_brace$subexpression$1\"]},\n        {\"name\": \"key_string$ebnf$1\", \"symbols\": [\"stringreftoken\"]},\n        {\n            \"name\": \"key_string$ebnf$1\",\n            \"symbols\": [\"key_string$ebnf$1\", \"stringreftoken\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"key_string\", \"symbols\": [\"key_string$ebnf$1\"], \"postprocess\": function (data) {\n            return joinTokens(data[0]).toLowerCase();\n        }\n        },\n        {\"name\": \"value_string$subexpression$1$ebnf$1\", \"symbols\": []},\n        {\n            \"name\": \"value_string$subexpression$1$ebnf$1$subexpression$1\",\n            \"symbols\": [\"_\", pound, \"_\", \"quoted_string_or_ref\"]\n        },\n        {\n            \"name\": \"value_string$subexpression$1$ebnf$1\",\n            \"symbols\": [\"value_string$subexpression$1$ebnf$1\", \"value_string$subexpression$1$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"value_string$subexpression$1\",\n            \"symbols\": [\"quoted_string_or_ref\", \"value_string$subexpression$1$ebnf$1\"]\n        },\n        {\"name\": \"value_string$subexpression$1\", \"symbols\": [\"braced_string\"]},\n        {\n            \"name\": \"value_string\",\n            \"symbols\": [\"value_string$subexpression$1\"],\n            \"postprocess\": function (data) {\n                // console.log(\"DATA\",JSON.stringify(data));\n                const match = data[0];\n                if (match.length === 2) {\n                    // quoted string\n                    const tokenz: any = [];\n                    tokenz.push(match[0]);\n                    for (let i = 0; i < match[1].length; i++) tokenz.push(match[1][i][3]);\n                    return {type: \"quotedstringwrapper\", data: tokenz};\n                } else if (match[0].type === \"braced\")\n                    return {type: \"bracedstringwrapper\", data: match[0].data};\n                // else if(isNumber(match[0]) return [match[0]];\n                else throw new Error(\"Don't know how to handle value \" + JSON.stringify(match[0]));\n            }\n        },\n        {\"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [\"quoted_string\"]},\n        {\"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [\"string_ref\"]},\n        {\"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [num]},\n        {\n            \"name\": \"quoted_string_or_ref\",\n            \"symbols\": [\"quoted_string_or_ref$subexpression$1\"],\n            \"postprocess\": function (data) {\n                // console.log(data);\n                if (data[0][0].type === \"quotedstring\") return data[0][0];\n                else {\n                    return data[0][0];\n                }\n            }\n        },\n        {\"name\": \"string_ref$subexpression$1$ebnf$1\", \"symbols\": []},\n        {\n            \"name\": \"string_ref$subexpression$1$ebnf$1\",\n            \"symbols\": [\"string_ref$subexpression$1$ebnf$1\", \"stringreftoken\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"string_ref$subexpression$1\",\n            \"symbols\": [\"stringreftoken_n_num\", \"string_ref$subexpression$1$ebnf$1\"]\n        },\n        {\n            \"name\": \"string_ref\",\n            \"symbols\": [\"string_ref$subexpression$1\"],\n            \"postprocess\": function (data) {\n                const str = data[0][0] + joinTokens(data[0][1]);\n                return {stringref: str};\n            }\n        },\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\n            \"name\": \"stringreftoken\",\n            \"symbols\": [\"stringreftoken$subexpression$1\"],\n            \"postprocess\": function (data) {\n                if (typeof data[0][0] === \"object\") {\n                    if (!data[0][0].string) throw new Error(\"Expected \" + data[0] + \"to have a 'string' field\");\n                    return data[0][0].string;\n                } else {\n                    if ((!(typeof data[0][0] === \"string\" || typeof data[0][0] === \"number\")))\n                        throw new Error(\"Expected \" + data[0][0] + \" to be a string\");\n                    return data[0][0];\n                }\n            }\n        },\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\n            \"name\": \"stringreftoken_n_num\",\n            \"symbols\": [\"stringreftoken_n_num$subexpression$1\"],\n            \"postprocess\": function (data) {\n                if (typeof data[0][0] === \"object\") {\n                    if (!data[0][0].string) throw new Error(\"Expected \" + data[0] + \"to have a 'string' field\");\n                    return data[0][0].string;\n                } else {\n                    if ((!(typeof data[0][0] === \"string\" || typeof data[0][0] === \"number\")))\n                        throw new Error(\"Expected \" + data[0][0] + \" to be a string\");\n                    return data[0][0];\n                }\n            }\n        },\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [quote_dbl]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [ws]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [comma]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [pound]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [eq]},\n        {\n            \"name\": \"non_brace\",\n            \"symbols\": [\"non_brace$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0];\n            }\n        },\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [quote_dbl]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [ws]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [comma]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [pound]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [eq]},\n        {\n            \"name\": \"non_bracket\",\n            \"symbols\": [\"non_bracket$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0];\n            }\n        },\n        {\"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_entry\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_escape\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_non_esc_outside_entry\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"non_esc_outside_entry\"]},\n        {\"name\": \"non_entry$ebnf$1\", \"symbols\": [\"non_entry$ebnf$1$subexpression$1\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_entry\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_escape\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_non_esc_outside_entry\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"non_esc_outside_entry\"]},\n        {\n            \"name\": \"non_entry$ebnf$1\",\n            \"symbols\": [\"non_entry$ebnf$1\", \"non_entry$ebnf$1$subexpression$2\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"non_entry\", \"symbols\": [\"non_entry$ebnf$1\"], \"postprocess\": function (data) {\n            // console.log(\"non_entry\",data);\n            const tokens: any = [];\n            for (let Ti = 0; Ti < data[0].length; Ti++) tokens.push(data[0][Ti][0]);\n            return tokens;\n        }\n        },\n        {\n            \"name\": \"escaped_escape\", \"symbols\": [esc, esc], \"postprocess\": function () {\n            return \"\\\\\";\n        }\n        },\n        {\n            \"name\": \"escaped_entry\", \"symbols\": [esc, \"entry_decl\"], \"postprocess\": function (data) {\n            return {type: \"escapedEntry\", data: data[1]};\n        }\n        },\n        {\n            \"name\": \"escaped_non_esc_outside_entry\",\n            \"symbols\": [esc, \"non_esc_outside_entry\"],\n            \"postprocess\": function (data) {\n                return data; // [\"\\\\\", data[1]];\n            }\n        },\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [ws]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [pound]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [eq]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [brace_l]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [brace_r]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [quote_dbl]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [comma]},\n        {\n            \"name\": \"non_esc_outside_entry\",\n            \"symbols\": [\"non_esc_outside_entry$subexpression$1\"],\n            \"postprocess\": function (data) {\n                // console.log(\"ooutside_entry\",data[0][0]);\n                return data[0][0];\n            }\n        }\n    ]\n    , ParserStart: \"main\"\n};\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/parser/ts-parser.ts","(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\nfunction Rule(name, symbols, postprocess) {\n    this.id = ++Rule.highestId;\n    this.name = name;\n    this.symbols = symbols;        // a list of literal | regex class | nonterminal\n    this.postprocess = postprocess;\n    return this;\n}\nRule.highestId = 0;\n\nRule.prototype.toString = function(withCursorAt) {\n    function stringifySymbolSequence (e) {\n        return e.literal ? JSON.stringify(e.literal) :\n               e.type ? '%' + e.type : e.toString();\n    }\n    var symbolSequence = (typeof withCursorAt === \"undefined\")\n                         ? this.symbols.map(stringifySymbolSequence).join(' ')\n                         : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                             + \"  \"\n                             + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n    return this.name + \"  \" + symbolSequence;\n}\n\n\n// a State is a rule at a position from a given starting point in the input stream (reference)\nfunction State(rule, dot, reference, wantedBy) {\n    this.rule = rule;\n    this.dot = dot;\n    this.reference = reference;\n    this.data = [];\n    this.wantedBy = wantedBy;\n    this.isComplete = this.dot === rule.symbols.length;\n}\n\nState.prototype.toString = function() {\n    return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n};\n\nState.prototype.nextState = function(child) {\n    var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n    state.left = this;\n    state.right = child;\n    if (state.isComplete) {\n        state.data = state.build();\n    }\n    return state;\n};\n\nState.prototype.build = function() {\n    var children = [];\n    var node = this;\n    do {\n        children.push(node.right.data);\n        node = node.left;\n    } while (node.left);\n    children.reverse();\n    return children;\n};\n\nState.prototype.finish = function() {\n    if (this.rule.postprocess) {\n        this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n    }\n};\n\n\nfunction Column(grammar, index) {\n    this.grammar = grammar;\n    this.index = index;\n    this.states = [];\n    this.wants = {}; // states indexed by the non-terminal they expect\n    this.scannable = []; // list of states that expect a token\n    this.completed = {}; // states that are nullable\n}\n\n\nColumn.prototype.process = function(nextColumn) {\n    var states = this.states;\n    var wants = this.wants;\n    var completed = this.completed;\n\n    for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n        var state = states[w];\n\n        if (state.isComplete) {\n            state.finish();\n            if (state.data !== Parser.fail) {\n                // complete\n                var wantedBy = state.wantedBy;\n                for (var i = wantedBy.length; i--; ) { // this line is hot\n                    var left = wantedBy[i];\n                    this.complete(left, state);\n                }\n\n                // special-case nullables\n                if (state.reference === this.index) {\n                    // make sure future predictors of this rule get completed.\n                    var exp = state.rule.name;\n                    (this.completed[exp] = this.completed[exp] || []).push(state);\n                }\n            }\n\n        } else {\n            // queue scannable states\n            var exp = state.rule.symbols[state.dot];\n            if (typeof exp !== 'string') {\n                this.scannable.push(state);\n                continue;\n            }\n\n            // predict\n            if (wants[exp]) {\n                wants[exp].push(state);\n\n                if (completed.hasOwnProperty(exp)) {\n                    var nulls = completed[exp];\n                    for (var i = 0; i < nulls.length; i++) {\n                        var right = nulls[i];\n                        this.complete(state, right);\n                    }\n                }\n            } else {\n                wants[exp] = [state];\n                this.predict(exp);\n            }\n        }\n    }\n}\n\nColumn.prototype.predict = function(exp) {\n    var rules = this.grammar.byName[exp] || [];\n\n    for (var i = 0; i < rules.length; i++) {\n        var r = rules[i];\n        var wantedBy = this.wants[exp];\n        var s = new State(r, 0, this.index, wantedBy);\n        this.states.push(s);\n    }\n}\n\nColumn.prototype.complete = function(left, right) {\n    var inp = right.rule.name;\n    if (left.rule.symbols[left.dot] === inp) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n}\n\n\nfunction Grammar(rules, start) {\n    this.rules = rules;\n    this.start = start || this.rules[0].name;\n    var byName = this.byName = {};\n    this.rules.forEach(function(rule) {\n        if (!byName.hasOwnProperty(rule.name)) {\n            byName[rule.name] = [];\n        }\n        byName[rule.name].push(rule);\n    });\n}\n\n// So we can allow passing (rules, start) directly to Parser for backwards compatibility\nGrammar.fromCompiled = function(rules, start) {\n    var lexer = rules.Lexer;\n    if (rules.ParserStart) {\n      start = rules.ParserStart;\n      rules = rules.ParserRules;\n    }\n    var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n    var g = new Grammar(rules, start);\n    g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n    return g;\n}\n\n\nfunction StreamLexer() {\n  this.reset(\"\");\n}\n\nStreamLexer.prototype.reset = function(data, state) {\n    this.buffer = data;\n    this.index = 0;\n    this.line = state ? state.line : 1;\n    this.lastLineBreak = state ? -state.col : 0;\n}\n\nStreamLexer.prototype.next = function() {\n    if (this.index < this.buffer.length) {\n        var ch = this.buffer[this.index++];\n        if (ch === '\\n') {\n          this.line += 1;\n          this.lastLineBreak = this.index;\n        }\n        return {value: ch};\n    }\n}\n\nStreamLexer.prototype.save = function() {\n  return {\n    line: this.line,\n    col: this.index - this.lastLineBreak,\n  }\n}\n\nStreamLexer.prototype.formatError = function(token, message) {\n    // nb. this gets called after consuming the offending token,\n    // so the culprit is index-1\n    var buffer = this.buffer;\n    if (typeof buffer === 'string') {\n        var nextLineBreak = buffer.indexOf('\\n', this.index);\n        if (nextLineBreak === -1) nextLineBreak = buffer.length;\n        var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n        var col = this.index - this.lastLineBreak;\n        message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n        message += \"  \" + line + \"\\n\"\n        message += \"  \" + Array(col).join(\" \") + \"^\"\n        return message;\n    } else {\n        return message + \" at index \" + (this.index - 1);\n    }\n}\n\n\nfunction Parser(rules, start, options) {\n    if (rules instanceof Grammar) {\n        var grammar = rules;\n        var options = start;\n    } else {\n        var grammar = Grammar.fromCompiled(rules, start);\n    }\n    this.grammar = grammar;\n\n    // Read options\n    this.options = {\n        keepHistory: false,\n        lexer: grammar.lexer || new StreamLexer,\n    };\n    for (var key in (options || {})) {\n        this.options[key] = options[key];\n    }\n\n    // Setup lexer\n    this.lexer = this.options.lexer;\n    this.lexerState = undefined;\n\n    // Setup a table\n    var column = new Column(grammar, 0);\n    var table = this.table = [column];\n\n    // I could be expecting anything.\n    column.wants[grammar.start] = [];\n    column.predict(grammar.start);\n    // TODO what if start rule is nullable?\n    column.process();\n    this.current = 0; // token index\n}\n\n// create a reserved token for indicating a parse fail\nParser.fail = {};\n\nParser.prototype.feed = function(chunk) {\n    var lexer = this.lexer;\n    lexer.reset(chunk, this.lexerState);\n\n    var token;\n    while (token = lexer.next()) {\n        // We add new states to table[current+1]\n        var column = this.table[this.current];\n\n        // GC unused states\n        if (!this.options.keepHistory) {\n            delete this.table[this.current - 1];\n        }\n\n        var n = this.current + 1;\n        var nextColumn = new Column(this.grammar, n);\n        this.table.push(nextColumn);\n\n        // Advance all tokens that expect the symbol\n        var literal = token.value;\n        var value = lexer.constructor === StreamLexer ? token.value : token;\n        var scannable = column.scannable;\n        for (var w = scannable.length; w--; ) {\n            var state = scannable[w];\n            var expect = state.rule.symbols[state.dot];\n            // Try to consume the token\n            // either regex or literal\n            if (expect.test ? expect.test(value) :\n                expect.type ? expect.type === token.type\n                            : expect.literal === literal) {\n                // Add it\n                var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                nextColumn.states.push(next);\n            }\n        }\n\n        // Next, for each of the rules, we either\n        // (a) complete it, and try to see if the reference row expected that\n        //     rule\n        // (b) predict the next nonterminal it expects by adding that\n        //     nonterminal's start state\n        // To prevent duplication, we also keep track of rules we have already\n        // added\n\n        nextColumn.process();\n\n        // If needed, throw an error:\n        if (nextColumn.states.length === 0) {\n            // No states at all! This is not good.\n            var message = this.lexer.formatError(token, \"invalid syntax\") + \"\\n\";\n            message += \"Unexpected \" + (token.type ? token.type + \" token: \" : \"\");\n            message += JSON.stringify(token.value !== undefined ? token.value : token) + \"\\n\";\n            var err = new Error(message);\n            err.offset = this.current;\n            err.token = token;\n            throw err;\n        }\n\n        // maybe save lexer state\n        if (this.options.keepHistory) {\n          column.lexerState = lexer.save()\n        }\n\n        this.current++;\n    }\n    if (column) {\n      this.lexerState = lexer.save()\n    }\n\n    // Incrementally keep track of results\n    this.results = this.finish();\n\n    // Allow chaining, for whatever it's worth\n    return this;\n};\n\nParser.prototype.save = function() {\n    var column = this.table[this.current];\n    column.lexerState = this.lexerState;\n    return column;\n};\n\nParser.prototype.restore = function(column) {\n    var index = column.index;\n    this.current = index;\n    this.table[index] = column;\n    this.table.splice(index + 1);\n    this.lexerState = column.lexerState;\n\n    // Incrementally keep track of results\n    this.results = this.finish();\n};\n\n// nb. deprecated: use save/restore instead!\nParser.prototype.rewind = function(index) {\n    if (!this.options.keepHistory) {\n        throw new Error('set option `keepHistory` to enable rewinding')\n    }\n    // nb. recall column (table) indicies fall between token indicies.\n    //        col 0   --   token 0   --   col 1\n    this.restore(this.table[index]);\n};\n\nParser.prototype.finish = function() {\n    // Return the possible parsings\n    var considerations = [];\n    var start = this.grammar.start;\n    var column = this.table[this.table.length - 1]\n    column.states.forEach(function (t) {\n        if (t.rule.name === start\n                && t.dot === t.rule.symbols.length\n                && t.reference === 0\n                && t.data !== Parser.fail) {\n            considerations.push(t);\n        }\n    });\n    return considerations.map(function(c) {return c.data; });\n};\n\nreturn {\n    Parser: Parser,\n    Grammar: Grammar,\n    Rule: Rule,\n};\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nearley/lib/nearley.js\n// module id = 22\n// module chunks = 0"],"sourceRoot":""}