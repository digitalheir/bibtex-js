{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap 64e00cd164dba9bfe415","webpack:///./src/util.ts","webpack:///./src/bibfile/BibEntry.ts","webpack:///./src/bibfile/string/BracedString.ts","webpack:///./src/bibfile/string/QuotedString.ts","webpack:///./src/bibfile/string/StringRef.ts","webpack:///./src/bibfile/string/BibStringItem.ts","webpack:///./src/bibfile/BibComment.ts","webpack:///./src/bibfile/BibFile.ts","webpack:///./src/bibfile/BibPreamble.ts","webpack:///./src/bibfile/string/StringEntry.ts","webpack:///./src/bibfile/KeyVal.ts","webpack:///./src/lexer/NumericToken.ts","webpack:///./src/lexer/Token.ts","webpack:///./src/lexer/WhitespaceToken.ts","webpack:///./src/index.ts","webpack:///./src/lexer/BibBlockTypes.ts","webpack:///./src/lexer/IdToken.ts","webpack:///./src/lexer/Lexer.ts","webpack:///./src/parser/ts-parser.ts","webpack:///./~/nearley/lib/nearley.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isString","data","isNumber","mustBeString","str","Error","JSON","stringify","mustBeDefined","t","undefined","mustBeArray","isArray","constructor","Array","flattenMyArray","arr","result","length","_i","_length","value2","push","_classCallCheck","instance","Constructor","TypeError","parseEntryFields","fields","fieldz","keys","forEach","key","parseFieldValue","parseStringComponent","braceDepth","obj","util_1","StringRef_1","isStringRef","StringRef","stringref","type","string","BracedString_1","BracedString","map","e","flattened","QuotedString_1","QuotedString","OuterQuotedString","OuterBracedString","isBibEntry","x","_createClass","defineProperties","target","props","descriptor","writable","protoProps","staticProps","BibEntry","id","_id","sortkey$","title$","toLowerCase","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","isOuterBracedString","isBracedString","BibStringItem_1","_BibStringItem_1$BibS","getPrototypeOf","BibStringComponent","_BibStringItem_1$BibS2","isOuterQuotedString","isQuotedString","isBibStringComponent","isBibComment","flattenPlainText","flattenO","BibComment","join","CommentEntry","wrapper","toString","parseNonEntry","nonEntry","BibComment_1","parseEntry","entry","_typeof","BibEntry_1","StringEntry_1","newStringNode","BibPreamble_1","newPreambleNode","parseBibFile","input","nearley","Parser","ts_parser_1","grammar","ParserRules","ParserStart","feed","Lexer_1","default","readTokens","res","results","parse","BibFile","parseBibEntriesAndNonEntries","Symbol","iterator","KeyVal_1","content","comments","filter","entries","entryMap","entries$","preambles","isPreamble","preamble$","strings","isKeyVal","strings$","resolveStrings","entity","BibFile_1","Preamble","_defineProperty","findKeyVal","newKeyVal","resolved","resolveStringReference","_findKeyVal","StringEntry","resolveStringReferences","seenBeforeStack","alreadyResolved","refs","datum","resolveStringRef","copyWithResolvedStringReferences","copyOuterWithResolvedStringReferences","newData","copied","refName","assign","newNumber","isNum","numericChars","0","1","2","3","4","5","6","7","8","9","newToken","isSpecialChar","specialChars","isEscapableChar","escapableChars","@","(",")","{","}","#","=",",","\\","\"","newWhitespace","isWhitespace","token","WS","isSingleWhiteSpaceCharacter","singleWhitespaces"," ","\t","\r","\n","__export","bibTypes","preamble","comment","bib","isBibType","newIdToken","isIdToken","isIdChar","Token_1","NumericToken_1","WhitespaceToken_1","IdToken_1","BibBlockTypes_1","Lexer","len","pos","terminalRegex","chars","charAt","match","tokens","nextToken","readNextToken","currentChar","eatWhiteSpace","eatSpecialChars","eatNumericString","eatIdString","pos2","charAtI","trim","startAt","nums","nextPos","newPos","newChar","numericString","number","Number","parseInt","isFinite","getStringUntilNonEscapedChar","addToObj","keyval","console","log","joinTokens","strs","tok_id","test","entry_type_bib","entry_type_string","entry_type_preamble","entry_type_comment","ws","num","pound","literal","eq","esc","paren_l","paren_r","brace_l","brace_r","quote_dbl","comma","symbols","postprocess","concat","topLevelObjects","toeknz","tk","keyvals","kv","tkz","tks","tokenz","Ti","Rule","highestId","State","rule","dot","reference","wantedBy","isComplete","Column","index","states","wants","scannable","completed","Grammar","rules","start","byName","StreamLexer","reset","options","fromCompiled","keepHistory","lexer","lexerState","column","table","predict","process","current","withCursorAt","stringifySymbolSequence","symbolSequence","slice","nextState","child","state","left","right","build","children","node","reverse","finish","fail","nextColumn","w","complete","exp","nulls","r","inp","copy","g","buffer","line","lastLineBreak","col","next","ch","save","formatError","message","nextLineBreak","indexOf","substring","chunk","expect","isToken","err","offset","restore","splice","rewind","considerations"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rechtspraak\"] = factory();\n\telse\n\t\troot[\"rechtspraak\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rechtspraak\"] = factory();\n\telse\n\t\troot[\"rechtspraak\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 14);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isString(data) {\n    return typeof data === \"string\";\n}\nexports.isString = isString;\nfunction isNumber(data) {\n    return typeof data === \"number\";\n}\nexports.isNumber = isNumber;\nfunction mustBeString(str, o) {\n    if (typeof str !== \"string\") throw new Error(\"Expected to be string: \" + JSON.stringify(o ? o : str));\n    return str;\n}\nexports.mustBeString = mustBeString;\nfunction mustBeDefined(t, o) {\n    if (t === undefined) throw new Error(\"Expected to be defined: \" + JSON.stringify(o ? o : t));\n    return t;\n}\nexports.mustBeDefined = mustBeDefined;\nfunction mustBeArray(str, o) {\n    if (!isArray(str)) throw new Error(\"Expected to be array: \" + JSON.stringify(o ? o : str));\n    return str;\n}\nexports.mustBeArray = mustBeArray;\nfunction isArray(data) {\n    return !!data && data.constructor === Array;\n}\nexports.isArray = isArray;\nexports.flattenMyArray = function (arr, result) {\n    if (!result) result = [];\n    for (var i = 0, length = arr.length; i < length; i++) {\n        var value = arr[i];\n        if (Array.isArray(value)) {\n            for (var _i = 0, _length = value.length; _i < _length; _i++) {\n                var value2 = value[_i];\n                if (Array.isArray(value2)) {\n                    exports.flattenMyArray(value2, result);\n                } else {\n                    result.push(value2);\n                }\n            }\n        } else {\n            result.push(value);\n        }\n    }\n    return result;\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar QuotedString_1 = __webpack_require__(3);\nvar BracedString_1 = __webpack_require__(2);\nvar util_1 = __webpack_require__(0);\nvar StringRef_1 = __webpack_require__(4);\n\nvar BibEntry = function () {\n    function BibEntry(type, id, fields) {\n        _classCallCheck(this, BibEntry);\n\n        this.type = type;\n        this._id = id;\n        this.fields = fields;\n        this.sortkey$ = \"\";\n        this.title$ = \"\";\n    }\n\n    _createClass(BibEntry, [{\n        key: \"getField\",\n        value: function getField(key) {\n            return this.fields[key.toLowerCase()];\n        }\n    }]);\n\n    return BibEntry;\n}();\n\nexports.BibEntry = BibEntry;\nfunction parseEntryFields(fields) {\n    var fieldz = {};\n    Object.keys(fields).forEach(function (key) {\n        fieldz[key] = parseFieldValue(fields[key]);\n    });\n    return fieldz;\n}\nexports.parseEntryFields = parseEntryFields;\nfunction parseStringComponent(braceDepth, obj) {\n    if (util_1.isNumber(obj) || util_1.isString(obj)) return obj;\n    if (StringRef_1.isStringRef(obj)) return new StringRef_1.StringRef(0, obj.stringref);\n    switch (util_1.mustBeString(obj.type, obj)) {\n        case \"id\":\n        case \"ws\":\n        case \"number\":\n            return util_1.mustBeString(obj.string);\n        case \"bracedstring\":\n        case \"braced\":\n            if (!util_1.isArray(obj.data)) {\n                throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n            }\n            return new BracedString_1.BracedString(braceDepth, util_1.flattenMyArray(obj.data).map(function (e) {\n                return parseStringComponent(braceDepth + 1, e);\n            }));\n        case \"quotedstring\":\n            if (!util_1.isArray(obj.data)) {\n                throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n            }\n            var flattened = util_1.flattenMyArray(obj.data);\n            return new QuotedString_1.QuotedString(braceDepth, flattened.map(function (e) {\n                return parseStringComponent(braceDepth, e);\n            }));\n        default:\n            throw new Error(\"Unexpected complex string type: \" + obj.type);\n    }\n}\nexports.parseStringComponent = parseStringComponent;\nfunction parseFieldValue(value) {\n    if (util_1.isNumber(value)) {\n        return value;\n    }\n    var data = util_1.mustBeArray(value.data);\n    switch (value.type) {\n        case \"quotedstringwrapper\":\n            if (data.length === 1 && util_1.isNumber(data[0])) return data[0];\n            return new QuotedString_1.OuterQuotedString(data.map(function (e) {\n                return parseStringComponent(0, e);\n            }));\n        case \"bracedstringwrapper\":\n            return new BracedString_1.OuterBracedString(data.map(function (e) {\n                return parseStringComponent(0, e);\n            }));\n        default:\n            throw new Error(\"Unexpected value: \" + JSON.stringify(value));\n    }\n}\nexports.parseFieldValue = parseFieldValue;\nfunction isBibEntry(x) {\n    return typeof x[\"type\"] === \"string\" && typeof x[\"_id\"] === \"string\" && !!x[\"fields\"];\n}\nexports.isBibEntry = isBibEntry;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BibStringItem_1 = __webpack_require__(5);\n\nvar BracedString = function (_BibStringItem_1$BibS) {\n    _inherits(BracedString, _BibStringItem_1$BibS);\n\n    function BracedString(braceDepth, data) {\n        _classCallCheck(this, BracedString);\n\n        return _possibleConstructorReturn(this, (BracedString.__proto__ || Object.getPrototypeOf(BracedString)).call(this, \"bracedstring\", braceDepth, data));\n    }\n\n    return BracedString;\n}(BibStringItem_1.BibStringComponent);\n\nexports.BracedString = BracedString;\n\nvar OuterBracedString = function (_BibStringItem_1$BibS2) {\n    _inherits(OuterBracedString, _BibStringItem_1$BibS2);\n\n    function OuterBracedString(data) {\n        _classCallCheck(this, OuterBracedString);\n\n        return _possibleConstructorReturn(this, (OuterBracedString.__proto__ || Object.getPrototypeOf(OuterBracedString)).call(this, \"bracedstringwrapper\", 0, data));\n    }\n\n    return OuterBracedString;\n}(BibStringItem_1.BibStringComponent);\n\nexports.OuterBracedString = OuterBracedString;\nfunction isOuterBracedString(x) {\n    return x.type === \"bracedstringwrapper\";\n}\nexports.isOuterBracedString = isOuterBracedString;\nfunction isBracedString(x) {\n    return x.type === \"bracedstring\";\n}\nexports.isBracedString = isBracedString;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BibStringItem_1 = __webpack_require__(5);\n\nvar QuotedString = function (_BibStringItem_1$BibS) {\n    _inherits(QuotedString, _BibStringItem_1$BibS);\n\n    function QuotedString(braceDepth, data) {\n        _classCallCheck(this, QuotedString);\n\n        return _possibleConstructorReturn(this, (QuotedString.__proto__ || Object.getPrototypeOf(QuotedString)).call(this, \"quotedstring\", braceDepth, data));\n    }\n\n    return QuotedString;\n}(BibStringItem_1.BibStringComponent);\n\nexports.QuotedString = QuotedString;\n\nvar OuterQuotedString = function (_BibStringItem_1$BibS2) {\n    _inherits(OuterQuotedString, _BibStringItem_1$BibS2);\n\n    function OuterQuotedString(data) {\n        _classCallCheck(this, OuterQuotedString);\n\n        return _possibleConstructorReturn(this, (OuterQuotedString.__proto__ || Object.getPrototypeOf(OuterQuotedString)).call(this, \"quotedstringwrapper\", 0, data));\n    }\n\n    return OuterQuotedString;\n}(BibStringItem_1.BibStringComponent);\n\nexports.OuterQuotedString = OuterQuotedString;\nfunction isOuterQuotedString(x) {\n    return x.type === \"quotedstringwrapper\";\n}\nexports.isOuterQuotedString = isOuterQuotedString;\nfunction isQuotedString(x) {\n    return x.type === \"quotedstring\";\n}\nexports.isQuotedString = isQuotedString;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar StringRef = function StringRef(braceDepth, stringref) {\n    _classCallCheck(this, StringRef);\n\n    this.braceDepth = braceDepth;\n    this.stringref = stringref;\n};\n\nexports.StringRef = StringRef;\nfunction isStringRef(stringref) {\n    return typeof stringref.stringref === \"string\";\n}\nexports.isStringRef = isStringRef;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar BibStringComponent = function BibStringComponent(type, braceDepth, data) {\n    _classCallCheck(this, BibStringComponent);\n\n    this.type = type;\n    this.braceDepth = braceDepth;\n    this.data = data;\n};\n\nexports.BibStringComponent = BibStringComponent;\nfunction isBibStringComponent(x) {\n    return typeof x.braceDepth === \"number\" && typeof x.type === \"string\";\n}\nexports.isBibStringComponent = isBibStringComponent;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(0);\n\nvar BibComment = function () {\n    function BibComment(data) {\n        _classCallCheck(this, BibComment);\n\n        this.type = \"comment\";\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    _createClass(BibComment, [{\n        key: \"toString\",\n        value: function toString() {\n            return this.string;\n        }\n    }]);\n\n    return BibComment;\n}();\n\nexports.BibComment = BibComment;\n\nvar CommentEntry = function () {\n    function CommentEntry(type, data) {\n        _classCallCheck(this, CommentEntry);\n\n        this.type = type;\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    _createClass(CommentEntry, [{\n        key: \"toString\",\n        value: function toString() {\n            return this.string;\n        }\n    }]);\n\n    return CommentEntry;\n}();\n\nexports.CommentEntry = CommentEntry;\nfunction isBibComment(n) {\n    return n.type === \"comment\" && util_1.isArray(n.data);\n}\nexports.isBibComment = isBibComment;\nvar flattenO = function flattenO(wrapper) {\n    return util_1.isString(wrapper) ? wrapper : typeof wrapper === \"number\" ? wrapper.toString() : wrapper[\"type\"] === \"@bib\" ? \"@\" + util_1.mustBeString(wrapper.string) : wrapper[\"type\"] === \"escapedEntry\" ? \"\\\\\" + flattenO(wrapper.data) : util_1.mustBeString(wrapper.string);\n};\nfunction flattenPlainText(data) {\n    return util_1.flattenMyArray(data).map(flattenO);\n}\nexports.flattenPlainText = flattenPlainText;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar nearley = __webpack_require__(19);\nvar ts_parser_1 = __webpack_require__(18);\nvar Lexer_1 = __webpack_require__(17);\nvar util_1 = __webpack_require__(0);\nvar KeyVal_1 = __webpack_require__(10);\nvar BibEntry_1 = __webpack_require__(1);\nvar BibComment_1 = __webpack_require__(6);\nvar BibPreamble_1 = __webpack_require__(8);\nvar StringEntry_1 = __webpack_require__(9);\n\nvar BibFile = function () {\n    function BibFile(content) {\n        _classCallCheck(this, BibFile);\n\n        this.content = content;\n        this.comments = content.filter(BibComment_1.isBibComment).map(function (c) {\n            if (BibComment_1.isBibComment(c)) return c;else throw new Error();\n        });\n        this.entries = content.filter(function (c) {\n            return BibEntry_1.isBibEntry(c);\n        }).map(function (c) {\n            if (BibEntry_1.isBibEntry(c)) return c;else throw new Error();\n        });\n        var entryMap = {};\n        this.entries.forEach(function (entry) {\n            var key = entry._id.toLowerCase();\n            if (!!entryMap[key]) throw new Error(\"Entry with id \" + key + \" was defined more than once\");\n            entryMap[key] = entry;\n        });\n        this.entries$ = entryMap;\n        this.preambles = content.filter(function (c) {\n            return BibPreamble_1.isPreamble(c);\n        }).map(function (c) {\n            if (BibPreamble_1.isPreamble(c)) return c;else throw new Error();\n        });\n        this.preamble$ = this.preambles.map(function (p) {\n            return p.toString();\n        }).join(\"\\n\");\n        var strings = {};\n        this.content.forEach(function (entry) {\n            if (KeyVal_1.isKeyVal(entry)) {\n                if (!!strings[entry.key]) throw new Error(\"String with id \" + entry.key + \" was defined more than once\");\n                strings[entry.key] = entry.value;\n            }\n        });\n        this.strings = strings;\n        this.strings$ = StringEntry_1.resolveStrings(strings);\n    }\n\n    _createClass(BibFile, [{\n        key: \"getEntry\",\n        value: function getEntry(id) {\n            return this.entries$[id.toLowerCase()];\n        }\n    }]);\n\n    return BibFile;\n}();\n\nexports.BibFile = BibFile;\nfunction parseNonEntry(nonEntry) {\n    if (!util_1.isArray(nonEntry.data) || nonEntry.type !== \"NON_ENTRY\") throw new Error();\n    return new BibComment_1.BibComment(BibComment_1.flattenPlainText(nonEntry.data));\n}\nfunction parseEntry(entry) {\n    switch (typeof entry === \"undefined\" ? \"undefined\" : _typeof(entry)) {\n        case \"object\":\n            var data = entry.data;\n            if (typeof data[\"@type\"] === \"string\") {\n                return new BibEntry_1.BibEntry(data[\"@type\"], data._id, BibEntry_1.parseEntryFields(data.fields));\n            }\n            var type = util_1.mustBeString(data.type);\n            switch (type) {\n                case \"string\":\n                    return StringEntry_1.newStringNode(data);\n                case \"preamble\":\n                    return BibPreamble_1.newPreambleNode(data);\n                default:\n                    throw new Error(\"Unexpected entry parsed: \" + data.type);\n            }\n        default:\n            throw new Error(\"Expected object as data for entry\");\n    }\n}\nexports.parseBibEntriesAndNonEntries = function (parse) {\n    return parse.map(function (entity) {\n        switch (entity.type) {\n            case \"NON_ENTRY\":\n                return parseNonEntry(entity);\n            case \"ENTRY\":\n                return parseEntry(entity);\n            default:\n                throw new Error(\"Expected ENTRY or NON_ENTRY\");\n        }\n    });\n};\nfunction parseBibFile(input) {\n    var p = new nearley.Parser(ts_parser_1.grammar.ParserRules, ts_parser_1.grammar.ParserStart);\n    p.feed(new Lexer_1.default(input).readTokens());\n    var res = p.results;\n    var parse = res[0];\n    return new BibFile(exports.parseBibEntriesAndNonEntries(parse));\n}\nexports.parseBibFile = parseBibFile;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(0);\nvar BibFile_1 = __webpack_require__(7);\n\nvar Preamble = function () {\n    function Preamble(data) {\n        _classCallCheck(this, Preamble);\n\n        this.type = \"preamble\";\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    _createClass(Preamble, [{\n        key: \"toString\",\n        value: function toString() {\n            return this.string;\n        }\n    }]);\n\n    return Preamble;\n}();\n\nexports.Preamble = Preamble;\nfunction isPreamble(x) {\n    return x.type === \"preamble\" && !!x.data;\n}\nexports.isPreamble = isPreamble;\nfunction newPreambleNode(data) {\n    var flattened = BibFile_1.parseBibEntriesAndNonEntries(util_1.mustBeArray(data.data));\n    return new Preamble(flattened);\n}\nexports.newPreambleNode = newPreambleNode;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar KeyVal_1 = __webpack_require__(10);\nvar BibStringItem_1 = __webpack_require__(5);\nvar StringRef_1 = __webpack_require__(4);\nvar QuotedString_1 = __webpack_require__(3);\nvar BracedString_1 = __webpack_require__(2);\nvar util_1 = __webpack_require__(0);\n\nvar StringEntry = function StringEntry(key, value) {\n    _classCallCheck(this, StringEntry);\n\n    this.type = \"string\";\n    this.key = key;\n    this.value = value;\n};\n\nexports.StringEntry = StringEntry;\nfunction findKeyVal(data) {\n    if (KeyVal_1.isKeyVal(data)) {\n        return KeyVal_1.newKeyVal(data);\n    } else {\n        if (data.type !== \"string\") {\n            throw new Error(\"Unexpected node: \" + JSON.stringify(data));\n        }\n        return findKeyVal(data.data);\n    }\n}\nfunction resolveStrings(strings) {\n    var resolved = {};\n    Object.keys(strings).forEach(function (key) {\n        if (!resolved[key]) resolved[key] = resolveStringReference({}, resolved, strings, strings[key]);\n    });\n    return resolved;\n}\nexports.resolveStrings = resolveStrings;\nfunction newStringNode(data) {\n    var _findKeyVal = findKeyVal(data),\n        key = _findKeyVal.key,\n        value = _findKeyVal.value;\n\n    return new StringEntry(key, value);\n}\nexports.newStringNode = newStringNode;\nfunction resolveStringReferences(o, seenBeforeStack, alreadyResolved, refs) {\n    return o.data.map(function (datum) {\n        if (util_1.isString(datum) || util_1.isNumber(datum)) return datum;else if (StringRef_1.isStringRef(datum)) return resolveStringRef(seenBeforeStack, refs, datum, alreadyResolved);else if (BibStringItem_1.isBibStringComponent(datum)) return copyWithResolvedStringReferences(datum, seenBeforeStack, alreadyResolved, refs);else throw new Error();\n    });\n}\nexports.resolveStringReferences = resolveStringReferences;\nfunction resolveStringReference(seenBeforeStack, alreadyResolved, refs, data) {\n    if (util_1.isNumber(data)) {\n        return data;\n    } else if (BracedString_1.isOuterBracedString(data) || QuotedString_1.isOuterQuotedString(data)) {\n        return copyOuterWithResolvedStringReferences(data, seenBeforeStack, alreadyResolved, refs);\n    }\n    if (StringRef_1.isStringRef(data)) {\n        return resolveStringRef(seenBeforeStack, refs, data, alreadyResolved);\n    }\n    return data;\n}\nexports.resolveStringReference = resolveStringReference;\nfunction copyWithResolvedStringReferences(obj, seenBeforeStack, alreadyResolved, refs) {\n    var newData = resolveStringReferences(obj, seenBeforeStack, alreadyResolved, refs);\n    var braceDepth = obj.braceDepth;\n    if (QuotedString_1.isQuotedString(obj)) return new QuotedString_1.QuotedString(braceDepth, newData);\n    if (BracedString_1.isBracedString(obj)) return new BracedString_1.BracedString(braceDepth, newData);\n    if (QuotedString_1.isOuterQuotedString(obj)) return new QuotedString_1.OuterQuotedString(newData);\n    if (BracedString_1.isOuterBracedString(obj)) return new BracedString_1.OuterBracedString(newData);else throw new Error();\n}\nexports.copyWithResolvedStringReferences = copyWithResolvedStringReferences;\nfunction copyOuterWithResolvedStringReferences(obj, seenBeforeStack, alreadyResolved, refs) {\n    var copied = copyWithResolvedStringReferences(obj, seenBeforeStack, alreadyResolved, refs);\n    if (!BracedString_1.isOuterBracedString(copied) && !QuotedString_1.isOuterQuotedString(copied)) throw new Error();\n    return copied;\n}\nexports.copyOuterWithResolvedStringReferences = copyOuterWithResolvedStringReferences;\nfunction resolveStringRef(seenBeforeStack, refs, data, alreadyResolved) {\n    var refName = data.stringref;\n    if (seenBeforeStack[refName]) throw new Error(\"Cycle detected: \" + refName);\n    if (alreadyResolved[refName]) {\n        return alreadyResolved[refName];\n    }\n    if (!refs[refName]) throw new Error(\"Unresolved reference: \" + JSON.stringify(data));\n    alreadyResolved[refName] = resolveStringReference(Object.assign({}, seenBeforeStack, _defineProperty({}, refName, true)), alreadyResolved, refs, refs[refName]);\n    return alreadyResolved[refName];\n}\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BibEntry_1 = __webpack_require__(1);\nfunction isKeyVal(data) {\n    return typeof data.key === \"string\" && data.value !== undefined;\n}\nexports.isKeyVal = isKeyVal;\nfunction newKeyVal(data) {\n    if (isKeyVal(data)) {\n        return {\n            key: data.key,\n            value: BibEntry_1.parseFieldValue(data.value)\n        };\n    } else {\n        throw new Error(\"Was not a KeyVal: \" + JSON.stringify(data));\n    }\n}\nexports.newKeyVal = newKeyVal;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction newNumber(string) {\n    return {\n        type: \"number\",\n        string: string\n    };\n}\nexports.newNumber = newNumber;\nexports.numericChars = {\n    \"0\": true,\n    \"1\": true,\n    \"2\": true,\n    \"3\": true,\n    \"4\": true,\n    \"5\": true,\n    \"6\": true,\n    \"7\": true,\n    \"8\": true,\n    \"9\": true\n};\nfunction isNum(c) {\n    return exports.numericChars.hasOwnProperty(c);\n}\nexports.isNum = isNum;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction newToken(type, string) {\n    return {\n        type: type,\n        string: string\n    };\n}\nexports.newToken = newToken;\nexports.specialChars = {\n    \"@\": true,\n    \"(\": true,\n    \")\": true,\n    \"{\": true,\n    \"}\": true,\n    \"#\": true,\n    \"=\": true,\n    \",\": true,\n    \"\\\\\": true,\n    \"\\\"\": true\n};\nfunction isSpecialChar(c) {\n    return exports.specialChars.hasOwnProperty(c);\n}\nexports.isSpecialChar = isSpecialChar;\nexports.escapableChars = {\n    \"\\\\\": true,\n    \"@\": true,\n    \"{\": true,\n    \"}\": true\n};\nfunction isEscapableChar(c) {\n    return exports.escapableChars.hasOwnProperty(c);\n}\nexports.isEscapableChar = isEscapableChar;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WS = \"ws\";\nfunction newWhitespace(string) {\n    return {\n        type: \"ws\",\n        string: string\n    };\n}\nexports.newWhitespace = newWhitespace;\nfunction isWhitespace(token) {\n    return typeof token.string === \"string\" && token.type === exports.WS;\n}\nexports.isWhitespace = isWhitespace;\nexports.singleWhitespaces = {\n    \" \": true,\n    \"\\t\": true,\n    \"\\r\": true,\n    \"\\n\": true\n};\nfunction isSingleWhiteSpaceCharacter(c) {\n    return exports.singleWhitespaces.hasOwnProperty(c);\n}\nexports.isSingleWhiteSpaceCharacter = isSingleWhiteSpaceCharacter;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction __export(m) {\n    for (var p in m) {\n        if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(7));\n__export(__webpack_require__(1));\n__export(__webpack_require__(6));\n__export(__webpack_require__(8));\n__export(__webpack_require__(3));\n__export(__webpack_require__(2));\n__export(__webpack_require__(9));\n__export(__webpack_require__(4));\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bibTypes = {\n    string: \"@string\",\n    preamble: \"@preamble\",\n    comment: \"@comment\",\n    bib: \"@bib\"\n};\nexports.isBibType = function (c) {\n    return exports.bibTypes.hasOwnProperty(c);\n};\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Token_1 = __webpack_require__(12);\nvar WhitespaceToken_1 = __webpack_require__(13);\nvar NumericToken_1 = __webpack_require__(11);\nfunction newIdToken(string) {\n    return {\n        type: \"id\",\n        string: string\n    };\n}\nexports.newIdToken = newIdToken;\nfunction isIdToken(string) {\n    return string.type === \"id\" && typeof string.string === \"string\";\n}\nexports.isIdToken = isIdToken;\nfunction isIdChar(c) {\n    return !(Token_1.isSpecialChar(c) || NumericToken_1.isNum(c) || WhitespaceToken_1.isSingleWhiteSpaceCharacter(c));\n}\nexports.isIdChar = isIdChar;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Token_1 = __webpack_require__(12);\nvar WhitespaceToken_1 = __webpack_require__(13);\nvar NumericToken_1 = __webpack_require__(11);\nvar IdToken_1 = __webpack_require__(16);\nvar BibBlockTypes_1 = __webpack_require__(15);\n\nvar Lexer = function () {\n    function Lexer(string) {\n        _classCallCheck(this, Lexer);\n\n        this.str = string;\n        this.len = string.length;\n        this.pos = 0;\n    }\n\n    _createClass(Lexer, [{\n        key: \"getStringUntilNonEscapedChar\",\n        value: function getStringUntilNonEscapedChar(terminalRegex) {\n            var chars = [];\n            for (var i = this.pos; i < this.len + 1; i++) {\n                this.pos = i;\n                if (this.str.charAt(i) == \"\\\\\" && this.str.charAt(i + 1).match(terminalRegex)) {\n                    i++;\n                    this.pos = i;\n                } else if (this.str.charAt(i).match(terminalRegex)) {\n                    break;\n                }\n                chars.push(this.str.charAt(i));\n            }\n            return chars.join(\"\");\n        }\n    }, {\n        key: \"readTokens\",\n        value: function readTokens() {\n            var tokens = [];\n            var nextToken = void 0;\n            while (nextToken = this.readNextToken()) {\n                tokens.push(nextToken);\n            }return tokens;\n        }\n    }, {\n        key: \"readNextToken\",\n        value: function readNextToken() {\n            if (this.pos >= this.str.length) return undefined;\n            var currentChar = this.str.charAt(this.pos);\n            if (WhitespaceToken_1.isSingleWhiteSpaceCharacter(currentChar)) return this.eatWhiteSpace();else if (Token_1.isSpecialChar(currentChar)) {\n                return this.eatSpecialChars(currentChar);\n            } else if (NumericToken_1.isNum(currentChar)) {\n                return this.eatNumericString(currentChar);\n            } else {\n                return this.eatIdString();\n            }\n        }\n    }, {\n        key: \"eatIdString\",\n        value: function eatIdString() {\n            var chars = [];\n            var pos2 = this.pos;\n            for (var i = pos2; i < this.len + 1; i++) {\n                this.pos = i;\n                var charAtI = this.str.charAt(i);\n                if (!IdToken_1.isIdChar(charAtI)) {\n                    break;\n                } else {\n                    chars.push(charAtI);\n                }\n            }\n            return IdToken_1.newIdToken(chars.join(\"\").trim());\n        }\n    }, {\n        key: \"eatNumericString\",\n        value: function eatNumericString(startAt) {\n            var nums = [startAt];\n            var nextPos = this.pos + 1;\n            for (var newPos = nextPos; newPos < this.len + 1; newPos++) {\n                this.pos = newPos;\n                var newChar = this.str.charAt(newPos);\n                if (NumericToken_1.isNum(newChar)) nums.push(newChar);else break;\n            }\n            var numericString = nums.join(\"\");\n            if (nums[0] === \"0\") return NumericToken_1.newNumber(numericString);else {\n                var number = Number.parseInt(numericString);\n                return Number.isFinite(number) ? number : NumericToken_1.newNumber(numericString);\n            }\n        }\n    }, {\n        key: \"eatSpecialChars\",\n        value: function eatSpecialChars(startAt) {\n            this.pos++;\n            if (startAt === \"@\") {\n                var type = this.getStringUntilNonEscapedChar(\"{\").trim().toLowerCase();\n                if (BibBlockTypes_1.isBibType(type)) return Token_1.newToken(BibBlockTypes_1.bibTypes[type], type);else return Token_1.newToken(\"@bib\", type);\n            }\n            return startAt;\n        }\n    }, {\n        key: \"eatWhiteSpace\",\n        value: function eatWhiteSpace() {\n            var chars = [];\n            while (this.pos < this.len + 1) {\n                var c = this.str.charAt(this.pos);\n                if (WhitespaceToken_1.isSingleWhiteSpaceCharacter(c)) {\n                    chars.push(c);\n                    this.pos++;\n                } else break;\n            }\n            return WhitespaceToken_1.newWhitespace(chars.join(\"\"));\n        }\n    }]);\n\n    return Lexer;\n}();\n\nexports.default = Lexer;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction id(x) {\n    return x[0];\n}\nvar isNumber = function isNumber(x) {\n    return x.constructor === Number || (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"number\";\n};\nvar tok_id = {\n    test: function test(x) {\n        return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"id\";\n    }\n};\nvar entry_type_bib = {\n    test: function test(x) {\n        return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"@bib\";\n    }\n};\nvar entry_type_string = {\n    test: function test(x) {\n        return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"@string\";\n    }\n};\nvar entry_type_preamble = {\n    test: function test(x) {\n        return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"@preamble\";\n    }\n};\nvar entry_type_comment = {\n    test: function test(x) {\n        return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"@comment\";\n    }\n};\nvar ws = {\n    test: function test(x) {\n        return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.type === \"ws\";\n    }\n};\nvar num = { test: isNumber };\nvar pound = { literal: \"#\" };\nvar eq = { literal: \"=\" };\nvar esc = { literal: \"\\\\\" };\nvar paren_l = { literal: \"(\" };\nvar paren_r = { literal: \")\" };\nvar brace_l = { literal: \"{\" };\nvar brace_r = { literal: \"}\" };\nvar quote_dbl = { literal: \"\\\"\" };\nvar comma = { literal: \",\" };\nfunction addToObj(obj, keyval) {\n    if (keyval.type !== \"keyval\") throw new Error(\"Expected a keyval object\");\n    var key = keyval.key.toLowerCase();\n    if (obj.fields[key]) {\n        console.log(\"WARNING: field '\" + key + \"' was already defined on \" + obj[\"@type\"] + \" object with id '\" + obj._id + \"'. Ignoring this value.\");\n        return;\n    } else {\n        obj.fields[key] = keyval.value;\n        return obj;\n    }\n}\nfunction joinTokens(arr) {\n    var strs = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (_typeof(arr[i]) === \"object\") {\n            if (!arr[i].string) throw new Error(\"Expected token to have a string field called 'string' in object \" + JSON.stringify(arr[i]));\n            strs.push(arr[i].string);\n        } else if (typeof arr[i] === \"string\" || typeof arr[i] === \"number\") {\n            strs.push(arr[i]);\n        } else throw new Error(\"Could not handle token \" + JSON.stringify(arr[i]) + \" in array \" + JSON.stringify(arr));\n    }\n    return strs.join(\"\");\n}\nexports.grammar = {\n    Lexer: undefined,\n    ParserRules: [{ \"name\": \"main$ebnf$1\", \"symbols\": [\"non_entry\"], \"postprocess\": id }, {\n        \"name\": \"main$ebnf$1\", \"symbols\": [], \"postprocess\": function postprocess() {\n            return undefined;\n        }\n    }, { \"name\": \"main$ebnf$2\", \"symbols\": [] }, { \"name\": \"main$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [\"non_entry\"], \"postprocess\": id }, {\n        \"name\": \"main$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function postprocess() {\n            return undefined;\n        }\n    }, { \"name\": \"main$ebnf$2$subexpression$1\", \"symbols\": [\"entry\", \"main$ebnf$2$subexpression$1$ebnf$1\"] }, {\n        \"name\": \"main$ebnf$2\",\n        \"symbols\": [\"main$ebnf$2\", \"main$ebnf$2$subexpression$1\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"main\",\n        \"symbols\": [\"main$ebnf$1\", \"main$ebnf$2\"],\n        \"postprocess\": function postprocess(data) {\n            var topLevelObjects = [];\n            if (data[0]) topLevelObjects.push({ type: \"NON_ENTRY\", data: data[0] });\n            for (var i = 0; i < data[1].length; i++) {\n                topLevelObjects.push({ type: \"ENTRY\", data: data[1][i][0] });\n                if (data[1][i][1]) topLevelObjects.push({ type: \"NON_ENTRY\", data: data[1][i][1] });\n            }\n            return topLevelObjects;\n        }\n    }, { \"name\": \"_$ebnf$1\", \"symbols\": [] }, {\n        \"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", ws], \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, { \"name\": \"_\", \"symbols\": [\"_$ebnf$1\"] }, { \"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_bib] }, { \"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_string] }, { \"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_preamble] }, { \"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_comment] }, {\n        \"name\": \"entry_decl\",\n        \"symbols\": [\"entry_decl$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0];\n        }\n    }, { \"name\": \"entry$subexpression$1\", \"symbols\": [\"bib_entry\"] }, { \"name\": \"entry$subexpression$1\", \"symbols\": [\"string_entry\"] }, { \"name\": \"entry$subexpression$1\", \"symbols\": [\"preamble_entry\"] }, { \"name\": \"entry$subexpression$1\", \"symbols\": [\"comment_entry\"] }, {\n        \"name\": \"entry\", \"symbols\": [\"entry$subexpression$1\"], \"postprocess\": function postprocess(data) {\n            return data[0][0];\n        }\n    }, {\n        \"name\": \"comment\", \"symbols\": [\"main\"], \"postprocess\": function postprocess(data) {\n            return data[0];\n        }\n    }, { \"name\": \"comment_liberal$ebnf$1\", \"symbols\": [] }, { \"name\": \"comment_liberal$ebnf$1$subexpression$1\", \"symbols\": [/./] }, {\n        \"name\": \"comment_liberal$ebnf$1\",\n        \"symbols\": [\"comment_liberal$ebnf$1\", \"comment_liberal$ebnf$1$subexpression$1\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"comment_liberal\",\n        \"symbols\": [\"comment_liberal$ebnf$1\"],\n        \"postprocess\": function postprocess(data) {\n            var toeknz = [];\n            for (var tk = 0; tk < data[0].length; tk++) {\n                toeknz.push(data[0][tk][0]);\n            }return toeknz;\n        }\n    }, { \"name\": \"entry_body_comment$subexpression$1$macrocall$2\", \"symbols\": [\"comment\"] }, {\n        \"name\": \"entry_body_comment$subexpression$1$macrocall$1\",\n        \"symbols\": [paren_l, \"entry_body_comment$subexpression$1$macrocall$2\", paren_r],\n        \"postprocess\": function postprocess(data) {\n            return data[1];\n        }\n    }, { \"name\": \"entry_body_comment$subexpression$1\", \"symbols\": [\"entry_body_comment$subexpression$1$macrocall$1\"] }, { \"name\": \"entry_body_comment$subexpression$1$macrocall$4\", \"symbols\": [\"comment\"] }, {\n        \"name\": \"entry_body_comment$subexpression$1$macrocall$3\",\n        \"symbols\": [brace_l, \"entry_body_comment$subexpression$1$macrocall$4\", brace_r],\n        \"postprocess\": function postprocess(data) {\n            return data[1];\n        }\n    }, { \"name\": \"entry_body_comment$subexpression$1\", \"symbols\": [\"entry_body_comment$subexpression$1$macrocall$3\"] }, {\n        \"name\": \"entry_body_comment\",\n        \"symbols\": [\"entry_body_comment$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0][0];\n        }\n    }, { \"name\": \"entry_body_string$subexpression$1$macrocall$2\", \"symbols\": [\"keyval\"] }, {\n        \"name\": \"entry_body_string$subexpression$1$macrocall$1\",\n        \"symbols\": [paren_l, \"_\", \"entry_body_string$subexpression$1$macrocall$2\", \"_\", paren_r],\n        \"postprocess\": function postprocess(data) {\n            return data[2];\n        }\n    }, { \"name\": \"entry_body_string$subexpression$1\", \"symbols\": [\"entry_body_string$subexpression$1$macrocall$1\"] }, { \"name\": \"entry_body_string$subexpression$1$macrocall$4\", \"symbols\": [\"keyval\"] }, {\n        \"name\": \"entry_body_string$subexpression$1$macrocall$3\",\n        \"symbols\": [brace_l, \"_\", \"entry_body_string$subexpression$1$macrocall$4\", \"_\", brace_r],\n        \"postprocess\": function postprocess(data) {\n            return data[2];\n        }\n    }, { \"name\": \"entry_body_string$subexpression$1\", \"symbols\": [\"entry_body_string$subexpression$1$macrocall$3\"] }, {\n        \"name\": \"entry_body_string\",\n        \"symbols\": [\"entry_body_string$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0][0];\n        }\n    }, { \"name\": \"entry_body_bib$subexpression$1$macrocall$2\", \"symbols\": [\"bib_content\"] }, {\n        \"name\": \"entry_body_bib$subexpression$1$macrocall$1\",\n        \"symbols\": [paren_l, \"_\", \"entry_body_bib$subexpression$1$macrocall$2\", \"_\", paren_r],\n        \"postprocess\": function postprocess(data) {\n            return data[2];\n        }\n    }, { \"name\": \"entry_body_bib$subexpression$1\", \"symbols\": [\"entry_body_bib$subexpression$1$macrocall$1\"] }, { \"name\": \"entry_body_bib$subexpression$1$macrocall$4\", \"symbols\": [\"bib_content\"] }, {\n        \"name\": \"entry_body_bib$subexpression$1$macrocall$3\",\n        \"symbols\": [brace_l, \"_\", \"entry_body_bib$subexpression$1$macrocall$4\", \"_\", brace_r],\n        \"postprocess\": function postprocess(data) {\n            return data[2];\n        }\n    }, { \"name\": \"entry_body_bib$subexpression$1\", \"symbols\": [\"entry_body_bib$subexpression$1$macrocall$3\"] }, {\n        \"name\": \"entry_body_bib\",\n        \"symbols\": [\"entry_body_bib$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0][0];\n        }\n    }, { \"name\": \"bib_content$ebnf$1\", \"symbols\": [] }, { \"name\": \"bib_content$ebnf$1$subexpression$1\", \"symbols\": [\"keyval\", \"_\", comma, \"_\"] }, {\n        \"name\": \"bib_content$ebnf$1\",\n        \"symbols\": [\"bib_content$ebnf$1\", \"bib_content$ebnf$1$subexpression$1\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, { \"name\": \"bib_content$ebnf$2$subexpression$1\", \"symbols\": [\"_\", comma] }, { \"name\": \"bib_content$ebnf$2\", \"symbols\": [\"bib_content$ebnf$2$subexpression$1\"], \"postprocess\": id }, {\n        \"name\": \"bib_content$ebnf$2\", \"symbols\": [], \"postprocess\": function postprocess() {\n            return undefined;\n        }\n    }, {\n        \"name\": \"bib_content\",\n        \"symbols\": [\"key_string\", \"_\", comma, \"_\", \"bib_content$ebnf$1\", \"keyval\", \"bib_content$ebnf$2\"],\n        \"postprocess\": function postprocess(data) {\n            var obj = {\n                _id: data[0],\n                fields: []\n            };\n            var keyvals = data[4];\n            for (var kv = 0; kv < keyvals.length; kv++) {\n                obj.fields.push(keyvals[kv][0]);\n            }\n            obj.fields.push(data[5]);\n            return obj;\n        }\n    }, {\n        \"name\": \"bib_entry\",\n        \"symbols\": [entry_type_bib, \"_\", \"entry_body_bib\"],\n        \"postprocess\": function postprocess(data) {\n            var obj = {\n                _id: data[2]._id\n            };\n            obj[\"@type\"] = data[0].string;\n            obj.fields = {};\n            var keyvals = data[2].fields;\n            for (var kv = 0; kv < keyvals.length; kv++) {\n                addToObj(obj, keyvals[kv]);\n            }\n            return obj;\n        }\n    }, {\n        \"name\": \"string_entry\",\n        \"symbols\": [entry_type_string, \"_\", \"entry_body_string\"],\n        \"postprocess\": function postprocess(data) {\n            return { type: \"string\", data: data[2] };\n        }\n    }, {\n        \"name\": \"preamble_entry\",\n        \"symbols\": [entry_type_preamble, \"_\", \"entry_body_comment\"],\n        \"postprocess\": function postprocess(data) {\n            return { type: \"preamble\", data: data[2] };\n        }\n    }, {\n        \"name\": \"comment_entry\",\n        \"symbols\": [entry_type_comment, \"_\", \"entry_body_comment\"],\n        \"postprocess\": function postprocess(data) {\n            return { type: \"comment\", data: data[2] };\n        }\n    }, {\n        \"name\": \"keyval\",\n        \"symbols\": [\"key_string\", \"_\", eq, \"_\", \"value_string\"],\n        \"postprocess\": function postprocess(data) {\n            return { type: \"keyval\", key: data[0], value: data[4] };\n        }\n    }, { \"name\": \"braced_string$ebnf$1\", \"symbols\": [] }, { \"name\": \"braced_string$ebnf$1$subexpression$1\", \"symbols\": [\"non_brace\"] }, { \"name\": \"braced_string$ebnf$1$subexpression$1\", \"symbols\": [\"braced_string\"] }, {\n        \"name\": \"braced_string$ebnf$1\",\n        \"symbols\": [\"braced_string$ebnf$1\", \"braced_string$ebnf$1$subexpression$1\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"braced_string\",\n        \"symbols\": [brace_l, \"braced_string$ebnf$1\", brace_r],\n        \"postprocess\": function postprocess(data) {\n            var tkz = [];\n            for (var i in data[1]) {\n                tkz.push(data[1][i][0]);\n            }return { type: \"braced\", data: tkz };\n        }\n    }, { \"name\": \"quoted_string$ebnf$1\", \"symbols\": [] }, { \"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_quote\"] }, { \"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"non_quote_non_brace\"] }, { \"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"braced_string\"] }, {\n        \"name\": \"quoted_string$ebnf$1\",\n        \"symbols\": [\"quoted_string$ebnf$1\", \"quoted_string$ebnf$1$subexpression$1\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"quoted_string\",\n        \"symbols\": [quote_dbl, \"quoted_string$ebnf$1\", quote_dbl],\n        \"postprocess\": function postprocess(data) {\n            var tks = [];\n            for (var i in data[1]) {\n                tks.push(data[1][i][0]);\n            }return { type: \"quotedstring\", data: tks };\n        }\n    }, { \"name\": \"escaped_quote\", \"symbols\": [esc, quote_dbl] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [tok_id] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_bib] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_string] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_preamble] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_comment] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [ws] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [num] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [pound] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [eq] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [esc] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [paren_l] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [paren_r] }, { \"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [comma] }, { \"name\": \"non_quote_non_brace\", \"symbols\": [\"non_quote_non_brace$subexpression$1\"] }, { \"name\": \"key_string$ebnf$1\", \"symbols\": [\"stringreftoken\"] }, {\n        \"name\": \"key_string$ebnf$1\",\n        \"symbols\": [\"key_string$ebnf$1\", \"stringreftoken\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"key_string\", \"symbols\": [\"key_string$ebnf$1\"], \"postprocess\": function postprocess(data) {\n            return joinTokens(data[0]).toLowerCase();\n        }\n    }, { \"name\": \"value_string$subexpression$1$ebnf$1\", \"symbols\": [] }, {\n        \"name\": \"value_string$subexpression$1$ebnf$1$subexpression$1\",\n        \"symbols\": [\"_\", pound, \"_\", \"quoted_string_or_ref\"]\n    }, {\n        \"name\": \"value_string$subexpression$1$ebnf$1\",\n        \"symbols\": [\"value_string$subexpression$1$ebnf$1\", \"value_string$subexpression$1$ebnf$1$subexpression$1\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"value_string$subexpression$1\",\n        \"symbols\": [\"quoted_string_or_ref\", \"value_string$subexpression$1$ebnf$1\"]\n    }, { \"name\": \"value_string$subexpression$1\", \"symbols\": [\"braced_string\"] }, {\n        \"name\": \"value_string\",\n        \"symbols\": [\"value_string$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            var match = data[0];\n            if (match.length === 2) {\n                var tokenz = [];\n                tokenz.push(match[0]);\n                for (var i = 0; i < match[1].length; i++) {\n                    tokenz.push(match[1][i][3]);\n                }return { type: \"quotedstringwrapper\", data: tokenz };\n            } else if (match[0].type === \"braced\") return { type: \"bracedstringwrapper\", data: match[0].data };else throw new Error(\"Don't know how to handle value \" + JSON.stringify(match[0]));\n        }\n    }, { \"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [\"quoted_string\"] }, { \"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [\"string_ref\"] }, { \"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [num] }, {\n        \"name\": \"quoted_string_or_ref\",\n        \"symbols\": [\"quoted_string_or_ref$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            if (data[0][0].type === \"quotedstring\") return data[0][0];else {\n                return data[0][0];\n            }\n        }\n    }, { \"name\": \"string_ref$subexpression$1$ebnf$1\", \"symbols\": [] }, {\n        \"name\": \"string_ref$subexpression$1$ebnf$1\",\n        \"symbols\": [\"string_ref$subexpression$1$ebnf$1\", \"stringreftoken\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"string_ref$subexpression$1\",\n        \"symbols\": [\"stringreftoken_n_num\", \"string_ref$subexpression$1$ebnf$1\"]\n    }, {\n        \"name\": \"string_ref\",\n        \"symbols\": [\"string_ref$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            var str = data[0][0] + joinTokens(data[0][1]);\n            return { stringref: str };\n        }\n    }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [esc] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [paren_l] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [paren_r] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [tok_id] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [num] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_bib] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_string] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_preamble] }, { \"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_comment] }, {\n        \"name\": \"stringreftoken\",\n        \"symbols\": [\"stringreftoken$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            if (_typeof(data[0][0]) === \"object\") {\n                if (!data[0][0].string) throw new Error(\"Expected \" + data[0] + \"to have a 'string' field\");\n                return data[0][0].string;\n            } else {\n                if (!(typeof data[0][0] === \"string\" || typeof data[0][0] === \"number\")) throw new Error(\"Expected \" + data[0][0] + \" to be a string\");\n                return data[0][0];\n            }\n        }\n    }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [esc] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [paren_l] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [paren_r] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [tok_id] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_bib] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_string] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_preamble] }, { \"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_comment] }, {\n        \"name\": \"stringreftoken_n_num\",\n        \"symbols\": [\"stringreftoken_n_num$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            if (_typeof(data[0][0]) === \"object\") {\n                if (!data[0][0].string) throw new Error(\"Expected \" + data[0] + \"to have a 'string' field\");\n                return data[0][0].string;\n            } else {\n                if (!(typeof data[0][0] === \"string\" || typeof data[0][0] === \"number\")) throw new Error(\"Expected \" + data[0][0] + \" to be a string\");\n                return data[0][0];\n            }\n        }\n    }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [esc] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [paren_l] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [paren_r] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [tok_id] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [quote_dbl] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [ws] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [num] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [comma] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_bib] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_string] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_preamble] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_comment] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [pound] }, { \"name\": \"non_brace$subexpression$1\", \"symbols\": [eq] }, {\n        \"name\": \"non_brace\",\n        \"symbols\": [\"non_brace$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0];\n        }\n    }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [esc] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [tok_id] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [quote_dbl] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [ws] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [num] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [comma] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_bib] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_string] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_preamble] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_comment] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [pound] }, { \"name\": \"non_bracket$subexpression$1\", \"symbols\": [eq] }, {\n        \"name\": \"non_bracket\",\n        \"symbols\": [\"non_bracket$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0];\n        }\n    }, { \"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_entry\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_escape\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_non_esc_outside_entry\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"non_esc_outside_entry\"] }, { \"name\": \"non_entry$ebnf$1\", \"symbols\": [\"non_entry$ebnf$1$subexpression$1\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_entry\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_escape\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_non_esc_outside_entry\"] }, { \"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"non_esc_outside_entry\"] }, {\n        \"name\": \"non_entry$ebnf$1\",\n        \"symbols\": [\"non_entry$ebnf$1\", \"non_entry$ebnf$1$subexpression$2\"],\n        \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n    }, {\n        \"name\": \"non_entry\", \"symbols\": [\"non_entry$ebnf$1\"], \"postprocess\": function postprocess(data) {\n            var tokens = [];\n            for (var Ti = 0; Ti < data[0].length; Ti++) {\n                tokens.push(data[0][Ti][0]);\n            }return tokens;\n        }\n    }, {\n        \"name\": \"escaped_escape\", \"symbols\": [esc, esc], \"postprocess\": function postprocess() {\n            return \"\\\\\";\n        }\n    }, {\n        \"name\": \"escaped_entry\", \"symbols\": [esc, \"entry_decl\"], \"postprocess\": function postprocess(data) {\n            return { type: \"escapedEntry\", data: data[1] };\n        }\n    }, {\n        \"name\": \"escaped_non_esc_outside_entry\",\n        \"symbols\": [esc, \"non_esc_outside_entry\"],\n        \"postprocess\": function postprocess(data) {\n            return data;\n        }\n    }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [tok_id] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [ws] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [num] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [pound] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [eq] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [paren_l] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [paren_r] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [brace_l] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [brace_r] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [quote_dbl] }, { \"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [comma] }, {\n        \"name\": \"non_esc_outside_entry\",\n        \"symbols\": [\"non_esc_outside_entry$subexpression$1\"],\n        \"postprocess\": function postprocess(data) {\n            return data[0][0];\n        }\n    }],\n    ParserStart: \"main\"\n};\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\n(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\nfunction Rule(name, symbols, postprocess) {\n    this.id = ++Rule.highestId;\n    this.name = name;\n    this.symbols = symbols;        // a list of literal | regex class | nonterminal\n    this.postprocess = postprocess;\n    return this;\n}\nRule.highestId = 0;\n\nRule.prototype.toString = function(withCursorAt) {\n    function stringifySymbolSequence (e) {\n        return e.literal ? JSON.stringify(e.literal) :\n               e.type ? '%' + e.type : e.toString();\n    }\n    var symbolSequence = (typeof withCursorAt === \"undefined\")\n                         ? this.symbols.map(stringifySymbolSequence).join(' ')\n                         : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                             + \"  \"\n                             + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n    return this.name + \"  \" + symbolSequence;\n}\n\n\n// a State is a rule at a position from a given starting point in the input stream (reference)\nfunction State(rule, dot, reference, wantedBy) {\n    this.rule = rule;\n    this.dot = dot;\n    this.reference = reference;\n    this.data = [];\n    this.wantedBy = wantedBy;\n    this.isComplete = this.dot === rule.symbols.length;\n}\n\nState.prototype.toString = function() {\n    return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n};\n\nState.prototype.nextState = function(child) {\n    var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n    state.left = this;\n    state.right = child;\n    if (state.isComplete) {\n        state.data = state.build();\n    }\n    return state;\n};\n\nState.prototype.build = function() {\n    var children = [];\n    var node = this;\n    do {\n        children.push(node.right.data);\n        node = node.left;\n    } while (node.left);\n    children.reverse();\n    return children;\n};\n\nState.prototype.finish = function() {\n    if (this.rule.postprocess) {\n        this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n    }\n};\n\n\nfunction Column(grammar, index) {\n    this.grammar = grammar;\n    this.index = index;\n    this.states = [];\n    this.wants = {}; // states indexed by the non-terminal they expect\n    this.scannable = []; // list of states that expect a token\n    this.completed = {}; // states that are nullable\n}\n\n\nColumn.prototype.process = function(nextColumn) {\n    var states = this.states;\n    var wants = this.wants;\n    var completed = this.completed;\n\n    for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n        var state = states[w];\n\n        if (state.isComplete) {\n            state.finish();\n            if (state.data !== Parser.fail) {\n                // complete\n                var wantedBy = state.wantedBy;\n                for (var i = wantedBy.length; i--; ) { // this line is hot\n                    var left = wantedBy[i];\n                    this.complete(left, state);\n                }\n\n                // special-case nullables\n                if (state.reference === this.index) {\n                    // make sure future predictors of this rule get completed.\n                    var exp = state.rule.name;\n                    (this.completed[exp] = this.completed[exp] || []).push(state);\n                }\n            }\n\n        } else {\n            // queue scannable states\n            var exp = state.rule.symbols[state.dot];\n            if (typeof exp !== 'string') {\n                this.scannable.push(state);\n                continue;\n            }\n\n            // predict\n            if (wants[exp]) {\n                wants[exp].push(state);\n\n                if (completed.hasOwnProperty(exp)) {\n                    var nulls = completed[exp];\n                    for (var i = 0; i < nulls.length; i++) {\n                        var right = nulls[i];\n                        this.complete(state, right);\n                    }\n                }\n            } else {\n                wants[exp] = [state];\n                this.predict(exp);\n            }\n        }\n    }\n}\n\nColumn.prototype.predict = function(exp) {\n    var rules = this.grammar.byName[exp] || [];\n\n    for (var i = 0; i < rules.length; i++) {\n        var r = rules[i];\n        var wantedBy = this.wants[exp];\n        var s = new State(r, 0, this.index, wantedBy);\n        this.states.push(s);\n    }\n}\n\nColumn.prototype.complete = function(left, right) {\n    var inp = right.rule.name;\n    if (left.rule.symbols[left.dot] === inp) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n}\n\n\nfunction Grammar(rules, start) {\n    this.rules = rules;\n    this.start = start || this.rules[0].name;\n    var byName = this.byName = {};\n    this.rules.forEach(function(rule) {\n        if (!byName.hasOwnProperty(rule.name)) {\n            byName[rule.name] = [];\n        }\n        byName[rule.name].push(rule);\n    });\n}\n\n// So we can allow passing (rules, start) directly to Parser for backwards compatibility\nGrammar.fromCompiled = function(rules, start) {\n    var lexer = rules.Lexer;\n    if (rules.ParserStart) {\n      start = rules.ParserStart;\n      rules = rules.ParserRules;\n    }\n    var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n    var g = new Grammar(rules, start);\n    g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n    return g;\n}\n\n\nfunction StreamLexer() {\n  this.reset(\"\");\n}\n\nStreamLexer.prototype.reset = function(data, state) {\n    this.buffer = data;\n    this.index = 0;\n    this.line = state ? state.line : 1;\n    this.lastLineBreak = state ? -state.col : 0;\n}\n\nStreamLexer.prototype.next = function() {\n    if (this.index < this.buffer.length) {\n        var ch = this.buffer[this.index++];\n        if (ch === '\\n') {\n          this.line += 1;\n          this.lastLineBreak = this.index;\n        }\n        return {value: ch};\n    }\n}\n\nStreamLexer.prototype.save = function() {\n  return {\n    line: this.line,\n    col: this.index - this.lastLineBreak,\n  }\n}\n\nStreamLexer.prototype.formatError = function(token, message) {\n    // nb. this gets called after consuming the offending token,\n    // so the culprit is index-1\n    var buffer = this.buffer;\n    if (typeof buffer === 'string') {\n        var nextLineBreak = buffer.indexOf('\\n', this.index);\n        if (nextLineBreak === -1) nextLineBreak = buffer.length;\n        var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n        var col = this.index - this.lastLineBreak;\n        message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n        message += \"  \" + line + \"\\n\"\n        message += \"  \" + Array(col).join(\" \") + \"^\"\n        return message;\n    } else {\n        return message + \" at index \" + (this.index - 1);\n    }\n}\n\n\nfunction Parser(rules, start, options) {\n    if (rules instanceof Grammar) {\n        var grammar = rules;\n        var options = start;\n    } else {\n        var grammar = Grammar.fromCompiled(rules, start);\n    }\n    this.grammar = grammar;\n\n    // Read options\n    this.options = {\n        keepHistory: false,\n        lexer: grammar.lexer || new StreamLexer,\n    };\n    for (var key in (options || {})) {\n        this.options[key] = options[key];\n    }\n\n    // Setup lexer\n    this.lexer = this.options.lexer;\n    this.lexerState = undefined;\n\n    // Setup a table\n    var column = new Column(grammar, 0);\n    var table = this.table = [column];\n\n    // I could be expecting anything.\n    column.wants[grammar.start] = [];\n    column.predict(grammar.start);\n    // TODO what if start rule is nullable?\n    column.process();\n    this.current = 0; // token index\n}\n\n// create a reserved token for indicating a parse fail\nParser.fail = {};\n\nParser.prototype.feed = function(chunk) {\n    var lexer = this.lexer;\n    lexer.reset(chunk, this.lexerState);\n\n    while (token = lexer.next()) {\n        // We add new states to table[current+1]\n        var column = this.table[this.current];\n\n        // GC unused states\n        if (!this.options.keepHistory) {\n            delete this.table[this.current - 1];\n        }\n\n        var n = this.current + 1;\n        var nextColumn = new Column(this.grammar, n);\n        this.table.push(nextColumn);\n\n        // Advance all tokens that expect the symbol\n        var literal = token.value;\n        var value = lexer.constructor === StreamLexer ? token.value : token;\n        var scannable = column.scannable;\n        for (var w = scannable.length; w--; ) {\n            var state = scannable[w];\n            var expect = state.rule.symbols[state.dot];\n            // Try to consume the token\n            // either regex or literal\n            if (expect.test ? expect.test(value) :\n                expect.type ? expect.type === token.type\n                            : expect.literal === literal) {\n                // Add it\n                var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                nextColumn.states.push(next);\n            }\n        }\n\n        // Next, for each of the rules, we either\n        // (a) complete it, and try to see if the reference row expected that\n        //     rule\n        // (b) predict the next nonterminal it expects by adding that\n        //     nonterminal's start state\n        // To prevent duplication, we also keep track of rules we have already\n        // added\n\n        nextColumn.process();\n\n        // If needed, throw an error:\n        if (nextColumn.states.length === 0) {\n            // No states at all! This is not good.\n            var message = this.lexer.formatError(token, \"invalid syntax\") + \"\\n\";\n            message += \"Unexpected \" + (token.type ? token.type + \" token: \" : \"\");\n            message += JSON.stringify(token.value !== undefined ? token.value : token) + \"\\n\";\n            var err = new Error(message);\n            err.offset = this.current;\n            err.token = token;\n            throw err;\n        }\n\n        // maybe save lexer state\n        if (this.options.keepHistory) {\n          column.lexerState = lexer.save()\n        }\n\n        this.current++;\n    }\n    if (column) {\n      this.lexerState = lexer.save()\n    }\n\n    // Incrementally keep track of results\n    this.results = this.finish();\n\n    // Allow chaining, for whatever it's worth\n    return this;\n};\n\nParser.prototype.save = function() {\n    var column = this.table[this.current];\n    column.lexerState = this.lexerState;\n    return column;\n};\n\nParser.prototype.restore = function(column) {\n    var index = column.index;\n    this.current = index;\n    this.table[index] = column;\n    this.table.splice(index + 1);\n    this.lexerState = column.lexerState;\n\n    // Incrementally keep track of results\n    this.results = this.finish();\n};\n\n// nb. deprecated: use save/restore instead!\nParser.prototype.rewind = function(index) {\n    if (!this.options.keepHistory) {\n        throw new Error('set option `keepHistory` to enable rewinding')\n    }\n    // nb. recall column (table) indicies fall between token indicies.\n    //        col 0   --   token 0   --   col 1\n    this.restore(this.table[index]);\n};\n\nParser.prototype.finish = function() {\n    // Return the possible parsings\n    var considerations = [];\n    var start = this.grammar.start;\n    var column = this.table[this.table.length - 1]\n    column.states.forEach(function (t) {\n        if (t.rule.name === start\n                && t.dot === t.rule.symbols.length\n                && t.reference === 0\n                && t.data !== Parser.fail) {\n            considerations.push(t);\n        }\n    });\n    return considerations.map(function(c) {return c.data; });\n};\n\nreturn {\n    Parser: Parser,\n    Grammar: Grammar,\n    Rule: Rule,\n};\n\n}));\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 14);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 64e00cd164dba9bfe415","export function isString(data: any): data is string {\r\n    return typeof data === \"string\";\r\n}\r\n\r\nexport function isNumber(data: any): data is number {\r\n    return typeof data === \"number\";\r\n}\r\n\r\nexport function mustBeString(str: any, o?: any): string {\r\n    if (typeof str !== \"string\")\r\n        throw new Error(\"Expected to be string: \" + JSON.stringify(o ? o : str));\r\n    return str;\r\n}\r\n\r\nexport function mustBeDefined<T>(t?: T, o?: any): T {\r\n    if (t === undefined)\r\n        throw new Error(\"Expected to be defined: \" + JSON.stringify(o ? o : t));\r\n    return t;\r\n}\r\nexport function mustBeArray(str: any, o?: any): any[] {\r\n    if (!isArray(str))\r\n        throw new Error(\"Expected to be array: \" + JSON.stringify(o ? o : str));\r\n    return str;\r\n}\r\n\r\nexport function isArray(data: any): data is any[] {\r\n    return !!data && data.constructor === Array;\r\n}\r\n\r\nexport const flattenMyArray = function (arr: any[], result?: any[]): any[] {\r\n    if (!result) result = [];\r\n    for (let i = 0, length = arr.length; i < length; i++) {\r\n        const value: any = arr[i];\r\n        if (Array.isArray(value)) {\r\n            for (let i = 0, length = value.length; i < length; i++) {\r\n                const value2: any = value[i];\r\n                if (Array.isArray(value2)) {\r\n                    flattenMyArray(value2, result);\r\n                } else {\r\n                    result.push(value2);\r\n                }\r\n            }\r\n        } else {\r\n            result.push(value);\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/util.ts","import {OuterQuotedString, QuotedString} from \"./string/QuotedString\";\nimport {BracedString, OuterBracedString} from \"./string/BracedString\";\nimport {flattenMyArray, isArray, isNumber, isString, mustBeArray, mustBeString} from \"../util\";\nimport {BibStringComponent} from \"./string/BibStringItem\";\nimport {isStringRef, StringRef} from \"./string/StringRef\";\n\nexport class BibEntry {\n    readonly type: string;\n    readonly _id: string;\n    readonly fields: EntryFields;\n    /**\n     * When sorting, BibTEX computes a string, named\n     sort.key$, for each entry. The sort.key$ string is an (often long) string defining the order\n     in which entries will be sorted. To avoid any ambiguity, sort.key$ should only contain alphanumeric\n     characters. Classical non-alphanumeric characters23, except special characters, will\n     be removed by a BibTEX function named purify$. For special characters, purify$ removes\n     spaces and LATEX commands (strings beginning with a backslash), even those placed between\n     brace pairs. Everything else is left unmodified. For instance, t\\^ete, t{\\^e}te and t{\\^{e}}te\n     are transformed into tete, while tte gives tte; Bib{\\TeX} gives Bib and Bib\\TeX becomes\n     BibTeX. There are thirteen LATEX commands that wont follow the above rules: \\OE, \\ae, \\AE,\n     \\aa, \\AA, \\o, \\O, \\l, \\L, \\ss. Those commands correspond to , , , , , , , , , , , ,\n     , and purify$ transforms them (if they are in a special character, in i, j, oe, OE, ae, AE, aa,\n     AA, o, O, l, L, ss, respectively.\n     */\n    readonly sortkey$: string;\n\n    /**\n     the second transformation applied to a title is to be turned to lower case (except the first character).\n     The function named change.case$ does this job. But it only applies to letters that are\n     a brace depth 0, except within a special character. In a special character, brace depth is always\n     0, and letters are switched to lower case, except LATEX commands, that are left unmodified.\n     */\n    readonly title$: string;\n\n    constructor(type: string, id: string, fields: EntryFields) {\n        this.type = type;\n        this._id = id;\n        this.fields = fields;\n        // TODO implement; see above\n        this.sortkey$ = \"\";\n        this.title$ = \"\";\n    }\n\n    getField(key: string): FieldValue | undefined {\n        return this.fields[key.toLowerCase()];\n    }\n}\n\n\nexport function parseEntryFields(fields: any): EntryFields {\n    const fieldz: EntryFields = {};\n    Object.keys(fields).forEach(key => {\n        fieldz[key] = parseFieldValue(fields[key]);\n    });\n    return fieldz;\n}\n\n\nexport function parseStringComponent(braceDepth: number, obj: any): BibStringComponent | string | number | StringRef {\n    if (isNumber(obj) || isString(obj))\n        return /*new BibStringComponent(typeof obj, braceDepth, [*/obj/*])*/;\n\n    if (isStringRef(obj))\n        return new StringRef(0, obj.stringref);\n    // if (isWhitespace(obj)) return obj;\n    // if (isIdToken(obj)) return obj.string;\n\n    switch (mustBeString(obj.type, obj)) {\n        case \"id\":\n        case \"ws\":\n        case \"number\":\n            return mustBeString(obj.string);\n        case \"bracedstring\":\n        case \"braced\":\n            if (!isArray(obj.data)) {\n                throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n            }\n            return new BracedString(braceDepth, flattenMyArray(obj.data).map(e => parseStringComponent(braceDepth + 1, e)));\n        case \"quotedstring\":\n            if (!isArray(obj.data)) {\n                throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n            }\n            const flattened = flattenMyArray(obj.data);\n            return new QuotedString(braceDepth, flattened.map(e => parseStringComponent(braceDepth, e)));\n        default:\n            throw new Error(\"Unexpected complex string type: \" + obj.type);\n    }\n}\n\n\n// export function parseComplexStringOuter(obj: any): OuterQuotedString | OuterBracedString | number {\n//     if (isString(obj)) return [obj];\n//\n//     switch (mustBeString(obj.type)) {\n//         case \"quotedstringwrapper\":\n//         case \"bracedstringwrapper\":\n//             if (!isArray(obj.data))\n//                 throw new Error(\"Expect array for data: \" + JSON.stringify(obj));\n//\n//             return obj.data.map(parseStringy);\n//         default:\n//             throw new Error(\"Unexpected complex string type: \" + obj.type);\n//     }\n// }\n\nexport function parseFieldValue(value: any): FieldValue {\n    if (isNumber(value)) {\n        return value;\n    }\n    const data = mustBeArray(value.data);\n    switch (value.type) {\n        case \"quotedstringwrapper\":\n            if (data.length === 1 && isNumber(data[0]))\n                // A single number is in a quoted string wrapper because the parser considered it part of a concatenated string\n                return data[0];\n\n            return new OuterQuotedString(data.map(e => parseStringComponent(0, e)));\n        case \"bracedstringwrapper\":\n            return new OuterBracedString(data.map(e => parseStringComponent(0, e)));\n        default:\n            throw new Error(\"Unexpected value: \" + JSON.stringify(value));\n    }\n}\n\n\n/**\n * Values (i.e. right hand sides of each assignment) can be either between curly braces or between\n * double quotes. The main difference is that you can write double quotes in the first case, and not\n * in the second case.\n *\n * For numerical values, curly braces and double quotes can be omitted.\n */\nexport type FieldValue = number | OuterQuotedString | OuterBracedString;\n\n\nexport type EntryFields = { [k: string]: FieldValue };\n\nexport function isBibEntry(x: any): x is BibEntry {\n    return typeof x[\"type\"] === \"string\"\n        && typeof x[\"_id\"] === \"string\"\n        && !!x[\"fields\"];\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/BibEntry.ts","import {BibStringComponent, BibStringData} from \"./BibStringItem\";\n\nexport class BracedString extends BibStringComponent {\n    constructor(braceDepth: number, data: BibStringData) {\n        super(\"bracedstring\", braceDepth, data);\n    }\n\n}\nexport class OuterBracedString extends BibStringComponent {\n    constructor(data: BibStringData) {\n        super(\"bracedstringwrapper\", 0, data);\n    }\n}\n\nexport function isOuterBracedString(x: any): x is OuterBracedString {\n    return x.type === \"bracedstringwrapper\";\n}\n\nexport function isBracedString(x: any): x is BracedString {\n    return x.type === \"bracedstring\";\n}\n\n// TODO extends?\n// export class DefiniteBracedString extends BibStringComponent {\n//     readonly type = \"bracedstring\";\n//     readonly data: DefiniteStringy[];\n//\n//     constructor(braceDepth: number, data: DefiniteStringy[]) {\n//         super(\"bracedstring\", braceDepth, data);\n//     }\n// }\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/string/BracedString.ts","import {BibStringComponent, BibStringData} from \"./BibStringItem\";\n\nexport class QuotedString extends BibStringComponent {\n    constructor(braceDepth: number, data: BibStringData) {\n        super(\"quotedstring\", braceDepth, data);\n    }\n}\n\n\nexport class OuterQuotedString extends BibStringComponent {\n    constructor(data: BibStringData) {\n        super(\"quotedstringwrapper\", 0, data);\n    }\n}\n\nexport function isOuterQuotedString(x: any): x is OuterQuotedString {\n    return x.type === \"quotedstringwrapper\";\n}\n\nexport function isQuotedString(x: any): x is OuterQuotedString {\n    return x.type === \"quotedstring\";\n}\n\n// export class DefiniteOuterQuotedString extends BibStringComponent {\n//     readonly data: DefiniteStringy[];\n//\n//     constructor(braceDepth: number, data: DefiniteStringy[]) {\n//         super(\"quotedstringwrapper\", braceDepth, data);\n//     }\n// }\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/string/QuotedString.ts","export class StringRef {\r\n    readonly stringref: string;\r\n    readonly braceDepth: number;\r\n\r\n    constructor(braceDepth: number, stringref: string) {\r\n        this.braceDepth = braceDepth;\r\n        this.stringref = stringref;\r\n    }\r\n}\r\n\r\nexport function isStringRef(stringref: any): stringref is StringRef {\r\n    return typeof stringref.stringref === \"string\";\r\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/string/StringRef.ts","import {StringRef} from \"./StringRef\";\nimport {BracedString, OuterBracedString} from \"./BracedString\";\nimport {OuterQuotedString, QuotedString} from \"./QuotedString\";\n\n\nexport type BibStringDatum = (BracedString | QuotedString | OuterQuotedString | OuterBracedString | string | number | StringRef);\nexport type BibStringData = BibStringDatum[];\n\nexport class BibStringComponent {\n    readonly data: BibStringData;\n    readonly type: string;\n\n    /**\n     * The brace depth of an item is the number of braces surrounding it (surrounding the field with braces instead of quotes does not modify the brace depth)\n     */\n    readonly braceDepth: number;\n\n    constructor(type: string, braceDepth: number, data: BibStringData) {\n        this.type = type;\n        this.braceDepth = braceDepth;\n        this.data = data;\n    }\n\n\n}\n\nexport function isBibStringComponent(x: any): x is BibStringComponent {\n    return typeof x.braceDepth === \"number\" && typeof x.type === \"string\";\n}\n\n// TODO\n// /**\n//  * A special character is a\n//  part of a field starting with a left brace being at brace depth 0 immediately followed with a backslash,\n//  and ending with the corresponding right brace. For instance, in the above example, there is no special\n//  character, since \\LaTeX is at depth 2. It should be noticed that anything in a special character is\n//  considered as being at brace depth 0, even if it is placed between another pair of braces.\n//  */\n// export class SpecialCharacter extends BibStringComponent {\n//     constructor(data: BibStringData) {\n//         super(\"specialCharacter\", 0, data);\n//     }\n//\n//     copyWithResolvedStringReferences(alreadyResolved, refs): BibStringComponent {\n//         return new SpecialCharacter(resolveStringReferences(this,(alreadyResolved, refs));\n//     }\n// }\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/string/BibStringItem.ts","import {flattenMyArray, isArray, isString, mustBeString} from \"../util\";\n\nexport class BibComment {\n    readonly type: string;\n    readonly data: string[];\n    readonly string: string;\n\n    constructor(data: string[]) {\n        this.type = \"comment\";\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    toString() {\n        return this.string;\n    }\n}\n\nexport class CommentEntry {\n    readonly type: string;\n    readonly data: string[];\n    readonly string: string;\n\n    constructor(type: string, data: string[]) {\n        this.type = type;\n        this.data = data;\n        this.string = data.join(\"\");\n    }\n\n    toString() {\n        return this.string;\n    }\n}\n\nexport function isBibComment(n: any): n is BibComment {\n    return n.type === \"comment\" && isArray(n.data);\n}\n\nconst flattenO = (wrapper: any): string => isString(wrapper) ? wrapper\n    : typeof wrapper === \"number\" ? wrapper.toString()\n        // : (isString(wrapper.type) && wrapper.type === \"@bib\" && isString(wrapper.string)) ? \"@\" + wrapper.string\n        : wrapper[\"type\"] === \"@bib\" ? \"@\" + mustBeString(wrapper.string)\n            : wrapper[\"type\"] === \"escapedEntry\" ? \"\\\\\" + flattenO(wrapper.data)\n                : mustBeString(wrapper.string)\n;\n\nexport function flattenPlainText(data: any[]): string[] {\n    return flattenMyArray(data).map(flattenO);\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/BibComment.ts","import * as nearley from \"nearley\";\n\nimport {grammar} from \"../parser/ts-parser\";\n\nimport Lexer from \"../lexer/Lexer\";\nimport {isArray, mustBeString} from \"../util\";\nimport {isKeyVal} from \"./KeyVal\";\nimport {BibEntry, FieldValue, isBibEntry, parseEntryFields} from \"./BibEntry\";\nimport {BibComment, CommentEntry, flattenPlainText, isBibComment} from \"./BibComment\";\nimport {isPreamble, Preamble, newPreambleNode} from \"./BibPreamble\";\nimport {newStringNode, resolveStrings, StringEntry} from \"./string/StringEntry\";\n\n\nexport type NonBibComment = BibEntry | CommentEntry | StringEntry | Preamble;\n\n\n/**\n * A bibfile is a sequence of entries, with comments interspersed\n */\nexport class BibFile {\n    readonly content: (NonBibComment | BibComment)[];\n    readonly comments: BibComment[];\n\n    readonly entries: BibEntry[];\n    readonly entries$: { [key: string]: BibEntry };\n\n    /**\n     * Anything declared in a @preamble command will be concatenated and put in a variable\n     named preamble$, for being used in the bibliography style and, generally, inserted at the beginning of\n     the .bbl file, just before the thebibliography environment. This is useful for defining new commands\n     used in the bibliography. Here is a small example:\n\n     \\@preamble{ \"\\makeatletter\" }\n     \\@preamble{ \"\\@ifundefined{url}{\\def\\url#1{\\texttt{#1}}}{}\" }\n     \\@preamble{ \"\\makeatother\" }\n\n     This way, you may safely use the \\url command in your entries. If it is not defined at the beginning\n     of the bibliography, the default command defined in the @preamble will be used.\n     Please note that you should never define style settings in the @preamble of a bibliography database,\n     since it would be applied to any bibliography built from this database.\n     */\n    readonly preambles: Preamble[];\n    readonly preamble$: string;\n\n    readonly strings: { [k: string]: FieldValue };\n    /**\n     * `strings`, but with all references resolved\n     */\n    readonly strings$: { [k: string]: FieldValue };\n\n\n    constructor(content: (NonBibComment | BibComment)[]) {\n        this.content = content;\n        this.comments = content.filter(isBibComment).map(c => {\n            if (isBibComment(c))return c; else throw new Error();\n        });\n\n\n        this.entries = content.filter(c => isBibEntry(c)).map(c => {\n            if (isBibEntry(c)) return c; else throw new Error();\n        });\n\n        const entryMap: { [k: string]: BibEntry } = {};\n        this.entries.forEach((entry: BibEntry) => {\n            const key = entry._id.toLowerCase();\n            /**\n             * BibTEX will complain if two entries have the same internal key, even if they arent capitalized in the same\n             * way. For instance, you cannot have two entries named Example and example.\n             * In the same way, if you cite both example and Example, BibTEX will complain. Indeed, it would\n             * have to include the same entry twice, which probably is not what you want\n             */\n            if (!!entryMap[key]) throw new Error(\"Entry with id \" + key + \" was defined more than once\");\n            entryMap[key] = entry;\n        });\n        this.entries$ = entryMap;\n\n        this.preambles = content.filter(c => isPreamble(c)).map(c => {\n            if (isPreamble(c)) return c; else throw new Error();\n        });\n        this.preamble$ = this.preambles.map(p => p.toString()).join(\"\\n\");\n\n        const strings: { [k: string]: FieldValue } = {};\n        this.content.forEach(entry => {\n                if (isKeyVal(entry)) {\n                    if (!!strings[entry.key])\n                        throw new Error(\"String with id \" + entry.key + \" was defined more than once\");\n                    strings[entry.key] = entry.value;\n                }\n            }\n        );\n        this.strings = strings;\n        this.strings$ = resolveStrings(strings);\n\n    }\n\n    getEntry(id: string): BibEntry | undefined {\n        return this.entries$[id.toLowerCase()];\n    }\n}\n\nfunction parseNonEntry(nonEntry: any): BibComment {\n    if (!isArray(nonEntry.data) || nonEntry.type !== \"NON_ENTRY\") throw new Error();\n    return new BibComment(flattenPlainText(nonEntry.data));\n}\n\n\nfunction parseEntry(entry: any): NonBibComment {\n    switch (typeof entry) {\n        case \"object\":\n            const data = entry.data;\n            if (typeof data[\"@type\"] === \"string\") {\n                return new BibEntry(data[\"@type\"], data._id, parseEntryFields(data.fields));\n            }\n\n            const type = mustBeString(data.type);\n            switch (type) {\n                case \"string\":\n                    return newStringNode(data);\n                case \"preamble\":\n                    return newPreambleNode(data);\n                // case \"bracedstringwrapper\":\n                //     return new BracedString(parseComplexStringOuter(data));\n                // case \"quotedstringwrapper\":\n                //     return new QuotedString(parseComplexStringOuter(data));\n                // case \"braced\":\n                // case \"quotedstring\":\n                default:\n                    throw new Error(\"Unexpected entry parsed: \" + data.type);\n            }\n        default:\n            throw new Error(\"Expected object as data for entry\");\n    }\n}\n\nexport const parseBibEntriesAndNonEntries = function (parse: any): (BibComment | NonBibComment)[] {\n    return parse.map((entity: any) => {\n        switch (entity.type) {\n            case \"NON_ENTRY\":\n                return (parseNonEntry(entity));\n            case \"ENTRY\":\n                return (parseEntry(entity));\n            default:\n                throw new Error(\"Expected ENTRY or NON_ENTRY\");\n        }\n    });\n};\n\nexport function parseBibFile(input: string): BibFile {\n    const p = new nearley.Parser(grammar.ParserRules, grammar.ParserStart);\n    p.feed(new Lexer(input).readTokens());\n    const res = p.results;\n    const parse = res[0];\n\n    return new BibFile(parseBibEntriesAndNonEntries(parse));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/BibFile.ts","import {isString, mustBeArray} from \"../util\";\r\nimport {parseBibEntriesAndNonEntries} from \"./BibFile\";\r\n\r\nexport class Preamble {\r\n    readonly type: string;\r\n    readonly data: any[];\r\n    readonly string: string;\r\n\r\n    // TODO\r\n    constructor(data: any[]) {\r\n        this.type = (\"preamble\");\r\n        this.data = data;\r\n        this.string = data.join(\"\");\r\n    }\r\n\r\n    toString() {\r\n        return this.string;\r\n    }\r\n}\r\n\r\nexport function isPreamble(x: any): x is Preamble {\r\n    return x.type === \"preamble\" && !!x.data;\r\n}\r\n\r\n\r\n// function parsePreambleContents(data: any) {\r\n//     if (isString(data)) return data;\r\n//     if (isString(data.type) && data.type === \"@bib\")\r\n//         return \"@\" + data.string;\r\n//     // if (isString(data.type) && data.type === \"NON_ENTRY\")\r\n//     //     return ;\r\n//     if (isString(data.string)) return data.string;\r\n//     return data;\r\n// }\r\n\r\nexport function newPreambleNode(data: any): Preamble {\r\n    const flattened = parseBibEntriesAndNonEntries(mustBeArray(data.data));\r\n    return new Preamble(flattened);\r\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/BibPreamble.ts","import {KeyVal, isKeyVal, newKeyVal} from \"../KeyVal\";\nimport {FieldValue} from \"../BibEntry\";\nimport {BibStringComponent, BibStringData, isBibStringComponent} from \"./BibStringItem\";\nimport {isStringRef, StringRef} from \"./StringRef\";\nimport {isOuterQuotedString, isQuotedString, OuterQuotedString, QuotedString} from \"./QuotedString\";\nimport {BracedString, isBracedString, isOuterBracedString, OuterBracedString} from \"./BracedString\";\nimport {isNumber, isString} from \"../../util\";\n\nexport class StringEntry {\n    readonly type: string;\n\n    readonly key: string;\n    readonly value: FieldValue;\n\n    public constructor(key: string, value: FieldValue) {\n        this.type = \"string\";\n        this.key = key;\n        this.value = value;\n    }\n}\n\nfunction findKeyVal(data: any): KeyVal {\n    if (isKeyVal(data)) {\n        return newKeyVal(data);\n    } else {\n        if (data.type !== \"string\") {\n            throw new Error(\"Unexpected node: \" + JSON.stringify(data));\n        }\n        return findKeyVal(data.data);\n    }\n}\n\n\nexport function resolveStrings(strings: { [key: string]: FieldValue }): { [key: string]: FieldValue } {\n    const resolved: { [key: string]: FieldValue } = {};\n    Object.keys(strings).forEach(key => {\n        if (!resolved[key])\n            resolved[key] = resolveStringReference({}, resolved, strings, strings[key]);\n    });\n    return resolved;\n}\n// function resolveStringDeclarations(wrapper: FieldValue,\n//                                    compiledSoFar: { [key: string]: FieldValue },\n//                                    rawStrings: { [key: string]: FieldValue }) {\n//     if (isNumber(wrapper))\n//         return wrapper;\n//\n//     return copyWithResolvedStringReferences(wrapper, compiledSoFar, rawStrings);\n//\n//     //  else\n//     //    throw new Error(\"Unexpected object to resolve: \" + JSON.stringify(wrapper));\n// }\n\n\nexport function newStringNode(data: any): StringEntry {\n    const {key, value}: KeyVal = findKeyVal(data);\n    return new StringEntry(key, value);\n}\n\n\nexport function resolveStringReferences(o: BibStringComponent, seenBeforeStack: { [key: string]: boolean },\n                                        alreadyResolved: { [key: string]: /*Resolved*/FieldValue },\n                                        refs: { [key: string]: FieldValue }): BibStringData {\n    return o.data.map(datum => {\n        if (isString(datum) || isNumber(datum)) return datum;\n        else if (isStringRef(datum)) return resolveStringRef(seenBeforeStack, refs, datum, alreadyResolved);\n        else if (isBibStringComponent(datum)) return copyWithResolvedStringReferences(datum, seenBeforeStack, alreadyResolved, refs);\n        else throw new Error();\n    });\n}\n\nexport function resolveStringReference(seenBeforeStack: { [key: string]: boolean },\n                                       alreadyResolved: { [p: string]: FieldValue },\n                                       refs: { [p: string]: FieldValue },\n                                       data: FieldValue): FieldValue {\n    if (isNumber(data)) {\n        return data;\n    } else if (isOuterBracedString(data) || isOuterQuotedString(data)) {\n        return copyOuterWithResolvedStringReferences(data, seenBeforeStack, alreadyResolved, refs);\n    }\n    if (isStringRef(data)) {\n        return resolveStringRef(seenBeforeStack, refs, data, alreadyResolved);\n    }\n\n    // else if (isBibStringComponent(data))\n    //     return data.copyWithResolvedStringReferences(alreadyResolved, refs);\n    // else throw new Error();\n    return data;\n}\n\n\nexport function copyWithResolvedStringReferences(obj: BibStringComponent,\n                                                 seenBeforeStack: { [key: string]: boolean },\n                                                 alreadyResolved: { [key: string]: /*Resolved*/FieldValue },\n                                                 refs: { [key: string]: FieldValue }): OuterQuotedString | OuterBracedString {\n    const newData = resolveStringReferences(obj, seenBeforeStack, alreadyResolved, refs);\n\n    const braceDepth: number = obj.braceDepth;\n    if (isQuotedString(obj))\n        return new QuotedString(braceDepth, newData);\n    if (isBracedString(obj))\n        return new BracedString(braceDepth, newData);\n    if (isOuterQuotedString(obj))\n        return new OuterQuotedString(newData);\n    if (isOuterBracedString(obj))\n        return new OuterBracedString(newData);\n    else\n        throw new Error();\n}\n\nexport function copyOuterWithResolvedStringReferences(obj: OuterQuotedString | OuterBracedString,\n                                                      seenBeforeStack: { [key: string]: boolean },\n                                                      alreadyResolved: { [key: string]: /*Resolved*/FieldValue },\n                                                      refs: { [key: string]: FieldValue }): OuterQuotedString | OuterBracedString {\n    const copied = copyWithResolvedStringReferences(\n        obj,\n        seenBeforeStack,\n        alreadyResolved,\n        refs\n    );\n    if (!isOuterBracedString(copied) && !isOuterQuotedString(copied)) throw new Error();\n    return copied;\n}\n\nfunction resolveStringRef(seenBeforeStack: { [key: string]: boolean },\n                          refs: { [key: string]: FieldValue },\n                          data: StringRef,\n                          alreadyResolved: { [key: string]: FieldValue }): FieldValue {\n    const refName = data.stringref;\n    if (seenBeforeStack[refName])\n        throw new Error(\"Cycle detected: \" + refName);\n    if (alreadyResolved[refName]) {\n        return alreadyResolved[refName];\n    }\n    if (!refs[refName])\n        throw new Error(\"Unresolved reference: \" + JSON.stringify(data));\n\n    alreadyResolved[refName] = resolveStringReference(\n        Object.assign({}, seenBeforeStack, {[refName]: true}),\n        alreadyResolved,\n        refs,\n        refs[refName]\n    );\n    return alreadyResolved[refName];\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/string/StringEntry.ts","\r\nimport {FieldValue, parseFieldValue} from \"./BibEntry\";\r\n\r\nexport interface KeyVal {\r\n    readonly key: string;\r\n    readonly value: FieldValue;\r\n}\r\n\r\nexport function isKeyVal(data: any): data is KeyVal {\r\n    return typeof data.key === \"string\"\r\n        && data.value !== undefined;\r\n}\r\n\r\nexport function newKeyVal(data: any): KeyVal {\r\n    if (isKeyVal(data)) {\r\n        return {\r\n            key: data.key,\r\n            value: parseFieldValue(data.value),\r\n        };\r\n    } else {\r\n        throw new Error(\"Was not a KeyVal: \" + JSON.stringify(data));\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/bibfile/KeyVal.ts","// export const NUMBER = \"number\";\r\n\r\nimport {TypedToken} from \"./Token\";\r\n\r\nexport function newNumber(string: string): NumberToken {\r\n    return {\r\n        type: \"number\",\r\n        string\r\n    };\r\n}\r\n\r\nexport interface NumberToken extends TypedToken {\r\n    type: \"number\";\r\n}\r\n\r\nexport const numericChars = {\r\n    \"0\": true,\r\n    \"1\": true,\r\n    \"2\": true,\r\n    \"3\": true,\r\n    \"4\": true,\r\n    \"5\": true,\r\n    \"6\": true,\r\n    \"7\": true,\r\n    \"8\": true,\r\n    \"9\": true\r\n};\r\n\r\nexport type NumericChar = keyof typeof numericChars;\r\n\r\nexport function isNum(c: string): c is NumericChar {\r\n    return numericChars.hasOwnProperty(c);\r\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/lexer/NumericToken.ts","export type Token = TypedToken | string | number;\n\nexport interface TypedToken {\n    type: string;\n    string?: string;\n}\n\nexport function newToken(type: string, string: string): TypedToken {\n    return {\n        type,\n        string\n    };\n}\n\n\nexport const specialChars = {\n    \"@\": true,\n    \"(\": true,\n    \")\": true,\n    \"{\": true,\n    \"}\": true,\n    \"#\": true,\n    \"=\": true,\n    \",\": true,\n    \"\\\\\": true,\n    \"\\\"\": true,\n};\n\nexport type SpecialChar = keyof typeof specialChars;\n\nexport function isSpecialChar(c: string): c is SpecialChar {\n    return specialChars.hasOwnProperty(c);\n}\n\n\nexport const escapableChars = {\n    \"\\\\\": true,\n    \"@\": true,\n    \"{\": true,\n    \"}\": true\n};\n\nexport type EscapableChar = keyof typeof escapableChars;\n\nexport function isEscapableChar(c: string): c is EscapableChar {\n    return escapableChars.hasOwnProperty(c);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/lexer/Token.ts","import {TypedToken} from \"./Token\";\r\n\r\nexport const WS = \"ws\";\r\n\r\nexport function newWhitespace(string: string): WhitespaceToken {\r\n    return {\r\n        type: \"ws\",\r\n        string\r\n    };\r\n}\r\n\r\n//noinspection JSUnusedGlobalSymbols\r\nexport function isWhitespace(token: any): token is WhitespaceToken {\r\n    return typeof token.string === \"string\" && token.type === WS;\r\n}\r\n\r\n\r\nexport interface WhitespaceToken extends TypedToken {\r\n    type: \"ws\";\r\n}\r\n\r\nexport const singleWhitespaces = {\r\n    \" \": true,\r\n    \"\\t\": true,\r\n    \"\\r\": true,\r\n    \"\\n\": true\r\n};\r\n\r\nexport type SingleWhitespace = keyof typeof singleWhitespaces;\r\n\r\nexport function isSingleWhiteSpaceCharacter(c: string): c is SingleWhitespace {\r\n    return singleWhitespaces.hasOwnProperty(c);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/lexer/WhitespaceToken.ts","export * from \"./bibfile/BibFile\";\nexport * from \"./bibfile/BibEntry\";\nexport * from \"./bibfile/BibComment\";\nexport * from \"./bibfile/BibPreamble\";\nexport * from \"./bibfile/string/QuotedString\";\nexport * from \"./bibfile/string/BracedString\";\nexport * from \"./bibfile/string/StringEntry\";\nexport * from \"./bibfile/string/StringRef\";\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/index.ts","export const bibTypes = {\r\n    string: \"@string\",\r\n    preamble: \"@preamble\",\r\n    comment: \"@comment\",\r\n    bib: \"@bib\"\r\n};\r\n\r\nexport type BibType = keyof typeof bibTypes;\r\n\r\nexport const isBibType = function (c: string): c is BibType {\r\n    return bibTypes.hasOwnProperty(c);\r\n};\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/lexer/BibBlockTypes.ts","import {TypedToken, SpecialChar, isSpecialChar} from \"./Token\";\r\n\r\nimport {SingleWhitespace, isSingleWhiteSpaceCharacter} from \"./WhitespaceToken\";\r\nimport {isNum, NumericChar} from \"./NumericToken\";\r\n\r\nexport interface IdToken extends TypedToken {\r\n    type: \"id\";\r\n    string: string;\r\n}\r\n\r\nexport function newIdToken(string: string): IdToken {\r\n    return {\r\n        type: \"id\",\r\n        string\r\n    };\r\n}\r\n\r\nexport function isIdToken(string: any): string is IdToken {\r\n    return string.type === \"id\" && typeof string.string === \"string\";\r\n}\r\n\r\nexport function isIdChar(c: string): c is IdChar {\r\n    return !(isSpecialChar(c) || isNum(c) || isSingleWhiteSpaceCharacter(c));\r\n}\r\n\r\nexport type IdChar = SpecialChar | NumericChar | SingleWhitespace;\r\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/lexer/IdToken.ts","import {TypedToken, isSpecialChar, newToken, Token} from \"./Token\";\nimport {isSingleWhiteSpaceCharacter, WhitespaceToken, SingleWhitespace, newWhitespace} from \"./WhitespaceToken\";\nimport {isNum, NumericChar, NumberToken, newNumber} from \"./NumericToken\";\nimport {IdToken, isIdChar, newIdToken} from \"./IdToken\";\nimport {isBibType, bibTypes} from \"./BibBlockTypes\";\n\nexport default class Lexer {\n    private str: string;\n    private len: number;\n    private pos: number;\n\n    constructor(string: string) {\n        this.str = string;\n        this.len = string.length;\n        this.pos = 0;\n    }\n\n    getStringUntilNonEscapedChar(terminalRegex: RegExp | string): string {\n        // if (typeof terminalRegex === 'string') {\n        // }\n        const chars: string[] = [];\n        for (let i = this.pos; i < this.len + 1; i++) {\n            this.pos = i;\n            if (this.str.charAt(i) == \"\\\\\" && this.str.charAt(i + 1).match(terminalRegex)) {\n                i++;\n                this.pos = i;\n            } else if (this.str.charAt(i).match(terminalRegex)) {\n                break;\n            }\n            chars.push(this.str.charAt(i));\n        }\n        return chars.join(\"\");\n    }\n    readTokens(): Token[] {\n        const tokens: Token[] = [];\n        let nextToken;\n        while (nextToken = this.readNextToken())\n            tokens.push(nextToken);\n        return tokens;\n    }\n\n    readNextToken(): Token | undefined {\n        if (this.pos >= this.str.length)\n            return undefined;\n\n        const currentChar: string = this.str.charAt(this.pos);\n\n        if (isSingleWhiteSpaceCharacter(currentChar))\n            return this.eatWhiteSpace();\n        else if (isSpecialChar(currentChar)) {\n            return this.eatSpecialChars(currentChar);\n        } else if (isNum(currentChar)) {\n            return this.eatNumericString(currentChar);\n        } else {\n            return this.eatIdString();\n        }\n    }\n\n    // NOTE: not needed? delete?\n    // isEscapeChar(i: number): boolean {\n    //     if (this.str.charAt(i) == '\\\\') {\n    //         // Might be an escaped character\n    //         const nextChar = this.str.charAt(i + 1);\n    //\n    //         // We've escaped a special character\n    //         return isEscapableChar(nextChar);\n    //     } else return false;\n    // }\n\n    private eatIdString(): IdToken {\n        // id\n        const chars: string[] = [];\n        const pos2 = this.pos;\n        for (let i = pos2; i < this.len + 1; i++) {\n            this.pos = i;\n            // console.log(this.pos, i);\n            // console.log(this.pos, this.str.charAt(i));\n            const charAtI = this.str.charAt(i);\n            if (!isIdChar(charAtI)) {\n                break;\n                // else if (charAtI == '\\\\' && (this.str.charAt(i + 1) == '\\\\' || isSpecialChar(this.str.charAt(i + 1)))) {\n                //  i++;\n                //  this.pos = i;\n                //  chars.push(this.str.charAt(i));\n            } else {\n                chars.push(charAtI);\n            }\n        }\n\n        return newIdToken(chars.join(\"\").trim());\n    }\n\n    private eatNumericString(startAt: NumericChar): number | NumberToken {\n        const nums: NumericChar[] = [startAt];\n\n        const nextPos = this.pos + 1;\n        for (let newPos = nextPos; newPos < this.len + 1; newPos++) {\n            this.pos = newPos;\n\n            const newChar = this.str.charAt(newPos);\n            if (isNum(newChar))\n                nums.push(newChar);\n            else\n                break;\n        }\n\n        const numericString: string = nums.join(\"\");\n\n        if (nums[0] === \"0\")  // If it starts with 0, return as a string\n            return newNumber(numericString);\n        else {\n            const number = Number.parseInt(numericString);\n            return Number.isFinite(number) ? number : newNumber(numericString);\n        }\n    }\n\n    private eatSpecialChars(startAt: string): string | TypedToken {\n        this.pos++;\n        if (startAt === \"@\") {\n            const type = this.getStringUntilNonEscapedChar(\"{\").trim().toLowerCase();\n            if (isBibType(type))\n                return newToken(bibTypes[type], type);\n            else\n                return newToken(\"@bib\", type);\n        }\n        return startAt;\n    }\n\n    private eatWhiteSpace(): WhitespaceToken {\n        const chars: SingleWhitespace[] = [];\n        while (this.pos < this.len + 1) {\n            const c = this.str.charAt(this.pos);\n            // ignore whitespaces\n            if (isSingleWhiteSpaceCharacter(c)) {\n                chars.push(c);\n                this.pos++;\n            } else break;\n        }\n        return newWhitespace(chars.join(\"\"));\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/lexer/Lexer.ts","function id(x) {\n    return x[0];\n}\n\nconst isNumber = function (x) {\n    return x.constructor === Number || (typeof x === \"object\" && x.type === \"number\");\n};\nconst tok_id = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"id\";\n    }\n};\nconst entry_type_bib = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"@bib\";\n    }\n};\nconst entry_type_string = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"@string\";\n    }\n};\nconst entry_type_preamble = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"@preamble\";\n    }\n};\nconst entry_type_comment = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"@comment\";\n    }\n};\nconst ws: any = {\n    test: function (x) {\n        return typeof x === \"object\" && x.type === \"ws\";\n    }\n};\nconst num: any = {test: isNumber};\nconst pound: any = {literal: \"#\"};\nconst eq: any = {literal: \"=\"};\nconst esc: any = {literal: \"\\\\\"};\nconst paren_l = {literal: \"(\"};\nconst paren_r = {literal: \")\"};\nconst brace_l = {literal: \"{\"};\nconst brace_r = {literal: \"}\"};\nconst quote_dbl = {literal: \"\\\"\"};\nconst comma: any = {literal: \",\"};\n\n\nfunction addToObj(obj, keyval) {\n    if (keyval.type !== \"keyval\") throw new Error(\"Expected a keyval object\");\n    const key = keyval.key.toLowerCase();\n    if (obj.fields[key]) {\n        console.log(\"WARNING: field '\" + key + \"' was already defined on \" + obj[\"@type\"] + \" object with id '\" + obj._id + \"'. Ignoring this value.\");\n        return;\n    } else {\n        obj.fields[key] = keyval.value;\n        return obj;\n    }\n}\n\nfunction joinTokens(arr) {\n    const strs: any = [];\n    for (let i = 0; i < arr.length; i++) {\n        if (typeof arr[i] === \"object\") {\n            if (!arr[i].string) throw new Error(\"Expected token to have a string field called 'string' in object \" + JSON.stringify(arr[i]));\n            strs.push(arr[i].string);\n        } else if (typeof arr[i] === \"string\" || typeof arr[i] === \"number\") {\n            strs.push(arr[i]);\n        } else throw new Error(\"Could not handle token \" + JSON.stringify(arr[i]) + \" in array \" + JSON.stringify(arr));\n    }\n    return strs.join(\"\");\n}\n\nexport const grammar: any = {\n    Lexer: undefined,\n    ParserRules: [\n        {\"name\": \"main$ebnf$1\", \"symbols\": [\"non_entry\"], \"postprocess\": id},\n        {\n            \"name\": \"main$ebnf$1\", \"symbols\": [], \"postprocess\": function () {\n            return undefined;\n        }\n        },\n        {\"name\": \"main$ebnf$2\", \"symbols\": []},\n        {\"name\": \"main$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [\"non_entry\"], \"postprocess\": id},\n        {\n            \"name\": \"main$ebnf$2$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function () {\n            return undefined;\n        }\n        },\n        {\"name\": \"main$ebnf$2$subexpression$1\", \"symbols\": [\"entry\", \"main$ebnf$2$subexpression$1$ebnf$1\"]},\n        {\n            \"name\": \"main$ebnf$2\",\n            \"symbols\": [\"main$ebnf$2\", \"main$ebnf$2$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"main\",\n            \"symbols\": [\"main$ebnf$1\", \"main$ebnf$2\"],\n            \"postprocess\": function (data) {\n                const topLevelObjects: any = [];\n                // console.log(JSON.stringify(data));\n                if (data[0])\n                    topLevelObjects.push({type: \"NON_ENTRY\", data: data[0]});\n\n                for (let i = 0; i < data[1].length; i++) {\n\n                    topLevelObjects.push({type: \"ENTRY\", data: data[1][i][0]});\n\n                    if (data[1][i][1])\n                        topLevelObjects.push({type: \"NON_ENTRY\", data: data[1][i][1]});\n                }\n                return topLevelObjects;\n            }\n        },\n        {\"name\": \"_$ebnf$1\", \"symbols\": []},\n        {\n            \"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", ws], \"postprocess\": function arrpush(d) {\n            return d[0].concat([d[1]]);\n        }\n        },\n        {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"]},\n        {\"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"entry_decl$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\n            \"name\": \"entry_decl\",\n            \"symbols\": [\"entry_decl$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0];\n            }\n        },\n        {\"name\": \"entry$subexpression$1\", \"symbols\": [\"bib_entry\"]},\n        {\"name\": \"entry$subexpression$1\", \"symbols\": [\"string_entry\"]},\n        {\"name\": \"entry$subexpression$1\", \"symbols\": [\"preamble_entry\"]},\n        {\"name\": \"entry$subexpression$1\", \"symbols\": [\"comment_entry\"]},\n        {\n            \"name\": \"entry\", \"symbols\": [\"entry$subexpression$1\"], \"postprocess\": function (data) {\n            return data[0][0];\n        }\n        },\n        {\n            \"name\": \"comment\", \"symbols\": [\"main\"], \"postprocess\": function (data) {\n            return data[0];\n        }\n        },\n        {\"name\": \"comment_liberal$ebnf$1\", \"symbols\": []},\n        {\"name\": \"comment_liberal$ebnf$1$subexpression$1\", \"symbols\": [/./]},\n        {\n            \"name\": \"comment_liberal$ebnf$1\",\n            \"symbols\": [\"comment_liberal$ebnf$1\", \"comment_liberal$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"comment_liberal\",\n            \"symbols\": [\"comment_liberal$ebnf$1\"],\n            \"postprocess\": function (data) {\n                const toeknz: any = [];\n                for (let tk = 0; tk < data[0].length; tk++)\n                    toeknz.push(data[0][tk][0]);\n                return toeknz;\n            }\n        },\n        {\"name\": \"entry_body_comment$subexpression$1$macrocall$2\", \"symbols\": [\"comment\"]},\n        {\n            \"name\": \"entry_body_comment$subexpression$1$macrocall$1\",\n            \"symbols\": [paren_l, \"entry_body_comment$subexpression$1$macrocall$2\", paren_r],\n            \"postprocess\": function (data) {\n                return data[1];\n            }\n        },\n        {\"name\": \"entry_body_comment$subexpression$1\", \"symbols\": [\"entry_body_comment$subexpression$1$macrocall$1\"]},\n        {\"name\": \"entry_body_comment$subexpression$1$macrocall$4\", \"symbols\": [\"comment\"]},\n        {\n            \"name\": \"entry_body_comment$subexpression$1$macrocall$3\",\n            \"symbols\": [brace_l, \"entry_body_comment$subexpression$1$macrocall$4\", brace_r],\n            \"postprocess\": function (data) {\n                return data[1];\n            }\n        },\n        {\"name\": \"entry_body_comment$subexpression$1\", \"symbols\": [\"entry_body_comment$subexpression$1$macrocall$3\"]},\n        {\n            \"name\": \"entry_body_comment\",\n            \"symbols\": [\"entry_body_comment$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0][0];\n            }\n        },\n        {\"name\": \"entry_body_string$subexpression$1$macrocall$2\", \"symbols\": [\"keyval\"]},\n        {\n            \"name\": \"entry_body_string$subexpression$1$macrocall$1\",\n            \"symbols\": [paren_l, \"_\", \"entry_body_string$subexpression$1$macrocall$2\", \"_\", paren_r],\n            \"postprocess\": function (data) {\n                return data[2];\n            }\n        },\n        {\"name\": \"entry_body_string$subexpression$1\", \"symbols\": [\"entry_body_string$subexpression$1$macrocall$1\"]},\n        {\"name\": \"entry_body_string$subexpression$1$macrocall$4\", \"symbols\": [\"keyval\"]},\n        {\n            \"name\": \"entry_body_string$subexpression$1$macrocall$3\",\n            \"symbols\": [brace_l, \"_\", \"entry_body_string$subexpression$1$macrocall$4\", \"_\", brace_r],\n            \"postprocess\": function (data) {\n                return data[2];\n            }\n        },\n        {\"name\": \"entry_body_string$subexpression$1\", \"symbols\": [\"entry_body_string$subexpression$1$macrocall$3\"]},\n        {\n            \"name\": \"entry_body_string\",\n            \"symbols\": [\"entry_body_string$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0][0];\n            }\n        },\n        {\"name\": \"entry_body_bib$subexpression$1$macrocall$2\", \"symbols\": [\"bib_content\"]},\n        {\n            \"name\": \"entry_body_bib$subexpression$1$macrocall$1\",\n            \"symbols\": [paren_l, \"_\", \"entry_body_bib$subexpression$1$macrocall$2\", \"_\", paren_r],\n            \"postprocess\": function (data) {\n                return data[2];\n            }\n        },\n        {\"name\": \"entry_body_bib$subexpression$1\", \"symbols\": [\"entry_body_bib$subexpression$1$macrocall$1\"]},\n        {\"name\": \"entry_body_bib$subexpression$1$macrocall$4\", \"symbols\": [\"bib_content\"]},\n        {\n            \"name\": \"entry_body_bib$subexpression$1$macrocall$3\",\n            \"symbols\": [brace_l, \"_\", \"entry_body_bib$subexpression$1$macrocall$4\", \"_\", brace_r],\n            \"postprocess\": function (data) {\n                return data[2];\n            }\n        },\n        {\"name\": \"entry_body_bib$subexpression$1\", \"symbols\": [\"entry_body_bib$subexpression$1$macrocall$3\"]},\n        {\n            \"name\": \"entry_body_bib\",\n            \"symbols\": [\"entry_body_bib$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0][0];\n            }\n        },\n        {\"name\": \"bib_content$ebnf$1\", \"symbols\": []},\n        {\"name\": \"bib_content$ebnf$1$subexpression$1\", \"symbols\": [\"keyval\", \"_\", comma, \"_\"]},\n        {\n            \"name\": \"bib_content$ebnf$1\",\n            \"symbols\": [\"bib_content$ebnf$1\", \"bib_content$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\"name\": \"bib_content$ebnf$2$subexpression$1\", \"symbols\": [\"_\", comma]},\n        {\"name\": \"bib_content$ebnf$2\", \"symbols\": [\"bib_content$ebnf$2$subexpression$1\"], \"postprocess\": id},\n        {\n            \"name\": \"bib_content$ebnf$2\", \"symbols\": [], \"postprocess\": function () {\n            return undefined;\n        }\n        },\n        {\n            \"name\": \"bib_content\",\n            \"symbols\": [\"key_string\", \"_\", comma, \"_\", \"bib_content$ebnf$1\", \"keyval\", \"bib_content$ebnf$2\"],\n            \"postprocess\": function (data) {\n                const obj: any = {\n                    _id: data[0],\n                    fields: []\n                };\n                const keyvals = data[4];\n                for (let kv = 0; kv < keyvals.length; kv++) {\n                    obj.fields.push(keyvals[kv][0]);\n                }\n                obj.fields.push(data[5]);\n                return obj;\n            }\n        },\n        {\n            \"name\": \"bib_entry\",\n            \"symbols\": [entry_type_bib, \"_\", \"entry_body_bib\"],\n            \"postprocess\": function (data) {\n                const obj: any = {\n                    _id: data[2]._id\n                };\n                obj[\"@type\"] = data[0].string;\n                obj.fields = {};\n\n                const keyvals = data[2].fields;\n                for (let kv = 0; kv < keyvals.length; kv++) {\n                    addToObj(obj, keyvals[kv]);\n                }\n                return obj;\n            }\n        },\n        {\n            \"name\": \"string_entry\",\n            \"symbols\": [entry_type_string, \"_\", \"entry_body_string\"],\n            \"postprocess\": function (data) {\n                return {type: \"string\", data: data[2]};\n            }\n        },\n        {\n            \"name\": \"preamble_entry\",\n            \"symbols\": [entry_type_preamble, \"_\", \"entry_body_comment\"],\n            \"postprocess\": function (data) {\n                return {type: \"preamble\", data: data[2]};\n            }\n        },\n        {\n            \"name\": \"comment_entry\",\n            \"symbols\": [entry_type_comment, \"_\", \"entry_body_comment\"],\n            \"postprocess\": function (data) {\n                return {type: \"comment\", data: data[2]};\n            }\n        },\n        {\n            \"name\": \"keyval\",\n            \"symbols\": [\"key_string\", \"_\", eq, \"_\", \"value_string\"],\n            \"postprocess\": function (data) {\n                return {type: \"keyval\", key: data[0], value: data[4]};\n            }\n        },\n        {\"name\": \"braced_string$ebnf$1\", \"symbols\": []},\n        {\"name\": \"braced_string$ebnf$1$subexpression$1\", \"symbols\": [\"non_brace\"]},\n        {\"name\": \"braced_string$ebnf$1$subexpression$1\", \"symbols\": [\"braced_string\"]},\n        {\n            \"name\": \"braced_string$ebnf$1\",\n            \"symbols\": [\"braced_string$ebnf$1\", \"braced_string$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"braced_string\",\n            \"symbols\": [brace_l, \"braced_string$ebnf$1\", brace_r],\n            \"postprocess\": function (data) {\n                const tkz: any = [];\n                for (const i in data[1]) tkz.push(data[1][i][0]);\n                return {type: \"braced\", data: tkz};\n            }\n\n        },\n        {\"name\": \"quoted_string$ebnf$1\", \"symbols\": []},\n        {\"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_quote\"]},\n        {\"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"non_quote_non_brace\"]},\n        {\"name\": \"quoted_string$ebnf$1$subexpression$1\", \"symbols\": [\"braced_string\"]},\n        {\n            \"name\": \"quoted_string$ebnf$1\",\n            \"symbols\": [\"quoted_string$ebnf$1\", \"quoted_string$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"quoted_string\",\n            \"symbols\": [quote_dbl, \"quoted_string$ebnf$1\", quote_dbl],\n            \"postprocess\": function (data) {\n                const tks: any = [];\n                for (const i in data[1]) tks.push(data[1][i][0]);\n                return {type: \"quotedstring\", data: tks};\n            }\n        },\n        {\"name\": \"escaped_quote\", \"symbols\": [esc, quote_dbl]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [ws]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [pound]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [eq]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"non_quote_non_brace$subexpression$1\", \"symbols\": [comma]},\n        {\"name\": \"non_quote_non_brace\", \"symbols\": [\"non_quote_non_brace$subexpression$1\"]},\n        {\"name\": \"key_string$ebnf$1\", \"symbols\": [\"stringreftoken\"]},\n        {\n            \"name\": \"key_string$ebnf$1\",\n            \"symbols\": [\"key_string$ebnf$1\", \"stringreftoken\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"key_string\", \"symbols\": [\"key_string$ebnf$1\"], \"postprocess\": function (data) {\n            return joinTokens(data[0]).toLowerCase();\n        }\n        },\n        {\"name\": \"value_string$subexpression$1$ebnf$1\", \"symbols\": []},\n        {\n            \"name\": \"value_string$subexpression$1$ebnf$1$subexpression$1\",\n            \"symbols\": [\"_\", pound, \"_\", \"quoted_string_or_ref\"]\n        },\n        {\n            \"name\": \"value_string$subexpression$1$ebnf$1\",\n            \"symbols\": [\"value_string$subexpression$1$ebnf$1\", \"value_string$subexpression$1$ebnf$1$subexpression$1\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"value_string$subexpression$1\",\n            \"symbols\": [\"quoted_string_or_ref\", \"value_string$subexpression$1$ebnf$1\"]\n        },\n        {\"name\": \"value_string$subexpression$1\", \"symbols\": [\"braced_string\"]},\n        {\n            \"name\": \"value_string\",\n            \"symbols\": [\"value_string$subexpression$1\"],\n            \"postprocess\": function (data) {\n                // console.log(\"DATA\",JSON.stringify(data));\n                const match = data[0];\n                if (match.length === 2) {\n                    // quoted string\n                    const tokenz: any = [];\n                    tokenz.push(match[0]);\n                    for (let i = 0; i < match[1].length; i++) tokenz.push(match[1][i][3]);\n                    return {type: \"quotedstringwrapper\", data: tokenz};\n                } else if (match[0].type === \"braced\")\n                    return {type: \"bracedstringwrapper\", data: match[0].data};\n                // else if(isNumber(match[0]) return [match[0]];\n                else throw new Error(\"Don't know how to handle value \" + JSON.stringify(match[0]));\n            }\n        },\n        {\"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [\"quoted_string\"]},\n        {\"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [\"string_ref\"]},\n        {\"name\": \"quoted_string_or_ref$subexpression$1\", \"symbols\": [num]},\n        {\n            \"name\": \"quoted_string_or_ref\",\n            \"symbols\": [\"quoted_string_or_ref$subexpression$1\"],\n            \"postprocess\": function (data) {\n                // console.log(data);\n                if (data[0][0].type === \"quotedstring\") return data[0][0];\n                else {\n                    return data[0][0];\n                }\n            }\n        },\n        {\"name\": \"string_ref$subexpression$1$ebnf$1\", \"symbols\": []},\n        {\n            \"name\": \"string_ref$subexpression$1$ebnf$1\",\n            \"symbols\": [\"string_ref$subexpression$1$ebnf$1\", \"stringreftoken\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"string_ref$subexpression$1\",\n            \"symbols\": [\"stringreftoken_n_num\", \"string_ref$subexpression$1$ebnf$1\"]\n        },\n        {\n            \"name\": \"string_ref\",\n            \"symbols\": [\"string_ref$subexpression$1\"],\n            \"postprocess\": function (data) {\n                const str = data[0][0] + joinTokens(data[0][1]);\n                return {stringref: str};\n            }\n        },\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"stringreftoken$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\n            \"name\": \"stringreftoken\",\n            \"symbols\": [\"stringreftoken$subexpression$1\"],\n            \"postprocess\": function (data) {\n                if (typeof data[0][0] === \"object\") {\n                    if (!data[0][0].string) throw new Error(\"Expected \" + data[0] + \"to have a 'string' field\");\n                    return data[0][0].string;\n                } else {\n                    if ((!(typeof data[0][0] === \"string\" || typeof data[0][0] === \"number\")))\n                        throw new Error(\"Expected \" + data[0][0] + \" to be a string\");\n                    return data[0][0];\n                }\n            }\n        },\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"stringreftoken_n_num$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\n            \"name\": \"stringreftoken_n_num\",\n            \"symbols\": [\"stringreftoken_n_num$subexpression$1\"],\n            \"postprocess\": function (data) {\n                if (typeof data[0][0] === \"object\") {\n                    if (!data[0][0].string) throw new Error(\"Expected \" + data[0] + \"to have a 'string' field\");\n                    return data[0][0].string;\n                } else {\n                    if ((!(typeof data[0][0] === \"string\" || typeof data[0][0] === \"number\")))\n                        throw new Error(\"Expected \" + data[0][0] + \" to be a string\");\n                    return data[0][0];\n                }\n            }\n        },\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [quote_dbl]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [ws]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [comma]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [pound]},\n        {\"name\": \"non_brace$subexpression$1\", \"symbols\": [eq]},\n        {\n            \"name\": \"non_brace\",\n            \"symbols\": [\"non_brace$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0];\n            }\n        },\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [esc]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [quote_dbl]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [ws]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [comma]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_bib]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_string]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_preamble]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [entry_type_comment]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [pound]},\n        {\"name\": \"non_bracket$subexpression$1\", \"symbols\": [eq]},\n        {\n            \"name\": \"non_bracket\",\n            \"symbols\": [\"non_bracket$subexpression$1\"],\n            \"postprocess\": function (data) {\n                return data[0][0];\n            }\n        },\n        {\"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_entry\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_escape\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"escaped_non_esc_outside_entry\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$1\", \"symbols\": [\"non_esc_outside_entry\"]},\n        {\"name\": \"non_entry$ebnf$1\", \"symbols\": [\"non_entry$ebnf$1$subexpression$1\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_entry\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_escape\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"escaped_non_esc_outside_entry\"]},\n        {\"name\": \"non_entry$ebnf$1$subexpression$2\", \"symbols\": [\"non_esc_outside_entry\"]},\n        {\n            \"name\": \"non_entry$ebnf$1\",\n            \"symbols\": [\"non_entry$ebnf$1\", \"non_entry$ebnf$1$subexpression$2\"],\n            \"postprocess\": function arrpush(d) {\n                return d[0].concat([d[1]]);\n            }\n        },\n        {\n            \"name\": \"non_entry\", \"symbols\": [\"non_entry$ebnf$1\"], \"postprocess\": function (data) {\n            // console.log(\"non_entry\",data);\n            const tokens: any = [];\n            for (let Ti = 0; Ti < data[0].length; Ti++) tokens.push(data[0][Ti][0]);\n            return tokens;\n        }\n        },\n        {\n            \"name\": \"escaped_escape\", \"symbols\": [esc, esc], \"postprocess\": function () {\n            return \"\\\\\";\n        }\n        },\n        {\n            \"name\": \"escaped_entry\", \"symbols\": [esc, \"entry_decl\"], \"postprocess\": function (data) {\n            return {type: \"escapedEntry\", data: data[1]};\n        }\n        },\n        {\n            \"name\": \"escaped_non_esc_outside_entry\",\n            \"symbols\": [esc, \"non_esc_outside_entry\"],\n            \"postprocess\": function (data) {\n                return data; // [\"\\\\\", data[1]];\n            }\n        },\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [tok_id]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [ws]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [num]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [pound]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [eq]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [paren_l]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [paren_r]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [brace_l]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [brace_r]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [quote_dbl]},\n        {\"name\": \"non_esc_outside_entry$subexpression$1\", \"symbols\": [comma]},\n        {\n            \"name\": \"non_esc_outside_entry\",\n            \"symbols\": [\"non_esc_outside_entry$subexpression$1\"],\n            \"postprocess\": function (data) {\n                // console.log(\"ooutside_entry\",data[0][0]);\n                return data[0][0];\n            }\n        }\n    ]\n    , ParserStart: \"main\"\n};\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/parser/ts-parser.ts","(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\nfunction Rule(name, symbols, postprocess) {\n    this.id = ++Rule.highestId;\n    this.name = name;\n    this.symbols = symbols;        // a list of literal | regex class | nonterminal\n    this.postprocess = postprocess;\n    return this;\n}\nRule.highestId = 0;\n\nRule.prototype.toString = function(withCursorAt) {\n    function stringifySymbolSequence (e) {\n        return e.literal ? JSON.stringify(e.literal) :\n               e.type ? '%' + e.type : e.toString();\n    }\n    var symbolSequence = (typeof withCursorAt === \"undefined\")\n                         ? this.symbols.map(stringifySymbolSequence).join(' ')\n                         : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                             + \"  \"\n                             + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n    return this.name + \"  \" + symbolSequence;\n}\n\n\n// a State is a rule at a position from a given starting point in the input stream (reference)\nfunction State(rule, dot, reference, wantedBy) {\n    this.rule = rule;\n    this.dot = dot;\n    this.reference = reference;\n    this.data = [];\n    this.wantedBy = wantedBy;\n    this.isComplete = this.dot === rule.symbols.length;\n}\n\nState.prototype.toString = function() {\n    return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n};\n\nState.prototype.nextState = function(child) {\n    var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n    state.left = this;\n    state.right = child;\n    if (state.isComplete) {\n        state.data = state.build();\n    }\n    return state;\n};\n\nState.prototype.build = function() {\n    var children = [];\n    var node = this;\n    do {\n        children.push(node.right.data);\n        node = node.left;\n    } while (node.left);\n    children.reverse();\n    return children;\n};\n\nState.prototype.finish = function() {\n    if (this.rule.postprocess) {\n        this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n    }\n};\n\n\nfunction Column(grammar, index) {\n    this.grammar = grammar;\n    this.index = index;\n    this.states = [];\n    this.wants = {}; // states indexed by the non-terminal they expect\n    this.scannable = []; // list of states that expect a token\n    this.completed = {}; // states that are nullable\n}\n\n\nColumn.prototype.process = function(nextColumn) {\n    var states = this.states;\n    var wants = this.wants;\n    var completed = this.completed;\n\n    for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n        var state = states[w];\n\n        if (state.isComplete) {\n            state.finish();\n            if (state.data !== Parser.fail) {\n                // complete\n                var wantedBy = state.wantedBy;\n                for (var i = wantedBy.length; i--; ) { // this line is hot\n                    var left = wantedBy[i];\n                    this.complete(left, state);\n                }\n\n                // special-case nullables\n                if (state.reference === this.index) {\n                    // make sure future predictors of this rule get completed.\n                    var exp = state.rule.name;\n                    (this.completed[exp] = this.completed[exp] || []).push(state);\n                }\n            }\n\n        } else {\n            // queue scannable states\n            var exp = state.rule.symbols[state.dot];\n            if (typeof exp !== 'string') {\n                this.scannable.push(state);\n                continue;\n            }\n\n            // predict\n            if (wants[exp]) {\n                wants[exp].push(state);\n\n                if (completed.hasOwnProperty(exp)) {\n                    var nulls = completed[exp];\n                    for (var i = 0; i < nulls.length; i++) {\n                        var right = nulls[i];\n                        this.complete(state, right);\n                    }\n                }\n            } else {\n                wants[exp] = [state];\n                this.predict(exp);\n            }\n        }\n    }\n}\n\nColumn.prototype.predict = function(exp) {\n    var rules = this.grammar.byName[exp] || [];\n\n    for (var i = 0; i < rules.length; i++) {\n        var r = rules[i];\n        var wantedBy = this.wants[exp];\n        var s = new State(r, 0, this.index, wantedBy);\n        this.states.push(s);\n    }\n}\n\nColumn.prototype.complete = function(left, right) {\n    var inp = right.rule.name;\n    if (left.rule.symbols[left.dot] === inp) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n}\n\n\nfunction Grammar(rules, start) {\n    this.rules = rules;\n    this.start = start || this.rules[0].name;\n    var byName = this.byName = {};\n    this.rules.forEach(function(rule) {\n        if (!byName.hasOwnProperty(rule.name)) {\n            byName[rule.name] = [];\n        }\n        byName[rule.name].push(rule);\n    });\n}\n\n// So we can allow passing (rules, start) directly to Parser for backwards compatibility\nGrammar.fromCompiled = function(rules, start) {\n    var lexer = rules.Lexer;\n    if (rules.ParserStart) {\n      start = rules.ParserStart;\n      rules = rules.ParserRules;\n    }\n    var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n    var g = new Grammar(rules, start);\n    g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n    return g;\n}\n\n\nfunction StreamLexer() {\n  this.reset(\"\");\n}\n\nStreamLexer.prototype.reset = function(data, state) {\n    this.buffer = data;\n    this.index = 0;\n    this.line = state ? state.line : 1;\n    this.lastLineBreak = state ? -state.col : 0;\n}\n\nStreamLexer.prototype.next = function() {\n    if (this.index < this.buffer.length) {\n        var ch = this.buffer[this.index++];\n        if (ch === '\\n') {\n          this.line += 1;\n          this.lastLineBreak = this.index;\n        }\n        return {value: ch};\n    }\n}\n\nStreamLexer.prototype.save = function() {\n  return {\n    line: this.line,\n    col: this.index - this.lastLineBreak,\n  }\n}\n\nStreamLexer.prototype.formatError = function(token, message) {\n    // nb. this gets called after consuming the offending token,\n    // so the culprit is index-1\n    var buffer = this.buffer;\n    if (typeof buffer === 'string') {\n        var nextLineBreak = buffer.indexOf('\\n', this.index);\n        if (nextLineBreak === -1) nextLineBreak = buffer.length;\n        var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n        var col = this.index - this.lastLineBreak;\n        message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n        message += \"  \" + line + \"\\n\"\n        message += \"  \" + Array(col).join(\" \") + \"^\"\n        return message;\n    } else {\n        return message + \" at index \" + (this.index - 1);\n    }\n}\n\n\nfunction Parser(rules, start, options) {\n    if (rules instanceof Grammar) {\n        var grammar = rules;\n        var options = start;\n    } else {\n        var grammar = Grammar.fromCompiled(rules, start);\n    }\n    this.grammar = grammar;\n\n    // Read options\n    this.options = {\n        keepHistory: false,\n        lexer: grammar.lexer || new StreamLexer,\n    };\n    for (var key in (options || {})) {\n        this.options[key] = options[key];\n    }\n\n    // Setup lexer\n    this.lexer = this.options.lexer;\n    this.lexerState = undefined;\n\n    // Setup a table\n    var column = new Column(grammar, 0);\n    var table = this.table = [column];\n\n    // I could be expecting anything.\n    column.wants[grammar.start] = [];\n    column.predict(grammar.start);\n    // TODO what if start rule is nullable?\n    column.process();\n    this.current = 0; // token index\n}\n\n// create a reserved token for indicating a parse fail\nParser.fail = {};\n\nParser.prototype.feed = function(chunk) {\n    var lexer = this.lexer;\n    lexer.reset(chunk, this.lexerState);\n\n    while (token = lexer.next()) {\n        // We add new states to table[current+1]\n        var column = this.table[this.current];\n\n        // GC unused states\n        if (!this.options.keepHistory) {\n            delete this.table[this.current - 1];\n        }\n\n        var n = this.current + 1;\n        var nextColumn = new Column(this.grammar, n);\n        this.table.push(nextColumn);\n\n        // Advance all tokens that expect the symbol\n        var literal = token.value;\n        var value = lexer.constructor === StreamLexer ? token.value : token;\n        var scannable = column.scannable;\n        for (var w = scannable.length; w--; ) {\n            var state = scannable[w];\n            var expect = state.rule.symbols[state.dot];\n            // Try to consume the token\n            // either regex or literal\n            if (expect.test ? expect.test(value) :\n                expect.type ? expect.type === token.type\n                            : expect.literal === literal) {\n                // Add it\n                var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                nextColumn.states.push(next);\n            }\n        }\n\n        // Next, for each of the rules, we either\n        // (a) complete it, and try to see if the reference row expected that\n        //     rule\n        // (b) predict the next nonterminal it expects by adding that\n        //     nonterminal's start state\n        // To prevent duplication, we also keep track of rules we have already\n        // added\n\n        nextColumn.process();\n\n        // If needed, throw an error:\n        if (nextColumn.states.length === 0) {\n            // No states at all! This is not good.\n            var message = this.lexer.formatError(token, \"invalid syntax\") + \"\\n\";\n            message += \"Unexpected \" + (token.type ? token.type + \" token: \" : \"\");\n            message += JSON.stringify(token.value !== undefined ? token.value : token) + \"\\n\";\n            var err = new Error(message);\n            err.offset = this.current;\n            err.token = token;\n            throw err;\n        }\n\n        // maybe save lexer state\n        if (this.options.keepHistory) {\n          column.lexerState = lexer.save()\n        }\n\n        this.current++;\n    }\n    if (column) {\n      this.lexerState = lexer.save()\n    }\n\n    // Incrementally keep track of results\n    this.results = this.finish();\n\n    // Allow chaining, for whatever it's worth\n    return this;\n};\n\nParser.prototype.save = function() {\n    var column = this.table[this.current];\n    column.lexerState = this.lexerState;\n    return column;\n};\n\nParser.prototype.restore = function(column) {\n    var index = column.index;\n    this.current = index;\n    this.table[index] = column;\n    this.table.splice(index + 1);\n    this.lexerState = column.lexerState;\n\n    // Incrementally keep track of results\n    this.results = this.finish();\n};\n\n// nb. deprecated: use save/restore instead!\nParser.prototype.rewind = function(index) {\n    if (!this.options.keepHistory) {\n        throw new Error('set option `keepHistory` to enable rewinding')\n    }\n    // nb. recall column (table) indicies fall between token indicies.\n    //        col 0   --   token 0   --   col 1\n    this.restore(this.table[index]);\n};\n\nParser.prototype.finish = function() {\n    // Return the possible parsings\n    var considerations = [];\n    var start = this.grammar.start;\n    var column = this.table[this.table.length - 1]\n    column.states.forEach(function (t) {\n        if (t.rule.name === start\n                && t.dot === t.rule.symbols.length\n                && t.reference === 0\n                && t.data !== Parser.fail) {\n            considerations.push(t);\n        }\n    });\n    return considerations.map(function(c) {return c.data; });\n};\n\nreturn {\n    Parser: Parser,\n    Grammar: Grammar,\n    Rule: Rule,\n};\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nearley/lib/nearley.js\n// module id = 19\n// module chunks = 0"],"sourceRoot":""}