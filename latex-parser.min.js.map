{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///latex-parser.min.js","webpack:///webpack/bootstrap c3daba75bdea758aa830","webpack:///./sources/lib/Utils.ts","webpack:///./sources/lib/Latex.ts","webpack:///./sources/lib/LatexStyle.ts","webpack:///./sources/lib/LatexTree.ts","webpack:///./sources/lib/SyntaxTree.ts","webpack:///./sources/lib/LatexParser.ts","webpack:///./sources/main.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","updateProperties","target","values","opt_keys","opt_attributes","arguments","length","undefined","writable","TypeError","key","create","Array","forEach","targetKey","_key","testProperties","opt_skipUndefined","every","_key2","isNumber","x","isString","mustNotBeUndefined","Error","_classCallCheck","instance","Constructor","isMode","modes","mustBeMode","isOperationProperties","mustBeOperationProperties","_createClass","defineProperties","props","descriptor","protoProps","staticProps","Lexeme","BINARY_OPERATOR","BRACKETS","CELL_SEPARATOR","CHAR","DIGIT","DIRECTIVE","DISPLAY_EQUATION","FILE_PATH","FLOATING_BOX","HORIZONTAL_SKIP","INLINE_EQUATION","LABEL","LENGTH","LETTER","LINE_BREAK","LIST_ITEM","LIST","NUMBER","PARAGRAPH_SEPARATOR","PICTURE","POST_OPERATOR","PRE_OPERATOR","RAW","SPACE","SUBSCRIPT","SUPERSCRIPT","TABLE","TABULAR_PARAMETERS","TAG","UNKNOWN","VERTICAL_SKIP","WORD","WRAPPER","MATH","TEXT","VERTICAL","Directive","State","opt_initialModeStates","modeStates_","update","modeStates","modeKey","mode","BEGIN","END","GROUP","Operation","opt_initialProperties","directive","operand","other","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","constructor","setPrototypeOf","__proto__","isArray","mustBeArray","isParameterProperties","ignored","mustBeParameterProperties","isCommand","Command","mustBeCommand","isEnvironment","Environment","Symbol","Parameter","Item","_typeof","iterator","obj","_get","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_Utils","_Latex","LatexStyle","symbols_","commands_","environments_","packageName","stylePackage","symbols","iSymbol","symbol","_Symbol","pattern","symbolPatternFirstChar","push","commands","iCommand","command","environments","iEnvironment","environment","envName","storedEnv","filteredSymbols","filter","styleItem","commandName","filteredCommands","environmentName","filteredEnvironments","state","patternFirstChar","SyntaxError","test","env","default","lexeme","_Item","_this","operations","map","operation","operations_","iOperation","equals","slice","_Item2","_this2","parameters","parameters_","parameter","patternComponents","match","patternComponents_","patternPart","parameterIndex","Number","substring","html","iParameter","patternComponent","join","_Symbol2","_this3","_Item3","_this4","isCommandToken","CommandToken","mustBeEnvironmentToken","isEnvironmentToken","EnvironmentToken","getBeginCommandToken","beginCommandToken","getEndCommandToken","endCommandToken","getEnvironment","_LatexStyle","SourceToken","SpaceToken","EnvironmentBodyToken","ParameterToken","SymbolToken","Token","_SyntaxTree2","_class","_SyntaxTree","rootToken","source","SyntaxTree","_Node","superInitialProperties","parentNode","parentToken","childNodes","childTokens","Node","parentNodeClass_","_Token","initialProperties","skipNodeClass","nPatternChars","iPatternChar","patternChar","parameterToken","childNode","toString","_Token2","hasBrackets","hasSpacePrefix","symbolToken","childIndex","_SymbolToken","_this5","_Token3","_this6","bodyToken","beginToken","endToken","_Token4","apply","_Token5","_this8","lineBreakCount","isFinite","_Token6","_this9","_toConsumableArray","arr","arr2","from","rootNode","tree","insertChildSubtree","optParentNode","node","childNodes_","indexOf","childNodesToCover","nodeChildNodes","splice","subtreeSize","nodeChildNode","nodeSubtreeSize","nodeOrNodeIndex","_childNodes_","nodeChildIndex","concat","parseCommentLine_","context","commentMatch","position","comments","lineNumber","charNumber","processParsedToken_","token","currentToken","parseSpaceToken_","isSpace","nLineBreaks","_LatexTree","Context","LatexParser","_LatexStyle2","latexStyle","opt_context","parsedTokens","parsedToken","parseToken_","contextBackup","copy","parseEnvironmentToken_","parseCommandToken_","parseSymbolsToken_","opt_endLabel","currentTokenBackup","updateState","spacePrefixState","parseUntilLabel_","startsWith","nameMatch","currentState","environmentToken","parsePatterns_","environmentBodyToken","endFound","cmdMatch","sourceCharacter","some","parsePattern_","nPatternComponents","iPatternComponent","parameterEndLabel","parseParameterToken_","endLabel","opt_lexeme","opt_source","stateStack","opt_target","newModeStates","pop","keys","_LatexParser"],"mappings":"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","file":"latex-parser.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"latex-parser\"] = factory();\n\telse\n\t\troot[\"latex-parser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"latex-parser\"] = factory();\n\telse\n\t\troot[\"latex-parser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.updateProperties = updateProperties;\nexports.testProperties = testProperties;\nexports.isNumber = isNumber;\nexports.isString = isString;\nexports.mustNotBeUndefined = mustNotBeUndefined;\nfunction updateProperties(target, values, opt_keys) {\n    var opt_attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { writable: true, enumerable: true, configurable: true };\n\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return;\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_attributes === undefined) {\n        opt_attributes = { writable: true, enumerable: true, configurable: true };\n    } else if (!(opt_attributes instanceof Object)) {\n        throw new TypeError('\"attributes\" isn\\'t an Object instance');\n    }\n    if (opt_keys === undefined) {\n        for (var key in values) {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, Object.create(opt_attributes, { value: { value: values[key] } }));\n            }\n        }\n    } else if (opt_keys instanceof Array) {\n        opt_keys.forEach(function (key) {\n            if (values[key] !== undefined) {\n                Object.defineProperty(target, key, Object.create(opt_attributes, { value: { value: values[key] } }));\n            }\n        });\n    } else if (opt_keys instanceof Object) {\n        for (var targetKey in opt_keys) {\n            var _key = opt_keys[targetKey];\n            if (values[_key] !== undefined) Object.defineProperty(target, targetKey, Object.create(opt_attributes, { value: { value: values[_key] } }));\n        }\n    } else {\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n}\n;\nfunction testProperties(target, values, opt_keys) {\n    var opt_skipUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\n    if (values === undefined) return true;\n    if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\n    if (opt_skipUndefined === undefined) opt_skipUndefined = true;\n    if (opt_keys === undefined) {\n        for (var key in values) {\n            if (target[key] !== values[key] && !(values[key] === undefined && opt_skipUndefined)) return false;\n        }\n    } else if (opt_keys instanceof Array) {\n        return opt_keys.every(function (key) {\n            return target[key] === values[key] || values[key] === undefined && opt_skipUndefined;\n        });\n    } else if (opt_keys instanceof Object) {\n        for (var targetKey in opt_keys) {\n            var _key2 = opt_keys[targetKey];\n            if (target[targetKey] !== values[_key2] && !(values[_key2] === undefined && opt_skipUndefined)) return false;\n        }\n    } else {\n        throw new TypeError('\"keys\" isn\\'t an Object instance');\n    }\n    return true;\n}\n;\nfunction isNumber(x) {\n    return typeof x === \"number\";\n}\nfunction isString(x) {\n    return typeof x === \"string\";\n}\nfunction mustNotBeUndefined(x) {\n    if (!x) throw new Error();\n    return x;\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.isMode = isMode;\nexports.mustBeMode = mustBeMode;\nexports.isOperationProperties = isOperationProperties;\nexports.mustBeOperationProperties = mustBeOperationProperties;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Lexeme = exports.Lexeme = {\n    BINARY_OPERATOR: 'BINARY_OPERATOR',\n    BRACKETS: 'BRACKETS',\n    CELL_SEPARATOR: 'CELL_SEPARATOR',\n    CHAR: 'CHAR',\n    DIGIT: 'DIGIT',\n    DIRECTIVE: 'DIRECTIVE',\n    DISPLAY_EQUATION: 'DISPLAY_EQUATION',\n    FILE_PATH: 'FILE_PATH',\n    FLOATING_BOX: 'FLOATING_BOX',\n    HORIZONTAL_SKIP: 'HORIZONTAL_SKIP',\n    INLINE_EQUATION: 'INLINE_EQUATION',\n    LABEL: 'LABEL',\n    LENGTH: 'LENGTH',\n    LETTER: 'LETTER',\n    LINE_BREAK: 'LINE_BREAK',\n    LIST_ITEM: 'LIST_ITEM',\n    LIST: 'LIST',\n    NUMBER: 'NUMBER',\n    PARAGRAPH_SEPARATOR: 'PARAGRAPH_SEPARATOR',\n    PICTURE: 'PICTURE',\n    POST_OPERATOR: 'POST_OPERATOR',\n    PRE_OPERATOR: 'PRE_OPERATOR',\n    RAW: 'RAW',\n    SPACE: 'SPACE',\n    SUBSCRIPT: 'SUBSCRIPT',\n    SUPERSCRIPT: 'SUPERSCRIPT',\n    TABLE: 'TABLE',\n    TABULAR_PARAMETERS: 'TABULAR_PARAMETERS',\n    TAG: 'TAG',\n    UNKNOWN: 'UNKNOWN',\n    VERTICAL_SKIP: 'VERTICAL_SKIP',\n    WORD: 'WORD',\n    WRAPPER: 'WRAPPER'\n};\nvar modes = exports.modes = {\n    LIST: 'LIST',\n    MATH: 'MATH',\n    PICTURE: 'PICTURE',\n    TABLE: 'TABLE',\n    TEXT: 'TEXT',\n    VERTICAL: 'VERTICAL'\n};\nfunction isMode(x) {\n    return modes.hasOwnProperty(x);\n}\nfunction mustBeMode(x) {\n    if (!isMode(x)) throw new Error();\n    return x;\n}\n\nvar State = exports.State = function () {\n    function State() {\n        var opt_initialModeStates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, State);\n\n        Object.defineProperty(this, 'modeStates_', { value: {}, enumerable: false });\n        this.modeStates_[modes.LIST] = false;\n        this.modeStates_[modes.MATH] = false;\n        this.modeStates_[modes.PICTURE] = false;\n        this.modeStates_[modes.TABLE] = false;\n        this.modeStates_[modes.TEXT] = true;\n        this.modeStates_[modes.VERTICAL] = false;\n        if (opt_initialModeStates !== undefined) this.update(opt_initialModeStates);\n    }\n\n    _createClass(State, [{\n        key: 'copy',\n        value: function copy() {\n            return new State(this.modeStates_);\n        }\n    }, {\n        key: 'update',\n        value: function update(modeStates) {\n            for (var modeKey in modeStates) {\n                var mode = modes[mustBeMode(modeKey)];\n                if (mode === undefined) throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\n                this.modeStates_[mode] = modeStates[modeKey];\n            }\n        }\n    }, {\n        key: 'test',\n        value: function test(modeStates) {\n            for (var modeKey in modeStates) {\n                var mode = modes[mustBeMode(modeKey)];\n                if (mode === undefined) throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\n                if (this.modeStates_[mode] !== modeStates[modeKey]) return false;\n            }\n            return true;\n        }\n    }]);\n\n    return State;\n}();\n\n;\nvar Directive = exports.Directive = {\n    BEGIN: 'BEGIN',\n    END: 'END'\n};\nvar GROUP = exports.GROUP = 'GROUP';\nfunction isOperationProperties(x) {\n    return x && x.hasOwnProperty(\"directive\") && x.hasOwnProperty(\"operand\");\n}\nfunction mustBeOperationProperties(x) {\n    if (!isOperationProperties(x)) throw new Error();\n    return x;\n}\n\nvar Operation = exports.Operation = function () {\n    function Operation(opt_initialProperties) {\n        _classCallCheck(this, Operation);\n\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        var directive = Directive[opt_initialProperties.directive];\n        if (!directive) throw new TypeError('\"initialProperties.directive\" isn\\'t an Latex.Directive option');\n        Object.defineProperty(this, 'directive', { value: directive, enumerable: true });\n        switch (opt_initialProperties.operand) {\n            case GROUP:\n                Object.defineProperty(this, 'operand', { value: GROUP, enumerable: true });\n                break;\n            default:\n                var mode = modes[opt_initialProperties.operand];\n                if (!mode) throw new TypeError('\"initialProperties.operand\" isn\\'t an Latex.Mode option');\n                Object.defineProperty(this, 'operand', { value: mode, enumerable: true });\n        }\n    }\n\n    _createClass(Operation, [{\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof Operation)) return false;\n            return this.directive === other.directive && this.operand === other.operand;\n        }\n    }]);\n\n    return Operation;\n}();\n\n;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Environment = exports.Command = exports.Symbol = exports.Parameter = exports.Item = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.isParameterProperties = isParameterProperties;\nexports.mustBeParameterProperties = mustBeParameterProperties;\nexports.isCommand = isCommand;\nexports.mustBeCommand = mustBeCommand;\nexports.isEnvironment = isEnvironment;\n\nvar _Utils = __webpack_require__(0);\n\nvar _Latex = __webpack_require__(1);\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction isArray(x) {\n    return x.constructor === Array;\n}\nfunction mustBeArray(x) {\n    if (!isArray(x)) throw new Error();\n    return x;\n}\n\nvar LatexStyle = function () {\n    function LatexStyle() {\n        _classCallCheck(this, LatexStyle);\n\n        this.symbols_ = {};\n        this.commands_ = {};\n        this.environments_ = {};\n    }\n\n    _createClass(LatexStyle, [{\n        key: 'loadPackage',\n        value: function loadPackage(packageName, stylePackage) {\n            if (stylePackage.symbols !== undefined) {\n                if (!(stylePackage.symbols instanceof Array)) throw new TypeError('\"stylePackage.symbols\" isn\\'t an Array');\n                for (var iSymbol = stylePackage.symbols.length - 1; iSymbol >= 0; --iSymbol) {\n                    var symbol = new _Symbol(stylePackage.symbols[iSymbol]);\n                    if (symbol.pattern) {\n                        var symbolPatternFirstChar = symbol.pattern[0];\n                        if (!this.symbols_.hasOwnProperty(symbolPatternFirstChar)) this.symbols_[symbolPatternFirstChar] = [];\n                        var symbols = this.symbols_[symbolPatternFirstChar];\n                        symbols.push({ symbol: symbol, packageName: packageName });\n                    }\n                }\n            }\n            if (stylePackage.commands !== undefined) {\n                if (!(stylePackage.commands instanceof Array)) throw new TypeError('\"stylePackage.commands\" isn\\'t an Array');\n                for (var iCommand = stylePackage.commands.length - 1; iCommand >= 0; --iCommand) {\n                    var command = new Command(stylePackage.commands[iCommand]);\n                    if (command.name) {\n                        (this.commands_[command.name] || (this.commands_[command.name] = [])).push({ command: command, packageName: packageName });\n                    }\n                }\n            }\n            if (stylePackage.environments !== undefined) {\n                if (!(stylePackage.environments instanceof Array)) throw new TypeError('\"stylePackage.environments\" isn\\'t an Array');\n                for (var iEnvironment = stylePackage.environments.length - 1; iEnvironment >= 0; --iEnvironment) {\n                    var environment = new Environment(stylePackage.environments[iEnvironment]);\n                    var envName = environment.name;\n                    if (envName) {\n                        var storedEnv = this.environments_[envName];\n                        if (storedEnv === undefined) {\n                            storedEnv = [];\n                            this.environments_[envName] = storedEnv;\n                        }\n                        storedEnv.push({ environment: environment, packageName: packageName });\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'unloadPackage',\n        value: function unloadPackage(packageName) {\n            for (var symbolPatternFirstChar in this.symbols_) {\n                if (this.symbols_.hasOwnProperty(symbolPatternFirstChar)) {\n                    var filteredSymbols = mustBeArray(this.symbols_[symbolPatternFirstChar]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredSymbols.length) {\n                        this.symbols_[symbolPatternFirstChar] = filteredSymbols;\n                    } else {\n                        delete this.symbols_[symbolPatternFirstChar];\n                    }\n                }\n            }for (var commandName in this.commands_) {\n                if (this.commands_.hasOwnProperty(commandName)) {\n                    var filteredCommands = mustBeArray(this.commands_[commandName]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredCommands.length) {\n                        this.commands_[commandName] = filteredCommands;\n                    } else {\n                        delete this.commands_[commandName];\n                    }\n                }\n            }for (var environmentName in this.environments_) {\n                if (this.environments_.hasOwnProperty(environmentName)) {\n                    var filteredEnvironments = mustBeArray(this.environments_[environmentName]).filter(function (styleItem) {\n                        return styleItem.packageName !== packageName;\n                    });\n                    if (filteredEnvironments.length) {\n                        this.environments_[environmentName] = filteredEnvironments;\n                    } else {\n                        delete this.environments_[environmentName];\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'symbols',\n        value: function symbols(state, patternFirstChar) {\n            if (!(state instanceof _Latex.State)) throw new SyntaxError('\"state\" isn\\'t a State instance');\n            var symbols = this.symbols_[patternFirstChar];\n            if (symbols === undefined) return [];\n            var filteredSymbols = [];\n            for (var iSymbol = mustBeArray(symbols).length - 1; iSymbol >= 0; --iSymbol) {\n                var symbol = symbols[iSymbol].symbol;\n                if (state.test(symbol.modes)) filteredSymbols.push(symbol);\n            }\n            return filteredSymbols;\n        }\n    }, {\n        key: 'commands',\n        value: function commands(state, name) {\n            if (!(state instanceof _Latex.State)) throw new SyntaxError('\"state\" isn\\'t a State instance');\n            var commands = this.commands_[name];\n            if (!commands) return [];\n            var filteredCommands = [];\n            for (var iCommand = mustBeArray(commands).length - 1; iCommand >= 0; --iCommand) {\n                var command = commands[iCommand].command;\n                if (state.test(command.modes)) filteredCommands.push(command);\n            }\n            return filteredCommands;\n        }\n    }, {\n        key: 'environments',\n        value: function environments(state, name) {\n            if (!(state instanceof _Latex.State)) throw new SyntaxError('state isn\\'t State instance');\n            var environments = this.environments_[name];\n            if (!environments) return [];\n            return mustBeArray(environments).filter(function (env) {\n                return state.test(env.modes);\n            });\n        }\n    }]);\n\n    return LatexStyle;\n}();\n\nexports.default = LatexStyle;\n\n;\n\nvar Item = exports.Item = function () {\n    function Item() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Item);\n\n        if (opt_initialProperties === undefined) return;\n        if (!(opt_initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        switch (opt_initialProperties.lexeme) {\n            case undefined:\n                break;\n            case null:\n                break;\n            default:\n                var lexeme = _Latex.Lexeme[opt_initialProperties.lexeme];\n                if (lexeme === undefined) throw new TypeError('\"initialProperties.lexeme\" isn\\'t a Lexeme option');\n                Object.defineProperty(this, 'lexeme', { value: lexeme });\n        }\n        if (opt_initialProperties.modes !== undefined) {\n            if (!(opt_initialProperties.modes instanceof Object)) throw new TypeError('\"initialProperties.modes\" isn\\'t an Object instance');\n            Object.defineProperty(this, 'modes', { value: {} });\n            for (var modeKey in opt_initialProperties.modes) {\n                var mode = (0, _Latex.mustBeMode)(modeKey);\n                if (mode === undefined) throw new TypeError('\"initialProperties.modes[' + modeKey + ']\" isn\\'t a Mode option');\n                Object.defineProperty(this.modes, mode, {\n                    value: opt_initialProperties.modes[modeKey],\n                    enumerable: true\n                });\n            }\n        }\n    }\n\n    _createClass(Item, [{\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof Item)) return false;\n            return this.lexeme === other.lexeme && (0, _Utils.testProperties)(this.modes, other.modes, _Latex.modes, false);\n        }\n    }]);\n\n    return Item;\n}();\n\n;\nObject.defineProperties(Item.prototype, {\n    lexeme: { value: undefined, enumerable: true },\n    modes: { value: {}, enumerable: true }\n});\nfunction isParameterProperties(ignored) {\n    return true;\n}\nfunction mustBeParameterProperties(x) {\n    if (!isParameterProperties) throw new Error();\n    return x;\n}\n\nvar Parameter = exports.Parameter = function (_Item) {\n    _inherits(Parameter, _Item);\n\n    function Parameter() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Parameter);\n\n        var _this = _possibleConstructorReturn(this, (Parameter.__proto__ || Object.getPrototypeOf(Parameter)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this);\n        if (opt_initialProperties.operations !== undefined) {\n            if (!(opt_initialProperties.operations instanceof Array)) throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(_this, 'operations_', {\n                value: opt_initialProperties.operations.map(function (operation) {\n                    return new _Latex.Operation(operation);\n                })\n            });\n        }\n        return _this;\n    }\n\n    _createClass(Parameter, [{\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof Parameter)) return false;\n            if (!_get(Parameter.prototype.__proto__ || Object.getPrototypeOf(Parameter.prototype), 'equals', this).call(this, other)) return false;\n            if (this.operations_.length !== other.operations_.length) return false;\n            return this.operations_.every(function (operation, iOperation) {\n                return operation.equals(other.operations_[iOperation]);\n            });\n        }\n    }, {\n        key: 'operations',\n        get: function get() {\n            return this.operations_.slice();\n        }\n    }]);\n\n    return Parameter;\n}(Item);\n\n;\nObject.defineProperties(Parameter.prototype, {\n    operations: { enumerable: true }\n});\nObject.defineProperties(Parameter.prototype, {\n    operations_: { value: [], enumerable: false }\n});\n\nvar _Symbol = function (_Item2) {\n    _inherits(_Symbol, _Item2);\n\n    function _Symbol() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, _Symbol);\n\n        var _this2 = _possibleConstructorReturn(this, (_Symbol.__proto__ || Object.getPrototypeOf(_Symbol)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this2);\n        if (opt_initialProperties.operations !== undefined) {\n            if (!(opt_initialProperties.operations instanceof Array)) throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\n            Object.defineProperty(_this2, 'operations_', {\n                value: opt_initialProperties.operations.map(function (operation) {\n                    return new _Latex.Operation((0, _Latex.mustBeOperationProperties)(operation));\n                })\n            });\n        }\n        if (opt_initialProperties.parameters !== undefined) {\n            if (!(opt_initialProperties.parameters instanceof Array)) throw new TypeError('\"initialProperties.parameters\" isn\\'t an Array instance');\n            _this2.parameters_ = opt_initialProperties.parameters.map(function (parameter) {\n                return new Parameter(mustBeParameterProperties(parameter));\n            });\n        }\n        if (opt_initialProperties.pattern !== undefined) {\n            if (typeof opt_initialProperties.pattern !== 'string') throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            var patternComponents = opt_initialProperties.pattern.match(/([ \\t]+|#\\d+|[^ \\t#]+)/g);\n            if (!!patternComponents) {\n                _this2.patternComponents_ = patternComponents.map(function (patternPart) {\n                    switch (patternPart[0]) {\n                        case ' ':\n                        case '\\t':\n                            return undefined;\n                        case '#':\n                            var parameterIndex = Number(patternPart.substring(1)) - 1;\n                            if (!_this2.parameters_[parameterIndex]) throw new TypeError('\"initialProperties.pattern\" contains the incorrect parameter number ' + patternPart.substring(1));\n                            return parameterIndex;\n                        default:\n                            return patternPart;\n                    }\n                });\n            }\n        }\n        if (opt_initialProperties.html !== undefined) {\n            if (typeof opt_initialProperties.html !== 'string') throw new TypeError('\"initialProperties.html\" isn\\'t a string');\n            Object.defineProperty(_this2, 'html', { value: opt_initialProperties.html, enumerable: true });\n        }\n        return _this2;\n    }\n\n    _createClass(_Symbol, [{\n        key: 'parameter',\n        value: function parameter(parameterIndex) {\n            return this.parameters_[parameterIndex] || undefined;\n        }\n    }, {\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof _Symbol)) return false;\n            if (!_get(_Symbol.prototype.__proto__ || Object.getPrototypeOf(_Symbol.prototype), 'equals', this).call(this, other)) return false;\n            if (this.operations_.length !== other.operations_.length) return false;\n            if (!this.operations_.every(function (operation, iOperation) {\n                return operation.equals(other.operations_[iOperation]);\n            })) return false;\n            if (this.parameters_.length !== other.parameters_.length) return false;\n            if (!this.parameters_.every(function (parameter, iParameter) {\n                return parameter.equals(other.parameters_[iParameter]);\n            })) return false;\n            return this.html === other.html;\n        }\n    }, {\n        key: 'operations',\n        get: function get() {\n            return this.operations_.slice();\n        }\n    }, {\n        key: 'parameters',\n        get: function get() {\n            return this.parameters_.slice();\n        }\n    }, {\n        key: 'patternComponents',\n        get: function get() {\n            return (0, _Utils.mustNotBeUndefined)(this.patternComponents_.slice());\n        }\n    }, {\n        key: 'pattern',\n        get: function get() {\n            return this.patternComponents_.map(function (patternComponent) {\n                if ((0, _Utils.isNumber)(patternComponent)) {\n                    return '#' + (patternComponent + 1);\n                }\n                switch (typeof patternComponent === 'undefined' ? 'undefined' : _typeof(patternComponent)) {\n                    case 'string':\n                        return patternComponent;\n                    default:\n                        return ' ';\n                }\n            }).join('');\n        }\n    }]);\n\n    return _Symbol;\n}(Item);\n\nexports.Symbol = _Symbol;\n\n;\nObject.defineProperties(_Symbol.prototype, {\n    operations: { enumerable: true },\n    parameters: { enumerable: true },\n    patternComponents: { enumerable: true },\n    pattern: { enumerable: true }\n});\nObject.defineProperties(_Symbol.prototype, {\n    operations_: { value: [], enumerable: false, writable: true },\n    parameters_: { value: [], enumerable: false, writable: true },\n    patternComponents_: { value: [], enumerable: false, writable: true },\n    html: { value: '', enumerable: true, writable: true }\n});\n\nvar Command = exports.Command = function (_Symbol2) {\n    _inherits(Command, _Symbol2);\n\n    function Command() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Command);\n\n        var _this3 = _possibleConstructorReturn(this, (Command.__proto__ || Object.getPrototypeOf(Command)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this3);\n        if (opt_initialProperties.name !== undefined) {\n            if (typeof opt_initialProperties.name !== 'string') throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            Object.defineProperty(_this3, 'name', { value: opt_initialProperties.name });\n        }\n        return _this3;\n    }\n\n    _createClass(Command, [{\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof Command)) return false;\n            if (!_get(Command.prototype.__proto__ || Object.getPrototypeOf(Command.prototype), 'equals', this).call(this, other)) return false;\n            return this.name === other.name;\n        }\n    }]);\n\n    return Command;\n}(_Symbol);\n\n;\nObject.defineProperties(Command.prototype, {\n    name: { value: '', enumerable: true }\n});\nfunction isCommand(c) {\n    return c instanceof Command;\n}\nfunction mustBeCommand(c) {\n    if (!isCommand(c)) throw new Error();\n    return c;\n}\n\nvar Environment = exports.Environment = function (_Item3) {\n    _inherits(Environment, _Item3);\n\n    function Environment() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Environment);\n\n        var _this4 = _possibleConstructorReturn(this, (Environment.__proto__ || Object.getPrototypeOf(Environment)).call(this, opt_initialProperties));\n\n        if (opt_initialProperties === undefined) return _possibleConstructorReturn(_this4);\n        if (opt_initialProperties.name !== undefined) {\n            if (typeof opt_initialProperties.name !== 'string') throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            Object.defineProperty(_this4, 'name', { value: opt_initialProperties.name });\n        }\n        return _this4;\n    }\n\n    _createClass(Environment, [{\n        key: 'equals',\n        value: function equals(other) {\n            if (!(other instanceof Environment)) return false;\n            if (!_get(Environment.prototype.__proto__ || Object.getPrototypeOf(Environment.prototype), 'equals', this).call(this, other)) return false;\n            return this.name === other.name;\n        }\n    }]);\n\n    return Environment;\n}(Item);\n\n;\nObject.defineProperties(Environment.prototype, {\n    name: { value: '', enumerable: true }\n});\nfunction isEnvironment(x) {\n    return x instanceof Environment;\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SourceToken = exports.SpaceToken = exports.EnvironmentBodyToken = exports.EnvironmentToken = exports.CommandToken = exports.ParameterToken = exports.SymbolToken = exports.Token = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nexports.isCommandToken = isCommandToken;\nexports.mustBeEnvironmentToken = mustBeEnvironmentToken;\nexports.isEnvironmentToken = isEnvironmentToken;\n\nvar _LatexStyle = __webpack_require__(2);\n\nvar _SyntaxTree2 = __webpack_require__(4);\n\nvar _Latex = __webpack_require__(1);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _class = function (_SyntaxTree) {\n    _inherits(_class, _SyntaxTree);\n\n    function _class(rootToken, source) {\n        _classCallCheck(this, _class);\n\n        if (!(rootToken instanceof Token)) throw new TypeError('\"rootToken\" isn\\'t a Token instance');\n        return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, rootToken, source));\n    }\n\n    return _class;\n}(_SyntaxTree2.SyntaxTree);\n\nexports.default = _class;\n\n;\n\nvar Token = exports.Token = function (_Node) {\n    _inherits(Token, _Node);\n\n    function Token() {\n        var opt_initialProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Token);\n\n        if (opt_initialProperties === undefined) {\n            var _this2 = _possibleConstructorReturn(this, (Token.__proto__ || Object.getPrototypeOf(Token)).call(this));\n        } else if (opt_initialProperties instanceof Object) {\n            var superInitialProperties = Object.create(opt_initialProperties);\n            superInitialProperties.parentNode = opt_initialProperties.parentToken;\n            superInitialProperties.childNodes = opt_initialProperties.childTokens;\n\n            var _this2 = _possibleConstructorReturn(this, (Token.__proto__ || Object.getPrototypeOf(Token)).call(this, superInitialProperties));\n        } else {\n            throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        }\n        return _possibleConstructorReturn(_this2);\n    }\n\n    _createClass(Token, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? _get(Token.prototype.__proto__ || Object.getPrototypeOf(Token.prototype), 'toString', this).call(this, true) : 'Token{' + _get(Token.prototype.__proto__ || Object.getPrototypeOf(Token.prototype), 'toString', this).call(this, true) + '}';\n        }\n    }]);\n\n    return Token;\n}(_SyntaxTree2.Node);\n\n;\nObject.defineProperties(Token.prototype, {\n    lexeme: { value: undefined, enumerable: true },\n    parentNodeClass_: { value: Token }\n});\n\nvar SymbolToken = exports.SymbolToken = function (_Token) {\n    _inherits(SymbolToken, _Token);\n\n    function SymbolToken(initialProperties) {\n        _classCallCheck(this, SymbolToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this3 = _possibleConstructorReturn(this, (SymbolToken.__proto__ || Object.getPrototypeOf(SymbolToken)).call(this, initialProperties));\n\n        if (initialProperties.symbol) {\n            if (!(initialProperties.symbol instanceof _LatexStyle.Symbol)) throw new TypeError('\"initialProperties.symbol\" isn\\'t a Symbol instance');\n            Object.defineProperty(_this3, 'symbol', { value: initialProperties.symbol, enumerable: true });\n        } else {\n            if (typeof initialProperties.pattern !== 'string') throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\n            Object.defineProperty(_this3, 'pattern', { value: initialProperties.pattern });\n        }\n        return _this3;\n    }\n\n    _createClass(SymbolToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = '';\n            var iParameter = 0;\n            var pattern = this.pattern;\n            for (var nPatternChars = pattern.length, iPatternChar = 0; iPatternChar < nPatternChars; ++iPatternChar) {\n                var patternChar = pattern[iPatternChar];\n                if (patternChar === '#') {\n                    ++iPatternChar;\n                    var parameterToken = this.childNode(iParameter++);\n                    source += parameterToken ? parameterToken.toString(true) : '??';\n                } else {\n                    source += patternChar;\n                }\n            }\n            return skipNodeClass ? source : 'SymbolToken' + (this.symbol ? '' : '[?]') + '{' + source + '}';\n        }\n    }, {\n        key: 'lexeme',\n        get: function get() {\n            return this.symbol ? this.symbol.lexeme : undefined;\n        }\n    }, {\n        key: 'pattern',\n        get: function get() {\n            return (0, _Utils.mustNotBeUndefined)(this.symbol).pattern;\n        }\n    }]);\n\n    return SymbolToken;\n}(Token);\n\n;\nObject.defineProperties(SymbolToken.prototype, {\n    symbol: { value: undefined, enumerable: true }\n});\nObject.defineProperties(SymbolToken.prototype, {\n    pattern: { enumerable: true }\n});\n\nvar ParameterToken = exports.ParameterToken = function (_Token2) {\n    _inherits(ParameterToken, _Token2);\n\n    function ParameterToken(initialProperties) {\n        _classCallCheck(this, ParameterToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this4 = _possibleConstructorReturn(this, (ParameterToken.__proto__ || Object.getPrototypeOf(ParameterToken)).call(this, initialProperties));\n\n        if (!initialProperties.hasBrackets) Object.defineProperty(_this4, 'hasBrackets', { value: false, enumerable: true });\n        if (initialProperties.hasSpacePrefix) Object.defineProperty(_this4, 'hasSpacePrefix', { value: true, enumerable: true });\n        return _this4;\n    }\n\n    _createClass(ParameterToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = this.hasSpacePrefix ? ' ' : '';\n            source += this.hasBrackets ? '{' + _get(ParameterToken.prototype.__proto__ || Object.getPrototypeOf(ParameterToken.prototype), 'toString', this).call(this, true) + '}' : _get(ParameterToken.prototype.__proto__ || Object.getPrototypeOf(ParameterToken.prototype), 'toString', this).call(this, true);\n            return skipNodeClass ? source : 'ParameterToken{' + source + '}';\n        }\n    }, {\n        key: 'lexeme',\n        get: function get() {\n            if (this.parameter && this.parameter.lexeme) return this.parameter.lexeme;\n        }\n    }, {\n        key: 'parameter',\n        get: function get() {\n            var symbolToken = this.parentNode;\n            var symbol = (0, _Utils.mustNotBeUndefined)(symbolToken.symbol);\n            var parameterIndex = symbolToken.childIndex(this);\n            if (symbolToken !== undefined && parameterIndex !== undefined && parameterIndex >= 0) return symbol.parameter(parameterIndex);\n        }\n    }]);\n\n    return ParameterToken;\n}(Token);\n\n;\nObject.defineProperties(ParameterToken.prototype, {\n    hasBrackets: { value: true, enumerable: true },\n    hasSpacePrefix: { value: false, enumerable: true },\n    parentNodeClass_: { value: SymbolToken }\n});\nObject.defineProperties(ParameterToken.prototype, {\n    parameter: { enumerable: true }\n});\n\nvar CommandToken = exports.CommandToken = function (_SymbolToken) {\n    _inherits(CommandToken, _SymbolToken);\n\n    function CommandToken(initialProperties) {\n        _classCallCheck(this, CommandToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n        var superInitialProperties = Object.create(initialProperties);\n        if (initialProperties.command) {\n            if (!(initialProperties.command instanceof _LatexStyle.Command)) throw new TypeError('\"initialProperties.command\" isn\\'t a LatexStyle.Command instance');\n            superInitialProperties.symbol = initialProperties.command;\n\n            var _this5 = _possibleConstructorReturn(this, (CommandToken.__proto__ || Object.getPrototypeOf(CommandToken)).call(this, superInitialProperties));\n        } else {\n            if (typeof initialProperties.name !== 'string') throw new TypeError('\"initialProperties.name\" isn\\'t a string');\n            superInitialProperties.pattern = '';\n\n            var _this5 = _possibleConstructorReturn(this, (CommandToken.__proto__ || Object.getPrototypeOf(CommandToken)).call(this, superInitialProperties));\n\n            Object.defineProperty(_this5, 'name', { value: initialProperties.name });\n        }\n        return _possibleConstructorReturn(_this5);\n    }\n\n    _createClass(CommandToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = '\\\\' + this.name + _get(CommandToken.prototype.__proto__ || Object.getPrototypeOf(CommandToken.prototype), 'toString', this).call(this, true);\n            return skipNodeClass ? source : 'CommandToken' + (this.command ? '' : '[?]') + '{' + source + '}';\n        }\n    }, {\n        key: 'command',\n        get: function get() {\n            return (0, _LatexStyle.mustBeCommand)(this.symbol);\n        }\n    }, {\n        key: 'name',\n        get: function get() {\n            return this.command.name;\n        }\n    }]);\n\n    return CommandToken;\n}(SymbolToken);\n\n;\nObject.defineProperties(CommandToken.prototype, {\n    command: { enumerable: true },\n    name: { enumerable: true }\n});\nfunction isCommandToken(x) {\n    return x && x instanceof CommandToken;\n}\n\nvar EnvironmentToken = exports.EnvironmentToken = function (_Token3) {\n    _inherits(EnvironmentToken, _Token3);\n\n    function EnvironmentToken(initialProperties) {\n        _classCallCheck(this, EnvironmentToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this6 = _possibleConstructorReturn(this, (EnvironmentToken.__proto__ || Object.getPrototypeOf(EnvironmentToken)).call(this, initialProperties));\n\n        if (!(initialProperties.environment instanceof _LatexStyle.Environment)) throw new TypeError('\"initialProperties.environment\" isn\\'t a LatexStyle.Environment instance');\n        Object.defineProperty(_this6, 'environment', {\n            value: initialProperties.environment,\n            enumerable: true\n        });\n        return _this6;\n    }\n\n    _createClass(EnvironmentToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var beginCommandToken = this.beginCommandToken;\n            var endCommandToken = this.endCommandToken;\n            var bodyToken = this.bodyToken;\n            var source = '\\\\begin{' + this.environment.name + '}';\n            source += beginCommandToken ? SymbolToken.prototype.toString.call(beginCommandToken, true) : '??';\n            source += bodyToken ? bodyToken.toString(true) : '??';\n            source += '\\\\end{' + this.environment.name + '}';\n            source += endCommandToken ? SymbolToken.prototype.toString.call(endCommandToken, true) : '??';\n            return skipNodeClass ? source : 'EnvironmentToken{' + source + '}';\n        }\n    }, {\n        key: 'lexeme',\n        get: function get() {\n            return this.environment.lexeme;\n        }\n    }, {\n        key: 'beginCommandToken',\n        get: function get() {\n            var beginCommandToken = this.childNode(0);\n            return beginCommandToken instanceof CommandToken ? beginCommandToken : undefined;\n        }\n    }, {\n        key: 'endCommandToken',\n        get: function get() {\n            var endCommandToken = this.childNode(2);\n            return endCommandToken instanceof CommandToken ? endCommandToken : undefined;\n        }\n    }, {\n        key: 'bodyToken',\n        get: function get() {\n            var bodyToken = this.childNode(1);\n            return bodyToken instanceof EnvironmentBodyToken ? bodyToken : undefined;\n        }\n    }]);\n\n    return EnvironmentToken;\n}(Token);\n\n;\nObject.defineProperties(EnvironmentToken.prototype, {\n    beginToken: { enumerable: true },\n    endToken: { enumerable: true }\n});\nfunction mustBeEnvironmentToken(x) {\n    if (!isEnvironmentToken(x)) throw new Error();\n    return x;\n}\nfunction isEnvironmentToken(x) {\n    return x instanceof EnvironmentToken;\n}\nfunction getBeginCommandToken(x) {\n    if (isCommandToken(x.beginCommandToken)) return x.beginCommandToken;\n}\nfunction getEndCommandToken(x) {\n    if (isCommandToken(x.endCommandToken)) return x.endCommandToken;\n}\nfunction getEnvironment(x) {\n    if (x.environment && (0, _LatexStyle.isEnvironment)(x.environment)) return x.environment;\n}\n\nvar EnvironmentBodyToken = exports.EnvironmentBodyToken = function (_Token4) {\n    _inherits(EnvironmentBodyToken, _Token4);\n\n    function EnvironmentBodyToken() {\n        _classCallCheck(this, EnvironmentBodyToken);\n\n        return _possibleConstructorReturn(this, (EnvironmentBodyToken.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken)).apply(this, arguments));\n    }\n\n    _createClass(EnvironmentBodyToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? _get(EnvironmentBodyToken.prototype.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken.prototype), 'toString', this).call(this, true) : 'EnvironmentBodyToken{' + _get(EnvironmentBodyToken.prototype.__proto__ || Object.getPrototypeOf(EnvironmentBodyToken.prototype), 'toString', this).call(this, true) + '}';\n        }\n    }, {\n        key: 'environment',\n        get: function get() {\n            return this.parentNode && getEnvironment(this.parentNode);\n        }\n    }, {\n        key: 'environmentToken',\n        get: function get() {\n            return this.parentNode && mustBeEnvironmentToken(this.parentNode);\n        }\n    }, {\n        key: 'beginCommandToken',\n        get: function get() {\n            return this.parentNode && getBeginCommandToken(this.parentNode);\n        }\n    }, {\n        key: 'endCommandToken',\n        get: function get() {\n            return this.parentNode && getEndCommandToken(this.parentNode);\n        }\n    }]);\n\n    return EnvironmentBodyToken;\n}(Token);\n\n;\nObject.defineProperties(EnvironmentBodyToken.prototype, {\n    parentNodeClass_: { value: EnvironmentToken }\n});\n\nvar SpaceToken = exports.SpaceToken = function (_Token5) {\n    _inherits(SpaceToken, _Token5);\n\n    function SpaceToken(initialProperties) {\n        _classCallCheck(this, SpaceToken);\n\n        if (initialProperties === undefined) {\n            var _this8 = _possibleConstructorReturn(this, (SpaceToken.__proto__ || Object.getPrototypeOf(SpaceToken)).call(this));\n\n            return _possibleConstructorReturn(_this8);\n        } else if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this8 = _possibleConstructorReturn(this, (SpaceToken.__proto__ || Object.getPrototypeOf(SpaceToken)).call(this, initialProperties));\n\n        if (initialProperties.lineBreakCount) {\n            if (!isFinite(initialProperties.lineBreakCount) || initialProperties.lineBreakCount < 0) throw new TypeError('\"initialProperties.lineBreakCount\" isn\\'t a non-negative number');\n            Object.defineProperty(_this8, 'lineBreakCount', {\n                value: initialProperties.lineBreakCount,\n                enumerable: true\n            });\n        }\n        return _possibleConstructorReturn(_this8);\n    }\n\n    _createClass(SpaceToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            if (skipNodeClass) {\n                switch (this.lineBreakCount) {\n                    case 0:\n                        return ' ';\n                    case 1:\n                        return '\\n';\n                    default:\n                        return '\\n\\n';\n                }\n            } else {\n                switch (this.lineBreakCount) {\n                    case 0:\n                        return 'SpaceToken{ }';\n                    case 1:\n                        return 'SpaceToken{\\n}';\n                    default:\n                        return 'SpaceToken{\\n\\n}';\n                }\n            }\n        }\n    }, {\n        key: 'lexeme',\n        get: function get() {\n            return this.lineBreakCount <= 1 ? \"SPACE\" : \"PARAGRAPH_SEPARATOR\";\n        }\n    }]);\n\n    return SpaceToken;\n}(Token);\n\n;\nObject.defineProperties(SpaceToken.prototype, {\n    lineBreakCount: { value: 0, enumerable: true }\n});\n\nvar SourceToken = exports.SourceToken = function (_Token6) {\n    _inherits(SourceToken, _Token6);\n\n    function SourceToken(initialProperties) {\n        _classCallCheck(this, SourceToken);\n\n        if (!(initialProperties instanceof Object)) throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\n\n        var _this9 = _possibleConstructorReturn(this, (SourceToken.__proto__ || Object.getPrototypeOf(SourceToken)).call(this, initialProperties));\n\n        if (!_Latex.Lexeme[initialProperties.lexeme]) throw new TypeError('\"initialProperties.lexeme\" isn\\'t known');\n        Object.defineProperty(_this9, 'lexeme', { value: initialProperties.lexeme, enumerable: true });\n        if (typeof initialProperties.source !== 'string') throw new TypeError('\"initialProperties.sources\" isn\\'t a string');\n        Object.defineProperty(_this9, 'source', { value: initialProperties.source, enumerable: true });\n        return _this9;\n    }\n\n    _createClass(SourceToken, [{\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            return skipNodeClass ? this.source : 'SourceToken[' + this.lexeme + ']{' + this.source + '}';\n        }\n    }]);\n\n    return SourceToken;\n}(Token);\n\n;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Node = exports.SyntaxTree = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Utils = __webpack_require__(0);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n'use strict';\n\nvar SyntaxTree = exports.SyntaxTree = function SyntaxTree(rootNode, source) {\n    _classCallCheck(this, SyntaxTree);\n\n    if (!(rootNode instanceof Node)) throw new TypeError('\"rootNode\" isn\\'t a SyntaxTree.Node instance');\n    if (rootNode.parentNode) throw new TypeError('\"rootNode\" has a parent node');\n    if (rootNode.tree) throw new TypeError('\"rootNode\" is a tree root');\n    if (typeof source !== 'string') throw new TypeError('\"sources\" isn\\'t a string');\n    Object.defineProperty(this, 'rootNode', { value: rootNode, enumerable: true });\n    Object.defineProperty(this, 'source', { value: source, enumerable: true });\n    Object.defineProperty(rootNode, 'tree', { value: this, enumerable: true });\n};\n\n;\n\nvar Node = exports.Node = function () {\n    function Node(opt_initialProperties) {\n        _classCallCheck(this, Node);\n\n        if (opt_initialProperties !== undefined) {\n            if (!(opt_initialProperties instanceof Object)) throw new TypeError('initialProperties isn\\'t an Object instance');\n            if (opt_initialProperties.childNodes !== undefined) {\n                if (!(opt_initialProperties.childNodes instanceof Array)) throw new TypeError('initialProperties.childNodes isn\\'t an Array instance');\n                opt_initialProperties.childNodes.forEach(this.insertChildSubtree, this);\n            }\n            var optParentNode = opt_initialProperties.parentNode;\n            if (optParentNode !== undefined) {\n                if (!!optParentNode) {\n                    optParentNode.insertChildSubtree(this);\n                } else {\n                    throw new TypeError('initialProperties.parentNode isn\\'t a SyntaxTree.Node instance');\n                }\n            }\n        }\n    }\n\n    _createClass(Node, [{\n        key: 'childNode',\n        value: function childNode(node) {\n            if ((0, _Utils.isNumber)(node)) return this.childNodes_[node] || undefined;\n            if (node instanceof Node) return node.parentNode === this ? node : undefined;\n            throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n        }\n    }, {\n        key: 'childIndex',\n        value: function childIndex(node) {\n            if ((0, _Utils.isNumber)(node)) return this.childNodes_[node] ? node : undefined;\n            if (node instanceof Node) return node.parentNode === this ? this.childNodes_.indexOf(node) : undefined;\n            throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\n        }\n    }, {\n        key: 'insertChildNode',\n        value: function insertChildNode(node, childIndex, childNodesToCover) {\n            if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n            if (node.parentNode) throw new TypeError('\"node\" has a parent');\n            if (node.tree) throw new TypeError('\"node\" is a tree root');\n            if (node.childNodes_.length) throw new TypeError('\"node\" has child nodes');\n            if (!this.hasOwnProperty('childNodes_')) Object.defineProperty(this, 'childNodes_', { value: [], configurable: true });\n            if (childIndex === undefined) childIndex = this.childNodes_.length;\n            if (childNodesToCover === undefined) childNodesToCover = 0;\n            var nodeChildNodes = this.childNodes_.splice(childIndex, childNodesToCover, node);\n            Object.defineProperty(this, 'subtreeSize', {\n                value: this.subtreeSize + 1,\n                enumerable: true,\n                configurable: true\n            });\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, 'subtreeSize', { value: parentNode.subtreeSize + 1 });\n            }\n            Object.defineProperty(node, 'parentNode', {\n                value: this,\n                enumerable: true,\n                configurable: true\n            });\n            if (nodeChildNodes.length) {\n                Object.defineProperty(node, 'childNodes_', { value: nodeChildNodes, configurable: true });\n                var subtreeSize = 1;\n                nodeChildNodes.forEach(function (nodeChildNode) {\n                    subtreeSize += nodeChildNode.subtreeSize;\n                });\n                Object.defineProperty(node, 'subtreeSize', {\n                    value: subtreeSize,\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n            return node;\n        }\n    }, {\n        key: 'insertChildSubtree',\n        value: function insertChildSubtree(node, childIndex) {\n            if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\n            if (node.parentNode) throw new TypeError('\"node\" has a parent');\n            if (node.tree) throw new TypeError('\"node\" is a tree root');\n            if (!this.hasOwnProperty('childNodes_')) Object.defineProperty(this, 'childNodes_', { value: [], configurable: true });\n            if (childIndex === undefined) childIndex = this.childNodes_.length;\n            this.childNodes_.splice(childIndex, 0, node);\n            var nodeSubtreeSize = node.subtreeSize;\n            Object.defineProperty(this, 'subtreeSize', {\n                value: this.subtreeSize + nodeSubtreeSize, enumerable: true, configurable: true\n            });\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, 'subtreeSize', {\n                    value: parentNode.subtreeSize + nodeSubtreeSize\n                });\n            }\n            Object.defineProperty(node, 'parentNode', {\n                value: this,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }, {\n        key: 'removeChildNode',\n        value: function removeChildNode(nodeOrNodeIndex) {\n            var _childNodes_;\n\n            var nodeChildIndex = this.childIndex(nodeOrNodeIndex);\n            if (nodeChildIndex === undefined) return undefined;\n            var node = this.childNodes_[nodeChildIndex];\n            (_childNodes_ = this.childNodes_).splice.apply(_childNodes_, [nodeChildIndex, 1].concat(_toConsumableArray(node.childNodes_)));\n            if (this.childNodes_.length) {\n                Object.defineProperty(this, 'subtreeSize', { value: this.subtreeSize - 1 });\n            } else {\n                delete this.childNodes_;\n                delete this.subtreeSize;\n            }\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, 'subtreeSize', { value: parentNode.subtreeSize - 1 });\n            }\n            delete node.parentNode;\n            delete node.childNodes_;\n            delete node.subtreeSize;\n            return node;\n        }\n    }, {\n        key: 'removeChildSubtree',\n        value: function removeChildSubtree(node) {\n            var nodeChildIndex = this.childIndex(node);\n            if (nodeChildIndex === undefined) return undefined;\n            node = this.childNodes_.splice(nodeChildIndex, 1)[0];\n            var nodeSubtreeSize = node.subtreeSize;\n            if (this.childNodes_.length) {\n                Object.defineProperty(this, 'subtreeSize', { value: this.subtreeSize - nodeSubtreeSize });\n            } else {\n                delete this.childNodes_;\n                delete this.subtreeSize;\n            }\n            for (var parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\n                Object.defineProperty(parentNode, 'subtreeSize', {\n                    value: parentNode.subtreeSize - nodeSubtreeSize\n                });\n            }\n            delete node.parentNode;\n            return node;\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            var skipNodeClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var source = '';\n            this.childNodes_.forEach(function (childNode) {\n                source += childNode.toString(true);\n            });\n            return skipNodeClass ? source : 'SourceTree.Node{' + source + '}';\n        }\n    }, {\n        key: 'childNodes',\n        get: function get() {\n            return this.childNodes_.slice();\n        }\n    }]);\n\n    return Node;\n}();\n\n;\nObject.defineProperties(Node.prototype, {\n    childNodes: { enumerable: true }\n});\nObject.defineProperties(Node.prototype, {\n    tree: { value: undefined, enumerable: true },\n    parentNode: { value: undefined, enumerable: true },\n    subtreeSize: { value: 1, enumerable: true },\n    childNodes_: { value: [], enumerable: false },\n    parentNodeClass_: { value: Node, enumerable: false }\n});\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Context = exports.LatexParser = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _LatexStyle = __webpack_require__(2);\n\nvar _LatexStyle2 = _interopRequireDefault(_LatexStyle);\n\nvar _LatexTree = __webpack_require__(3);\n\nvar _Latex = __webpack_require__(1);\n\nvar _Utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction parseCommentLine_(context) {\n    var commentMatch = context.source.substring(context.position).match(/^%([^\\n]*)(\\n[ \\t]*)?/);\n    if (!commentMatch) return false;\n    context.comments.push(commentMatch[1]);\n    context.position += commentMatch[0].length;\n    if (!commentMatch[2]) {\n        context.charNumber += commentMatch[0].length;\n    } else {\n        ++context.lineNumber;\n        context.charNumber = commentMatch[2].length - 1;\n    }\n    return true;\n}\nfunction processParsedToken_(context, token) {\n    if (context.currentToken) {\n        context.currentToken.insertChildSubtree(token);\n    }\n}\nfunction parseSpaceToken_(context) {\n    var isSpace = false;\n    var nLineBreaks = 0;\n    while (context.position < context.source.length) {\n        if (parseCommentLine_(context)) continue;\n        switch (context.source[context.position]) {\n            case ' ':\n            case '\\t':\n                isSpace = true;\n                ++context.position;\n                ++context.charNumber;\n                continue;\n            case '\\n':\n                isSpace = true;\n                ++nLineBreaks;\n                ++context.position;\n                ++context.lineNumber;\n                context.charNumber = 0;\n                continue;\n        }\n        break;\n    }\n    return isSpace ? new _LatexTree.SpaceToken({ lineBreakCount: nLineBreaks }) : undefined;\n}\n\nvar LatexParser = exports.LatexParser = function () {\n    function LatexParser(latexStyle) {\n        _classCallCheck(this, LatexParser);\n\n        if (!(latexStyle instanceof _LatexStyle2.default)) throw new TypeError('\"latexStyle\" isn\\'t a LatexStyle instance');\n        Object.defineProperty(this, 'latexStyle', { value: latexStyle, enumerable: true });\n    }\n\n    _createClass(LatexParser, [{\n        key: \"parse\",\n        value: function parse(source, opt_context) {\n            if (typeof source !== 'string') throw new TypeError('\"sources\" isn\\'t a string');\n            var context = void 0;\n            if (opt_context === undefined) {\n                context = new Context(source);\n            } else if (opt_context instanceof Context) {\n                context = opt_context;\n                context.source += source;\n            } else {\n                throw new TypeError('\"context\" isn\\'t a LatexParser.Context instance');\n            }\n            var parsedTokens = [];\n            while (true) {\n                var parsedToken = this.parseToken_(context);\n                if (parsedToken === undefined) break;\n                parsedTokens.push(parsedToken);\n            }\n            return parsedTokens;\n        }\n    }, {\n        key: \"parseToken_\",\n        value: function parseToken_(context) {\n            var token = parseSpaceToken_(context);\n            if (!token) {\n                if (context.position >= context.source.length) return undefined;\n                var contextBackup = context.copy();\n                if (!(token = this.parseEnvironmentToken_(context))) {\n                    contextBackup.copy(context);\n                    if (!(token = this.parseCommandToken_(context))) {\n                        contextBackup.copy(context);\n                        if (!(token = this.parseSymbolsToken_(context))) {\n                            return undefined;\n                        }\n                    }\n                }\n            }\n            processParsedToken_(context, token);\n            return token;\n        }\n    }, {\n        key: \"parseParameterToken_\",\n        value: function parseParameterToken_(context, parameter, opt_endLabel) {\n            var currentTokenBackup = context.currentToken;\n            context.updateState(parameter.operations);\n            if (opt_endLabel === undefined) {\n                var spacePrefixState = parseSpaceToken_(context) !== undefined;\n                if (context.source[context.position] === '{') {\n                    context.currentToken = new _LatexTree.ParameterToken({ hasBrackets: true, hasSpacePrefix: spacePrefixState });\n                    ++context.position;\n                    ++context.charNumber;\n                    if (!this.parseUntilLabel_(context, '}', parameter.lexeme)) return undefined;\n                    ++context.position;\n                    ++context.charNumber;\n                } else {\n                    context.currentToken = new _LatexTree.ParameterToken({ hasBrackets: false, hasSpacePrefix: spacePrefixState });\n                    if (this.parseToken_(context) === undefined) return undefined;\n                }\n            } else {\n                context.currentToken = new _LatexTree.ParameterToken({ hasBrackets: false, hasSpacePrefix: false });\n                if (!this.parseUntilLabel_(context, opt_endLabel, parameter.lexeme)) return undefined;\n            }\n            var parameterToken = context.currentToken;\n            context.currentToken = currentTokenBackup;\n            processParsedToken_(context, parameterToken);\n            return parameterToken;\n        }\n    }, {\n        key: \"parseEnvironmentToken_\",\n        value: function parseEnvironmentToken_(context) {\n            if (!context.source.startsWith('\\\\begin', context.position)) return undefined;\n            context.position += 6;\n            parseSpaceToken_(context);\n            var nameMatch = context.source.substring(context.position).match(/^{([\\w@]+\\*?)}/);\n            if (!nameMatch) return undefined;\n            var name = nameMatch[1];\n            context.position += nameMatch[0].length;\n            context.charNumber += nameMatch[0].length;\n            var currentTokenBackup = context.currentToken;\n            var environment = this.latexStyle.environments(context.currentState, name)[0];\n            var environmentToken = context.currentToken = environment ? new _LatexTree.EnvironmentToken({ environment: environment.environment }) : new _LatexTree.EnvironmentToken({ name: name });\n            var symbols = this.latexStyle.commands(context.currentState, name);\n            var beginCommandToken = this.parsePatterns_(context, symbols);\n            if (beginCommandToken === undefined) {\n                beginCommandToken = new _LatexTree.CommandToken({ name: name });\n            }\n            processParsedToken_(context, beginCommandToken);\n            var environmentBodyToken = context.currentToken = new _LatexTree.EnvironmentBodyToken();\n            var endFound = this.parseUntilLabel_(context, '\\\\end{' + name + '}');\n            context.currentToken = environmentToken;\n            processParsedToken_(context, environmentBodyToken);\n            var endCommandToken = undefined;\n            if (endFound) {\n                context.position += name.length + 6;\n                context.charNumber += name.length + 6;\n                endCommandToken = this.parsePatterns_(context, this.latexStyle.commands(context.currentState, 'end' + name));\n            } else {}\n            if (endCommandToken === undefined) {\n                endCommandToken = new _LatexTree.CommandToken({ name: 'end' + name });\n            }\n            processParsedToken_(context, endCommandToken);\n            context.currentToken = currentTokenBackup;\n            return environmentToken;\n        }\n    }, {\n        key: \"parseCommandToken_\",\n        value: function parseCommandToken_(context) {\n            var cmdMatch = context.source.substring(context.position).match(/^\\\\([\\w@]+\\*?)/);\n            if (!cmdMatch) return undefined;\n            context.position += cmdMatch[0].length;\n            context.charNumber += cmdMatch[0].length;\n            var token = this.parsePatterns_(context, this.latexStyle.commands(context.currentState, cmdMatch[1]));\n            if (token === undefined) {\n                token = new _LatexTree.CommandToken({ name: cmdMatch[1] });\n            }\n            return token;\n        }\n    }, {\n        key: \"parseSymbolsToken_\",\n        value: function parseSymbolsToken_(context) {\n            var sourceCharacter = context.source[context.position];\n            var token = this.parsePatterns_(context, this.latexStyle.symbols(context.currentState, sourceCharacter));\n            if (token === undefined) {\n                ++context.position;\n                ++context.charNumber;\n                token = new _LatexTree.SymbolToken({ pattern: sourceCharacter });\n            } else {}\n            return token;\n        }\n    }, {\n        key: \"parsePatterns_\",\n        value: function parsePatterns_(context, symbols) {\n            var _this = this;\n\n            var contextBackup = context.copy();\n            var token = undefined;\n            symbols.some(function (symbol) {\n                if (token = _this.parsePattern_(context, symbol)) {\n                    return true;\n                } else {\n                    contextBackup.copy(context);\n                    return false;\n                }\n            });\n            return token;\n        }\n    }, {\n        key: \"parsePattern_\",\n        value: function parsePattern_(context, symbol) {\n            var currentTokenBackup = context.currentToken;\n            context.currentToken = symbol instanceof _LatexStyle.Command ? new _LatexTree.CommandToken({ command: symbol }) : new _LatexTree.SymbolToken({ symbol: symbol });\n            var patternComponents = symbol.patternComponents;\n            var nPatternComponents = patternComponents.length;\n            var iPatternComponent = 0;\n            for (; iPatternComponent < nPatternComponents; ++iPatternComponent) {\n                var patternComponent = patternComponents[iPatternComponent];\n                if ((0, _Utils.isNumber)(patternComponent)) {\n                    var parameter = symbol.parameter(patternComponent);\n                    var parameterEndLabel = patternComponents[iPatternComponent + 1];\n                    if (typeof parameterEndLabel === 'string') {\n                        if (this.parseParameterToken_(context, (0, _Utils.mustNotBeUndefined)(parameter), parameterEndLabel)) {\n                            if (!context.source.startsWith(parameterEndLabel, context.position)) return undefined;\n                            context.position += parameterEndLabel.length;\n                            context.charNumber += parameterEndLabel.length;\n                            ++iPatternComponent;\n                            continue;\n                        }\n                    } else {\n                        if (this.parseParameterToken_(context, (0, _Utils.mustNotBeUndefined)(parameter))) continue;\n                    }\n                } else if ((0, _Utils.isString)(patternComponent)) {\n                    while (parseCommentLine_(context)) {}\n                    if (context.source.startsWith(patternComponent, context.position)) {\n                        context.position += patternComponent.length;\n                        context.charNumber += patternComponent.length;\n                        continue;\n                    }\n                } else if (parseSpaceToken_(context)) continue;\n                break;\n            }\n            if (iPatternComponent < nPatternComponents) return undefined;\n            var parsedToken = context.currentToken;\n            context.currentToken = currentTokenBackup;\n            context.updateState(symbol.operations);\n            return parsedToken;\n        }\n    }, {\n        key: \"parseUntilLabel_\",\n        value: function parseUntilLabel_(context, endLabel, opt_lexeme) {\n            switch (opt_lexeme) {\n                default:\n                    {\n                        while (!context.source.startsWith(endLabel, context.position)) {\n                            if (context.position >= context.source.length) {\n                                return false;\n                            }\n                            this.parseToken_(context);\n                        }\n                        return true;\n                    }\n            }\n        }\n    }]);\n\n    return LatexParser;\n}();\n\n;\n\nvar Context = exports.Context = function () {\n    function Context() {\n        var opt_source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n        _classCallCheck(this, Context);\n\n        this.source = opt_source || '';\n        this.position = 0;\n        this.lineNumber = 0;\n        this.charNumber = 0;\n        this.currentToken = undefined;\n        this.currentState = new _Latex.State();\n        this.stateStack = [];\n        this.comments = [];\n    }\n\n    _createClass(Context, [{\n        key: \"copy\",\n        value: function copy(opt_target) {\n            var target = opt_target || new Context();\n            target.source = this.source;\n            target.position = this.position;\n            target.lineNumber = this.lineNumber;\n            target.charNumber = this.charNumber;\n            target.currentToken = this.currentToken;\n            target.currentState = this.currentState.copy();\n            target.stateStack = this.stateStack.slice();\n            target.comments = this.comments.slice();\n            return target;\n        }\n    }, {\n        key: \"updateState\",\n        value: function updateState(operations) {\n            var _this2 = this;\n\n            if (!(operations instanceof Array)) throw new TypeError('\"operations\" isn\\'t an Array instance');\n            var newModeStates = {};\n            operations.forEach(function (operation) {\n                switch (operation.directive) {\n                    case _Latex.Directive.BEGIN:\n                        switch (operation.operand) {\n                            case _Latex.GROUP:\n                                _this2.currentState.update(newModeStates);\n                                newModeStates = {};\n                                _this2.stateStack.push(_this2.currentState.copy());\n                                break;\n                            default:\n                                newModeStates[operation.operand] = true;\n                        }\n                        break;\n                    case _Latex.Directive.END:\n                        switch (operation.operand) {\n                            case _Latex.GROUP:\n                                newModeStates = {};\n                                if (_this2.stateStack.length < 1) throw new Error('state stack is empty');\n                                _this2.currentState = (0, _Utils.mustNotBeUndefined)(_this2.stateStack.pop());\n                                break;\n                            default:\n                                newModeStates[operation.operand] = false;\n                        }\n                        break;\n                }\n            });\n            this.currentState.update(newModeStates);\n        }\n    }]);\n\n    return Context;\n}();\n\n;\nexports.default = LatexParser;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Utils = __webpack_require__(0);\n\nObject.keys(_Utils).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Utils[key];\n    }\n  });\n});\n\nvar _Latex = __webpack_require__(1);\n\nObject.keys(_Latex).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Latex[key];\n    }\n  });\n});\n\nvar _LatexStyle = __webpack_require__(2);\n\nObject.keys(_LatexStyle).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _LatexStyle[key];\n    }\n  });\n});\n\nvar _SyntaxTree = __webpack_require__(4);\n\nObject.keys(_SyntaxTree).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _SyntaxTree[key];\n    }\n  });\n});\n\nvar _LatexTree = __webpack_require__(3);\n\nObject.keys(_LatexTree).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _LatexTree[key];\n    }\n  });\n});\n\nvar _LatexParser = __webpack_require__(5);\n\nObject.keys(_LatexParser).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _LatexParser[key];\n    }\n  });\n});\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// latex-parser.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c3daba75bdea758aa830","/**\r\n * @fileoverview General JavaScript utils\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\nexport type StringMap = {[s:string]:string};\r\n\r\nexport type TargetObject = any;\r\nexport type ValuesObject = any;\r\n\r\nexport type OptKeys = StringMap | string[];\r\n\r\nexport interface OptAttributes {\r\n  writable: boolean;\r\n  enumerable: boolean;\r\n  configurable: boolean;\r\n}\r\n/**\r\n * Update object properties by property values\r\n * @param {!Object} target the object to copy properties to\r\n * @param {!Object} values the object with property values (undefined values will be skipped)\r\n * @param {(!Object.<string,string>|!Array.<string>)=} opt_keys\r\n *        list of keys or map of the target keys to the property names, all the enumerable\r\n *        properties will be used if undefined\r\n * @param {{writable:boolean,enumerable:boolean,configurable:boolean}=} opt_attributes\r\n *        property attributes, { writable: true, enumerable: true, configurable: true } by default\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport function updateProperties(target: TargetObject,\r\n                                 values: ValuesObject,\r\n                                 opt_keys?: OptKeys,\r\n                                 opt_attributes: OptAttributes = { writable: true, enumerable: true, configurable: true }) {\r\n  if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\r\n  if (values === undefined) return; // do noting is the sources is undefined\r\n  if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\r\n  if (opt_attributes === undefined) {\r\n    opt_attributes = { writable: true, enumerable: true, configurable: true };\r\n  } else if (!(opt_attributes instanceof Object)) {\r\n    throw new TypeError('\"attributes\" isn\\'t an Object instance')\r\n  }\r\n  if (opt_keys === undefined) { // if the key map isn't defined\r\n    for (let key in values) { // for all the enumerable properties\r\n      //noinspection JSUnfilteredForInLoop\r\n      if (values[key] !== undefined) {\r\n        //noinspection JSUnfilteredForInLoop\r\n        Object.defineProperty(target, key, // update the property\r\n          // using the defined value\r\n          Object.create(opt_attributes, { value: { value: values[key] } })\r\n        );\r\n      }\r\n    }\r\n  } else if (opt_keys instanceof Array) { // if the list of the keys is defined\r\n    opt_keys.forEach(key => { if (values[key] !== undefined) {\r\n      Object.defineProperty(target, key, // update the property\r\n        Object.create(opt_attributes, {value: {value: values[key]}}) // using the defined value\r\n      );\r\n    }});\r\n  } else if (opt_keys instanceof Object) { // if the map of the keys is defined\r\n    for (let targetKey in opt_keys) { // for all the target keys\r\n      //noinspection JSUnfilteredForInLoop\r\n      let key = opt_keys[targetKey]; // the sources key\r\n      if (values[key] !== undefined)\r\n        //noinspection JSUnfilteredForInLoop\r\n        Object.defineProperty(target, targetKey, // update the property\r\n          // using the defined value\r\n          Object.create(opt_attributes, { value: { value: values[key] } })\r\n        );\r\n    }\r\n  } else { // if \"keys\" has unsupported value\r\n    throw new TypeError('\"keys\" isn\\'t an Object instance');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Test object properties with property values (strict comparing is used)\r\n * @param {!Object} target the object with properties to test\r\n * @param {?Object} values the object with property values (undefined values will be skipped)\r\n * @param {?(Object.<string,string>|Array.<string>)} opt_keys\r\n *        list of keys or map of the target keys to the property names, all the enumerable\r\n *        properties will be used if undefined\r\n * @param {boolean=true} opt_skipUndefined true to skip keys with undefined values, false otherwise\r\n * @return {boolean} true if all the defined properties are the same false otherwise\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport function testProperties(target: TargetObject,\r\n                               values?: ValuesObject,\r\n                               opt_keys?: OptKeys,\r\n                               opt_skipUndefined: boolean = true) {\r\n  if (!(target instanceof Object)) throw new TypeError('\"target\" isn\\'t an Object instance');\r\n  if (values === undefined) return true; // do noting is the sources is undefined\r\n  if (!(values instanceof Object)) throw new TypeError('\"properties\" isn\\'t an Object instance');\r\n  if (opt_skipUndefined === undefined) opt_skipUndefined = true; // skip undefined by default\r\n\r\n  if (opt_keys === undefined) { // if the key map isn't defined\r\n    for (let key in values) { // for all the enumerable properties\r\n      if (target[key] !== values[key] && !(values[key] === undefined && opt_skipUndefined))\r\n        return false; // false if any value is different\r\n    }\r\n  } else if (opt_keys instanceof Array) { // if the list of the keys is defined\r\n    return opt_keys.every(key => {\r\n      return target[key] === values[key] || (values[key] === undefined && opt_skipUndefined);\r\n    });\r\n  } else if (opt_keys instanceof Object) { // if the map of the keys is defined\r\n    for (let targetKey in opt_keys) { // for all the target keys\r\n      let key = opt_keys[targetKey]; // the sources key\r\n      if (target[targetKey] !== values[key] && !(values[key] === undefined && opt_skipUndefined))\r\n        return false; // false if any value is different\r\n    }\r\n  } else { // if \"keys\" has unsupported value\r\n    throw new TypeError('\"keys\" isn\\'t an Object instance');\r\n  }\r\n  return true; // return true if all the defined properties are the same\r\n};\r\n\r\n\r\nexport function isNumber(x: any): x is number {\r\n  return typeof x === \"number\"\r\n}\r\n\r\nexport function isString(x: any): x is string {\r\n  return typeof x === \"string\"\r\n}\r\n\r\nexport function mustNotBeUndefined<T>(x?: T): T {\r\n  if(!x) throw new Error();\r\n  return x;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Utils.ts","/**\r\n * @fileoverview General LaTeX definitions\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\n'use strict';\r\n\r\n/**@module */\r\n\r\n\r\n\r\n/**\r\n * LaTeX lexeme\r\n * @enum {string}\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport const Lexeme = {\r\n  BINARY_OPERATOR:     'BINARY_OPERATOR',     // mathematical binary operator\r\n  BRACKETS:            'BRACKETS',            // logical brackets\r\n  CELL_SEPARATOR:      'CELL_SEPARATOR',      // table cell separator\r\n  CHAR:                'CHAR',                // character\r\n  DIGIT:               'DIGIT',               // digit\r\n  DIRECTIVE:           'DIRECTIVE',           // LaTeX directive\r\n  DISPLAY_EQUATION:    'DISPLAY_EQUATION',    // mathematical equation for display mode\r\n  FILE_PATH:           'FILE_PATH',           // file system path\r\n  FLOATING_BOX:        'FLOATING_BOX',        // floating box\r\n  HORIZONTAL_SKIP:     'HORIZONTAL_SKIP',     // any type of horizontal skip but not space\r\n  INLINE_EQUATION:     'INLINE_EQUATION',     // mathematical equation for inline mode\r\n  LABEL:               'LABEL',               // label identifier\r\n  LENGTH:              'LENGTH',              // linear dimension\r\n  LETTER:              'LETTER',              // word letter\r\n  LINE_BREAK:          'LINE_BREAK',          // text line break\r\n  LIST_ITEM:           'LIST_ITEM',           // list item\r\n  LIST:                'LIST',                // list of items\r\n  NUMBER:              'NUMBER',              // sequence of digits\r\n  PARAGRAPH_SEPARATOR: 'PARAGRAPH_SEPARATOR', // paragraph separator\r\n  PICTURE:             'PICTURE',             // picture\r\n  POST_OPERATOR:       'POST_OPERATOR',       // mathematical post-operator\r\n  PRE_OPERATOR:        'PRE_OPERATOR',        // mathematical pre-operator\r\n  RAW:                 'RAW',                 // unprocessable or raw sources\r\n  SPACE:               'SPACE',               // any type of space equivalent\r\n  SUBSCRIPT:           'SUBSCRIPT',           // subscript text\r\n  SUPERSCRIPT:         'SUPERSCRIPT',         // subscript text\r\n  TABLE:               'TABLE',               // table\r\n  TABULAR_PARAMETERS:  'TABULAR_PARAMETERS',  // LaTeX tabular parameters\r\n  TAG:                 'TAG',                 // formatting tag\r\n  UNKNOWN:             'UNKNOWN',             // unrecognized element\r\n  VERTICAL_SKIP:       'VERTICAL_SKIP',       // any type of vertical skip\r\n  WORD:                'WORD',                // sequence of letters\r\n  WRAPPER:             'WRAPPER'              // wrapper for something\r\n};\r\nexport type Lexeme = keyof typeof Lexeme;\r\n\r\n/**\r\n * LaTeX modes\r\n * @enum {string}\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport const modes = {\r\n  LIST:     'LIST',    // list of items\r\n  MATH:     'MATH',    // mathematical expressionLatex\r\n  PICTURE:  'PICTURE', // picture\r\n  TABLE:    'TABLE',   // LaTeX tabular\r\n  TEXT:     'TEXT',    // general text\r\n  VERTICAL: 'VERTICAL' // vertical spacing\r\n};\r\n\r\nexport type Mode = keyof typeof modes;\r\n\r\nexport function isMode(x: any): x is Mode {\r\n  return modes.hasOwnProperty(x);\r\n}\r\n\r\nexport function mustBeMode(x: any): Mode {\r\n  if(!isMode(x)) throw new Error();\r\n  return x;\r\n}\r\n\r\nexport type ModeStates = {[mode: string]: boolean};\r\n/**\r\n * LaTeX state encapsulation\r\n * @class\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport class State {\r\n  private modeStates_: ModeStates;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!Object.<Mode,boolean>=} opt_initialModeStates the initial mode states\r\n   * @constructor\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  constructor(opt_initialModeStates: ModeStates = {}) {\r\n    Object.defineProperty(this, 'modeStates_', { value: { }, enumerable: false });\r\n\r\n    this.modeStates_[modes.LIST]     = false;\r\n\r\n    this.modeStates_[modes.MATH]     = false;\r\n\r\n    this.modeStates_[modes.PICTURE]  = false;\r\n\r\n    this.modeStates_[modes.TABLE]    = false;\r\n\r\n    this.modeStates_[modes.TEXT]     = true;\r\n    //noinspection JSUnresolvedVariable\r\n    this.modeStates_[modes.VERTICAL] = false;\r\n    // update the mode states\r\n    if (opt_initialModeStates !== undefined) this.update(opt_initialModeStates);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Create a copy of this state.\r\n   * @return {!State} the created copy\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  copy() {\r\n    //noinspection JSValidateTypes,JSUnresolvedVariable\r\n    return new State(this.modeStates_);\r\n  }\r\n\r\n\r\n  /**\r\n   * Update the state with states for modes\r\n   * @param {!Object.<Mode,boolean>} modeStates the states for modes\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  update(modeStates: ModeStates) {\r\n    for (let modeKey in modeStates) { // for all the given modes\r\n      //noinspection JSUnfilteredForInLoop\r\n      let mode = modes[mustBeMode(modeKey)]; // verify the mode key\r\n      if (mode === undefined) // if the mode is unknown\r\n        throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\r\n      //noinspection JSUnfilteredForInLoop,JSUnresolvedVariable\r\n      this.modeStates_[mode] = modeStates[modeKey]; // store the mode state\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Test the state with mode states\r\n   * @param {!Object.<Mode,boolean>} modeStates the states for modes\r\n   * @return {boolean} true if the state fits the modes, false otherwise\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  test(modeStates: ModeStates) {\r\n    for (let modeKey in modeStates) { // for all the given modes\r\n      let mode = modes[mustBeMode(modeKey)]; // verify the mode key\r\n      if (mode === undefined) // if the mode is unknown\r\n        throw new TypeError('\"modeStates[' + modeKey + ']\" isn\\'t a Latex.Mode option');\r\n      // exit if the mode has different states\r\n      if (this.modeStates_[mode] !== modeStates[modeKey]) return false;\r\n    }\r\n    return true;\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * LaTeX directive\r\n * @enum {string}\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport const Directive = {\r\n  BEGIN: 'BEGIN', // begin something\r\n  END:   'END'    // end something\r\n};\r\nexport type Directive = keyof typeof Directive;\r\n\r\n\r\n/**\r\n * Group operand for directives\r\n * @const {string}\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport const GROUP = 'GROUP';\r\nexport type GROUP = 'GROUP';\r\n\r\n\r\n\r\n/**\r\n * LaTeX operation properties\r\n * @interface OperationProperties\r\n * @property {Directive} directive - The directive or undefined if there is no a directive\r\n * @property {Mode|GROUP} operand - The operand or undefined if there is no an operand\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport interface OperationProperties {\r\n  directive: Directive;\r\n  operand: Mode|GROUP;\r\n}\r\nexport function isOperationProperties(x: any): x is OperationProperties {\r\n  return x && x.hasOwnProperty(\"directive\") && x.hasOwnProperty(\"operand\");\r\n}\r\n\r\nexport function mustBeOperationProperties(x: any): OperationProperties {\r\n  if(!isOperationProperties(x)) throw new Error();\r\n  return x;\r\n}\r\n\r\n/**\r\n * LaTeX operation encapsulation\r\n * @class\r\n * @property {Directive} directive - The directive or undefined if there is no a directive\r\n * @property {Mode|GROUP} operand - The operand or undefined if there is no an operand\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport class Operation {\r\n  directive: Directive;\r\n  operand: Mode | GROUP;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!OperationProperties=} opt_initialProperties the initial property values\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  constructor(opt_initialProperties?: OperationProperties) {\r\n    // do nothing if the initial properties aren't defined\r\n    if (opt_initialProperties === undefined) return;\r\n    if (!(opt_initialProperties instanceof Object))\r\n      throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\r\n    let directive = Directive[opt_initialProperties.directive]; // validate the directive\r\n    if (!directive)\r\n      throw new TypeError('\"initialProperties.directive\" isn\\'t an Latex.Directive option');\r\n    Object.defineProperty(this, 'directive', { value: directive, enumerable: true });\r\n    switch (opt_initialProperties.operand) {\r\n    case GROUP: // if operand is a group\r\n      // store the operand\r\n      Object.defineProperty(this, 'operand', { value: GROUP, enumerable: true });\r\n      break;\r\n    default:\r\n      let mode = modes[opt_initialProperties.operand]; // validate the operand as a mode\r\n      if (!mode) throw new TypeError('\"initialProperties.operand\" isn\\'t an Latex.Mode option');\r\n      // store the operand\r\n      Object.defineProperty(this, 'operand', { value: mode, enumerable: true });\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Compare this operation with the other\r\n   * @param {!Operation} other the operation to compare with\r\n   * @return {boolean} True if the operations are equal false otherwise\r\n   * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Operation)) return false; // type test\r\n    return this.directive === other.directive && this.operand === other.operand;\r\n  };\r\n};\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/Latex.ts","/**\r\n * @fileoverview LaTeX style structures\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\n/**@module */\r\n\r\n\r\nimport {isNumber, mustNotBeUndefined, testProperties} from './Utils'; // object property testing function\r\n\r\nimport {\r\n  Lexeme, Mode, modes, mustBeMode, mustBeOperationProperties, Operation, OperationProperties,\r\n  State\r\n} from './Latex';\r\n\r\n\r\nfunction isArray(x: any): x is any[] {\r\n  return x.constructor === Array\r\n}\r\n\r\nfunction mustBeArray(x: any): any[] {\r\n  if (!isArray(x))throw new Error();\r\n  return x;\r\n}\r\n\r\n/**\r\n * LaTeX style package properties\r\n * @interface PackageProperties\r\n * @property {(!Array.<!SymbolProperties>|undefined)} symbols - The symbols of the package in the priority descending order\r\n * @property {(!Array.<!CommandProperties>|undefined)} commands - The commands of the package in the priority descending order\r\n * @property {(!Array.<!EnvironmentProperties>|undefined)} environments - The environments of the package\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface PackageProperties {\r\n  symbols?: SymbolProperties[];\r\n  commands?: CommandProperties[];\r\n  environments?: EnvironmentProperties[];\r\n}\r\n\r\n/**\r\n * LaTeX style collection\r\n * @class\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport default class LatexStyle {\r\n  private environments_: { [name: string]: EnvironmentAndPackage[] };\r\n  private commands_: { [name: string]: CommandAndPackage[] };\r\n  private symbols_: { [name: string]: SymbolAndPackage[] };\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor() {\r\n    /**\r\n     * The symbols by the first symbol of the pattern in the priority increasing order\r\n     * @private {!Object.<string,!Array.<!Symbol>>}\r\n     * @name symbols_\r\n     */\r\n    this.symbols_ = {};\r\n    /**\r\n     * The commands by the name in the priority increasing order\r\n     * @private {!Object.<string,!Array.<!Command>>}\r\n     * @name commands_\r\n     */\r\n    this.commands_ = {};\r\n    /**\r\n     * The environments by the name in the priority increasing order\r\n     * @private {!Object.<string,!Array.<!Environment>>}\r\n     * @name environments_\r\n     */\r\n    this.environments_ = {};\r\n  };\r\n\r\n\r\n  /**\r\n   * Load a package with style definitions\r\n   * @param {string} packageName the name of the style package\r\n   * @param {PackageProperties} stylePackage the style package\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  loadPackage(packageName: string, stylePackage: PackageProperties) {\r\n    if (stylePackage.symbols !== undefined) { // if the symbol descriptions are defined\r\n      if (!(stylePackage.symbols instanceof Array))\r\n        throw new TypeError('\"stylePackage.symbols\" isn\\'t an Array');\r\n      // for all the symbol descriptions\r\n      for (let iSymbol = stylePackage.symbols.length - 1; iSymbol >= 0; --iSymbol) {\r\n        let symbol: Symbol = new Symbol(stylePackage.symbols[iSymbol]); // the symbol description\r\n        if (symbol.pattern) { // if the symbol has a pattern\r\n          let symbolPatternFirstChar = symbol.pattern[0]; // the first char of the pattern\r\n          // the symbols with the same pattern first char\r\n          if (!this.symbols_.hasOwnProperty(symbolPatternFirstChar))\r\n            this.symbols_[symbolPatternFirstChar] = [];\r\n          let symbols: SymbolAndPackage[] = this.symbols_[symbolPatternFirstChar];\r\n\r\n          symbols.push({symbol, packageName}); // store the symbol and the package name\r\n        }\r\n      }\r\n    }\r\n    if (stylePackage.commands !== undefined) { // if the command descriptions are defined\r\n      if (!(stylePackage.commands instanceof Array))\r\n        throw new TypeError('\"stylePackage.commands\" isn\\'t an Array');\r\n      // for all the command descriptions\r\n      for (let iCommand = stylePackage.commands.length - 1; iCommand >= 0; --iCommand) {\r\n        let command = new Command(stylePackage.commands[iCommand]); // the command description\r\n        if (command.name) { // if the command has a name\r\n          // the commands with the same name\r\n          (this.commands_[command.name] || (this.commands_[command.name] = []))\r\n            .push({command, packageName}); // store the command and the package name\r\n        }\r\n      }\r\n    }\r\n    if (stylePackage.environments !== undefined) { // if the environment descriptions are defined\r\n      if (!(stylePackage.environments instanceof Array))\r\n        throw new TypeError(`\"stylePackage.environments\" isn't an Array`);\r\n      // for all the environment descriptions\r\n      for (let iEnvironment = stylePackage.environments.length - 1; iEnvironment >= 0;\r\n           --iEnvironment) {\r\n        // the environment description\r\n        let environment: Environment = new Environment(stylePackage.environments[iEnvironment]);\r\n        const envName: string = environment.name;\r\n        if (envName) { // if the environment has a name\r\n          // the environments with the same name\r\n          let storedEnv = this.environments_[envName];\r\n          if (storedEnv === undefined) {\r\n            storedEnv = [];\r\n            this.environments_[envName] = storedEnv;\r\n          }\r\n          storedEnv.push({environment, packageName}); // store the environment and the package name\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Unload a package with style definitions\r\n   * @param {string} packageName the name of the style package\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  unloadPackage(packageName: string) {\r\n    // for all the symbol pattern first chars\r\n    for (let symbolPatternFirstChar in this.symbols_)\r\n      if (this.symbols_.hasOwnProperty(symbolPatternFirstChar)) {\r\n        // the filtered symbols with the same pattern first char\r\n        let filteredSymbols = mustBeArray(this.symbols_[symbolPatternFirstChar]).filter(styleItem => {\r\n          return styleItem.packageName !== packageName;\r\n        });\r\n        // if there are still some symbols with the same pattern first char\r\n        if (filteredSymbols.length) {\r\n          // store the filtered symbol descriptions\r\n          this.symbols_[symbolPatternFirstChar] = filteredSymbols;\r\n        } else { // if there are no the symbols with the same pattern first char\r\n          delete this.symbols_[symbolPatternFirstChar]; // delete the key-value pair\r\n        }\r\n      }\r\n    // for all the command names\r\n    for (let commandName in this.commands_) if (this.commands_.hasOwnProperty(commandName)) {\r\n      // the filtered commands with the same name\r\n      let filteredCommands = mustBeArray(this.commands_[commandName]).filter(styleItem => {\r\n        return styleItem.packageName !== packageName;\r\n      });\r\n      if (filteredCommands.length) { // if there are still some commands with the same name\r\n        this.commands_[commandName] = filteredCommands; // store the filtered command descriptions\r\n      } else { // if there are no the commands with the same name\r\n        delete this.commands_[commandName]; // delete the key-value pair\r\n      }\r\n    }\r\n    // for all the environment names\r\n    for (let environmentName in this.environments_)\r\n      if (this.environments_.hasOwnProperty(environmentName)) {\r\n        // the filtered environments with the same name\r\n        let filteredEnvironments = mustBeArray(this.environments_[environmentName]).filter(styleItem => {\r\n          return styleItem.packageName !== packageName;\r\n        });\r\n        // if there are still some environments with the same name\r\n        if (filteredEnvironments.length) {\r\n          // store the filtered environment descriptions\r\n          this.environments_[environmentName] = filteredEnvironments;\r\n        } else { // if there are no the environments with the same name\r\n          delete this.environments_[environmentName]; // delete the key-value pair\r\n        }\r\n      }\r\n  };\r\n\r\n\r\n  /**\r\n   * Get symbols\r\n   * @param {!State} state the state that the symbols must match to\r\n   * @param {string} patternFirstChar the first char of the symbol parameter pattern\r\n   * @return {!Array.<!Symbol>} the list of symbols in the priority descending order\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  symbols(state: State, patternFirstChar: string) {\r\n    if (!(state instanceof State))\r\n      throw new SyntaxError('\"state\" isn\\'t a State instance');\r\n    // all the symbols with the defined first pattern char\r\n    let symbols = this.symbols_[patternFirstChar];\r\n    if (symbols === undefined) return []; // return empty list if there are no such symbols\r\n    let filteredSymbols = []; // the list of the symbols matching to the state\r\n    for (let iSymbol = mustBeArray(symbols).length - 1; iSymbol >= 0; --iSymbol) { // for all the symbols\r\n      let symbol = symbols[iSymbol].symbol; // the symbol\r\n      // store the symbol if it matches to the state\r\n      //noinspection JSUnresolvedFunction\r\n      if (state.test(symbol.modes)) filteredSymbols.push(symbol);\r\n    }\r\n    return filteredSymbols;\r\n  };\r\n\r\n\r\n  /**\r\n   * Get commands\r\n   * @param {!State} state the state that the commands must match to\r\n   * @param {!string} name the name of the command\r\n   * @return {Array.<Command>} the list of commands in the priority descending order\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  commands(state: State, name: string): Command[] {\r\n    if (!(state instanceof State))\r\n      throw new SyntaxError('\"state\" isn\\'t a State instance');\r\n    let commands = this.commands_[name]; // all the commands with the defined name\r\n    if (!commands) return []; // return empty list if there are no such commands\r\n    let filteredCommands = []; // the list of the commands matching to the state\r\n    for (let iCommand = mustBeArray(commands).length - 1; iCommand >= 0; --iCommand) { // for all the commands\r\n      let command = commands[iCommand].command; // the command\r\n      // store the command if it matches to the state\r\n      //noinspection JSUnresolvedFunction\r\n      if (state.test(command.modes)) filteredCommands.push(command);\r\n    }\r\n    return filteredCommands;\r\n  };\r\n\r\n\r\n  /**\r\n   * Get environments\r\n   * @param {!State} state the state that the environments must match to\r\n   * @param {!string} name the name of the environment\r\n   * @return {Array.<Environment>} the list of environments in the priority descending order\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  environments(state: State, name: string): EnvironmentAndPackage[] {\r\n    if (!(state instanceof State)) throw new SyntaxError('state isn\\'t State instance');\r\n    let environments: EnvironmentAndPackage[] = this.environments_[name]; // all the environments with the defined name\r\n    if (!environments) return []; // return empty list if there are no such environments\r\n\r\n    // store the environment if it matches to the state\r\n    return mustBeArray(environments)\r\n      .filter(env => state.test(env.modes));\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * LaTeX style item properties\r\n * @interface ItemProperties\r\n * @property {(Lexeme|undefined)} lexeme - The logical lexeme\r\n * @property {(!Object.<Mode, boolean>|undefined)} modes -\r\n *           The modes where the item is defined or not\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface ItemProperties {\r\n  lexeme?: Lexeme;\r\n  modes?: { [mode: string]: boolean };\r\n}\r\n\r\n\r\n/**\r\n * LaTeX style item encapsulation\r\n * @class\r\n * @property {(?Lexeme)} lexeme - The logical lexeme\r\n * @property {!Object.<Mode, boolean>} modes - The modes where the item is defined or not\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Item {\r\n  lexeme?: Lexeme;\r\n  modes: { [mode: string]: boolean };\r\n\r\n  /**\r\n   * Constructor.\r\n   * @param {!ItemProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: ItemProperties = {}) {\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (!(opt_initialProperties instanceof Object))\r\n      throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\r\n    switch (opt_initialProperties.lexeme) {\r\n      case undefined:\r\n        break; // do nothing if no lexeme defined\r\n      case null:\r\n        break; // do nothing if the default lexeme defined\r\n      default:\r\n        let lexeme = Lexeme[opt_initialProperties.lexeme]; // verify the lexeme\r\n        if (lexeme === undefined)\r\n          throw new TypeError('\"initialProperties.lexeme\" isn\\'t a Lexeme option');\r\n        Object.defineProperty(this, 'lexeme', {value: lexeme});\r\n    }\r\n    if (opt_initialProperties.modes !== undefined) {// if the mode states are set\r\n      if (!(opt_initialProperties.modes instanceof Object))\r\n        throw new TypeError('\"initialProperties.modes\" isn\\'t an Object instance');\r\n      Object.defineProperty(this, 'modes', {value: {}}); // create the mode state storage\r\n      for (let modeKey in opt_initialProperties.modes) { // for all the given modes // TODO better loop\r\n        let mode: Mode = mustBeMode(modeKey); // verify the mode key\r\n        if (mode === undefined) // if the mode is unknown\r\n          throw new TypeError('\"initialProperties.modes[' + modeKey +\r\n            ']\" isn\\'t a Mode option');\r\n        // store the mode state\r\n        //noinspection JSUnfilteredForInLoop\r\n        Object.defineProperty(this.modes, mode, {\r\n          value: opt_initialProperties.modes[modeKey],\r\n          enumerable: true\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Compare this item with the other one\r\n   * @param {?Item} other the item to compare with\r\n   * @return {boolean} true if the items are equal, false otherwise\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Item)) return false;\r\n    return this.lexeme === other.lexeme &&\r\n      testProperties(this.modes, other.modes, modes, false);\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Item.prototype, { // default property values\r\n  lexeme: {value: undefined, enumerable: true}, // no lexeme by default\r\n  modes: {value: {}, enumerable: true} // no mode mask by default\r\n});\r\n\r\n\r\n/**\r\n * LaTeX symbol or command parameter properties\r\n * @interface ParameterProperties\r\n * @extends ItemProperties\r\n * @property {(!Array.<!Operation|!OperationProperties>|undefined)} operations -\r\n *           The LaTeX operations that are performed before the parameter\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface ParameterProperties extends ItemProperties {\r\n  operations?: (Operation | OperationProperties)[];\r\n}\r\n\r\nexport function isParameterProperties(ignored: any): ignored is ParameterProperties {\r\n  return true; // todo fields are all optional\r\n}\r\n\r\nexport function mustBeParameterProperties(x: any): ParameterProperties {\r\n  if (!isParameterProperties) throw new Error();\r\n  return x;\r\n}\r\n\r\n/**\r\n * LaTeX symbol or command parameter encapsulation\r\n * @class\r\n * @extends Item\r\n * @property {!Array.<!Operation>} operations -\r\n *           The LaTeX operations that are performed before this parameter\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Parameter extends Item {\r\n  //noinspection JSMismatchedCollectionQueryUpdate TODO\r\n  private operations_: Operation[];\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!ParameterProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: ParameterProperties = {}) {\r\n    super(opt_initialProperties); // the superclass constructor\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (opt_initialProperties.operations !== undefined) { // if the operation list is set\r\n      if (!(opt_initialProperties.operations instanceof Array))\r\n        throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\r\n      Object.defineProperty(this, 'operations_', { // generate and store the operations list\r\n        value: opt_initialProperties.operations.map(operation => new Operation(operation))\r\n      });\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the LaTeX operations that are performed before this parameter\r\n   * @return {!Array.<!Operation>} the operation list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get operations(): Operation[] {\r\n    return this.operations_.slice()\r\n  }\r\n\r\n\r\n  /**\r\n   * Compare this parameter with the other one\r\n   * @param {?Parameter} other the parameter to compare with\r\n   * @return {boolean} true if the parameters are equal, false otherwise\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Parameter)) return false; // type test\r\n    if (!super.equals(other)) return false; // superclass test\r\n\r\n    if (this.operations_.length !== other.operations_.length) return false;\r\n    // test all the operations\r\n\r\n    return this.operations_.every((operation, iOperation) =>\r\n      operation.equals(other.operations_[iOperation]));\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Parameter.prototype, { // make getters and setters enumerable\r\n  operations: {enumerable: true}\r\n});\r\nObject.defineProperties(Parameter.prototype, { // default property values\r\n  operations_: {value: [], enumerable: false} // empty operation list by default\r\n});\r\n\r\n\r\n/**\r\n * LaTeX symbol properties\r\n * @interface SymbolProperties\r\n * @extends ItemProperties\r\n * @property {(!Array.<!Operation|!OperationProperties>|undefined)} operations - The LaTeX operations that\r\n * @property {(!Array.<!Parameter|!ParameterProperties>|undefined)} parameters - The parameters description list\r\n * @property {(string|undefined)} pattern - The LaTeX input pattern\r\n * @property {(string|undefined)} html - The HTML output pattern\r\n * are performed after the symbol\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface SymbolProperties extends ItemProperties {\r\n  operations?: (Operation | OperationProperties)[];\r\n  parameters?: (Parameter | ParameterProperties)[];\r\n  pattern?: string;\r\n  html?: string;\r\n}\r\n\r\nexport interface SymbolAndPackage {\r\n  symbol: Symbol;\r\n  packageName: string;\r\n}\r\n\r\n/**\r\n * LaTeX symbol encapsulation\r\n * @class\r\n * @extends Item\r\n * @property {!Array.<!Operation>} operations -\r\n *           The LaTeX operations that are performed after this symbol\r\n * @property {!Array.<!Parameter>} parameters - The parameters description list\r\n * @property {!Array.<undefined|string|number>} patternComponents - The LaTeX input pattern components\r\n * @property {string} pattern - The LaTeX input pattern\r\n * @property {string} html - The HTML output pattern\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Symbol extends Item {\r\n  //noinspection JSMismatchedCollectionQueryUpdate // TODO\r\n  private operations_: Operation[];\r\n  //noinspection JSMismatchedCollectionQueryUpdate // TODO\r\n  private parameters_: Parameter[];\r\n  //noinspection JSMismatchedCollectionQueryUpdate // TODO\r\n  private patternComponents_: (undefined | string | number)[];\r\n\r\n  html: string;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!SymbolProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: SymbolProperties = {}) {\r\n    super(opt_initialProperties); // the superclass constructor\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (opt_initialProperties.operations !== undefined) { // if the operation list is set\r\n      if (!(opt_initialProperties.operations instanceof Array))\r\n        throw new TypeError('\"initialProperties.operations\" isn\\'t an Array instance');\r\n      Object.defineProperty(this, 'operations_', { // generate and store the operations list\r\n        value: opt_initialProperties.operations.map(operation => new Operation(mustBeOperationProperties(operation)))\r\n      });\r\n    }\r\n    if (opt_initialProperties.parameters !== undefined) { // if the parameters list is set\r\n      if (!(opt_initialProperties.parameters instanceof Array))\r\n        throw new TypeError('\"initialProperties.parameters\" isn\\'t an Array instance');\r\n      // generate and store the parameters list\r\n      this.parameters_ = opt_initialProperties.parameters.map(parameter => new Parameter(mustBeParameterProperties(parameter)));\r\n    }\r\n    if (opt_initialProperties.pattern !== undefined) { // if the LaTeX pattern is set\r\n      if (typeof opt_initialProperties.pattern !== 'string')\r\n        throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\r\n      // try to parse the pattern\r\n      const patternComponents = opt_initialProperties.pattern.match(/([ \\t]+|#\\d+|[^ \\t#]+)/g);\r\n      if (!!patternComponents) { // if there is a non-trivial pattern\r\n\r\n        // store the pattern components\r\n        this.patternComponents_ = patternComponents.map((patternPart: string): string | undefined | number => {\r\n          switch (patternPart[0]) {\r\n            case ' ':\r\n            case '\\t': // if a space part\r\n              return undefined; // undefined is a mark for spaces\r\n            case '#': // if a parameter part\r\n              let parameterIndex = Number(patternPart.substring(1)) - 1; // the index of a parameter\r\n              if (!this.parameters_[parameterIndex])\r\n                throw new TypeError(\r\n                  '\"initialProperties.pattern\" contains the incorrect parameter number ' +\r\n                  patternPart.substring(1)\r\n                );\r\n              return parameterIndex;\r\n            default: // raw pattern part\r\n              return patternPart;\r\n          }\r\n        });\r\n      }\r\n    }\r\n    if (opt_initialProperties.html !== undefined) { // if the LaTeX pattern is set\r\n      if (typeof opt_initialProperties.html !== 'string')\r\n        throw new TypeError('\"initialProperties.html\" isn\\'t a string');\r\n      // store the pattern\r\n      Object.defineProperty(this, 'html', {value: opt_initialProperties.html, enumerable: true});\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get the LaTeX operations that are performed after this symbol\r\n   * @return {!Array.<!Operation>} the operation list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get operations(): Operation[] {\r\n    return this.operations_.slice()\r\n  }\r\n\r\n  /**\r\n   * Get the parameters description list\r\n   * @return {!Array.<!Latex.Parameter>} the parameter list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get parameters(): Parameter[] {\r\n    return this.parameters_.slice()\r\n  }\r\n\r\n  /**\r\n   * Get the parameter description\r\n   * @param {number} parameterIndex the index of the parameter\r\n   * @return {?Latex.Parameter} the parameter or undefined if there is no parameter with such an index\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parameter(parameterIndex: number): Parameter | undefined {\r\n    return this.parameters_[parameterIndex] || undefined\r\n  }\r\n\r\n  /**\r\n   * Get the pattern components\r\n   * @return {!Array.<!Latex.Parameter>} the pattern component list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get patternComponents(): any[] {\r\n    return mustNotBeUndefined(this.patternComponents_.slice())\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the pattern\r\n   * @return {string} the LaTeX input pattern\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get pattern() {\r\n    return this.patternComponents_.map(patternComponent => {\r\n      if (isNumber(patternComponent)) {\r\n        return '#' + (patternComponent + 1);\r\n      }\r\n      switch (typeof patternComponent) {\r\n        case 'string':\r\n          return patternComponent;\r\n        default:\r\n          return ' ';\r\n      }\r\n    }).join('');\r\n  }\r\n\r\n  /**\r\n   * Compare this symbol with the other one\r\n   * @param {?Symbol} other the symbol to compare with\r\n   * @return {boolean} true if the symbols are equal, false otherwise\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any): boolean {\r\n    if (!(other instanceof Symbol)) return false; // type test\r\n    if (!super.equals(other)) return false; // superclass test\r\n\r\n    if (this.operations_.length !== other.operations_.length) return false;\r\n    // test all the operations\r\n\r\n    if (!this.operations_.every((operation, iOperation) =>\r\n        operation.equals(other.operations_[iOperation])))\r\n      return false;\r\n\r\n    if (this.parameters_.length !== other.parameters_.length) return false;\r\n    // test all the parameters\r\n\r\n    if (!this.parameters_.every((parameter, iParameter) =>\r\n        parameter.equals(other.parameters_[iParameter])))\r\n      return false;\r\n    return this.html === other.html;\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Symbol.prototype, { // make getters and setters enumerable\r\n  operations: {enumerable: true},\r\n  parameters: {enumerable: true},\r\n  patternComponents: {enumerable: true},\r\n  pattern: {enumerable: true}\r\n});\r\n\r\nObject.defineProperties(Symbol.prototype, { // default property values\r\n  operations_: {value: [], enumerable: false, writable: true}, // empty operation list\r\n  parameters_: {value: [], enumerable: false, writable: true}, // empty parameter list\r\n  patternComponents_: {value: [], enumerable: false, writable: true}, // empty pattern\r\n  html: {value: '', enumerable: true, writable: true} // empty HTML pattern\r\n});\r\n\r\n\r\n/**\r\n * LaTeX command properties\r\n * @interface CommandProperties\r\n * @extends SymbolProperties\r\n * @property {(string|undefined)} name - The command name (a sequence of letters and optional star)\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface CommandProperties extends SymbolProperties {\r\n  name?: string;\r\n}\r\n\r\nexport interface CommandAndPackage {\r\n  command: Command;\r\n  packageName: string;\r\n}\r\n\r\n/**\r\n * LaTeX command encapsulation\r\n * @class\r\n * @extends Symbol\r\n * @property {string} name - The command name (a sequence of letters and optional star)\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Command extends Symbol {\r\n  name: string;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!CommandProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: CommandProperties = {}) {\r\n    super(opt_initialProperties); // the superclass constructor\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (opt_initialProperties.name !== undefined) { // if the name is set\r\n      if (typeof opt_initialProperties.name !== 'string')\r\n        throw new TypeError('\"initialProperties.name\" isn\\'t a string');\r\n      // store the name\r\n      Object.defineProperty(this, 'name', {value: opt_initialProperties.name});\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Compare this command with the other one\r\n   * @param {?Command} other the command to compare with\r\n   * @return {boolean} true if the commands are equal, false otherwise\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Command)) return false; // type test\r\n    if (!super.equals(other)) return false; // superclass test\r\n    return this.name === other.name;\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Command.prototype, { // default property values\r\n  name: {value: '', enumerable: true} // empty name\r\n});\r\nexport function isCommand(c: any): c is Command {\r\n  return c instanceof Command;\r\n}\r\nexport function mustBeCommand(c: any): Command {\r\n  if (!isCommand(c)) throw new Error();\r\n  return c;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX command properties\r\n * @interface EnvironmentProperties\r\n * @extends ItemProperties\r\n * @property {(string|undefined)} name - The command name (a sequence of letters and optional star)\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface EnvironmentProperties extends ItemProperties {\r\n  name?: string;\r\n}\r\n\r\nexport interface EnvironmentAndPackage {\r\n  environment: Environment;\r\n  packageName?: string;\r\n}\r\n\r\n/**\r\n * LaTeX environment encapsulation\r\n * @class\r\n * @extends Item\r\n * @property {string} name - The environment name (a sequence of letters and optional star)\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Environment extends Item {\r\n  name: string;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!EnvironmentProperties=} opt_initialProperties the initial property values\r\n   */\r\n  constructor(opt_initialProperties: EnvironmentProperties = {}) {\r\n    super(opt_initialProperties); // the superclass constructor\r\n    // do nothing if there are no initial properties\r\n    if (opt_initialProperties === undefined) return;\r\n    if (opt_initialProperties.name !== undefined) { // if the name is set\r\n      if (typeof opt_initialProperties.name !== 'string')\r\n        throw new TypeError('\"initialProperties.name\" isn\\'t a string');\r\n      // store the name\r\n      Object.defineProperty(this, 'name', {value: opt_initialProperties.name});\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Compare this environment with the other one\r\n   * @param {?Environment} other the environment to compare with\r\n   * @return {boolean} true if the environments are equal, false otherwise\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  equals(other: any) {\r\n    if (!(other instanceof Environment)) return false; // type test\r\n    if (!super.equals(other)) return false; // superclass test\r\n    return this.name === other.name;\r\n  }\r\n}\r\n;\r\nObject.defineProperties(Environment.prototype, { // default property values\r\n  name: {value: '', enumerable: true} // empty name\r\n});\r\nexport function isEnvironment(x: any): x is Environment {\r\n  return x instanceof Environment;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexStyle.ts","/**\r\n * @fileoverview LaTeX syntax tree structure elements\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\n/** @module */\r\n\r\n/** @external LatexStyle*/\r\nimport {Command, Environment, isEnvironment, mustBeCommand, Parameter, Symbol} from './LatexStyle'; // LaTeX style structures\r\n/** @external SyntaxTree */\r\nimport {SyntaxTree, Node} from './SyntaxTree';\r\nimport {Lexeme} from \"./Latex\";\r\nimport {mustNotBeUndefined} from \"./Utils\";\r\n\r\n\r\n/**\r\n * LaTeX syntax tree structure\r\n * @class\r\n * @extends SyntaxTree\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport default class extends SyntaxTree {\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!Token} rootToken the root token (must have no parent and no tree)\r\n   * @param {string} source the sources text that has this syntax tree\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(rootToken: Token, source: string) {\r\n    if (!(rootToken instanceof Token))\r\n      throw new TypeError('\"rootToken\" isn\\'t a Token instance');\r\n    super(rootToken, source); // the superclass constructor\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * LaTeX syntax tree token base properties\r\n * @interface TokenProperties\r\n * @property {(?Token|undefined)} parentToken - The parent token or undefined if there is no parent\r\n * @property {(!Array.<Token>|undefined)} childTokens - The list of the child tokens\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface TokenProperties {\r\n  parentToken?: Token;\r\n  childTokens?: Token[];\r\n}\r\n\r\n\r\n/**\r\n * LaTeX syntax tree token base structure\r\n * @class\r\n * @extends SyntaxTree.Node\r\n * @property {(Lexeme|undefined)} lexeme - The logical lexeme of the token\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Token extends Node {\r\n  lexeme?: Lexeme;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!TokenProperties=} opt_initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(opt_initialProperties: TokenProperties = {}) {\r\n    if (opt_initialProperties === undefined) { // if the initial properties are not set\r\n      super(); // superclass constructor\r\n    } else if (opt_initialProperties instanceof Object) { // if the initial properties are set\r\n      // superclass constructor\r\n      // superclass initial properties\r\n      let superInitialProperties = Object.create(opt_initialProperties);\r\n      superInitialProperties.parentNode = opt_initialProperties.parentToken;\r\n      superInitialProperties.childNodes = opt_initialProperties.childTokens;\r\n      super(superInitialProperties);\r\n    } else { // if the initial properties are in unsupported type\r\n      throw new TypeError('\"initialProperties\" isn\\'t an Object instance');\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    return skipNodeClass ? super.toString(true) : 'Token{' + super.toString(true) + '}';\r\n  }\r\n};\r\nObject.defineProperties(Token.prototype, { // default properties\r\n  lexeme: { value: undefined, enumerable: true }, // no lexeme\r\n  parentNodeClass_: { value: Token } // parent node must be an EnvironmentToken instance\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX symbol token properties\r\n * @interface SymbolTokenProperties\r\n * @extends TokenProperties\r\n * @property {!Symbol|undefined} symbol - The LaTeX symbol or undefined if the symbol is unrecognized\r\n * @property {string|undefined} pattern - The pattern that corresponds to the unrecognized symbol\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface SymbolTokenProperties extends TokenProperties {\r\n  symbol?: Symbol;\r\n  pattern?: string;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX symbol token structure\r\n * @class\r\n * @extends Token\r\n * @property {?Symbol} symbol - The corresponding LaTeX symbol or undefined if the symbol is unrecognized\r\n * @property {string} pattern - The symbol LaTeX pattern\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class SymbolToken extends Token {\r\n  symbol?: Symbol;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!SymbolTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: SymbolTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (initialProperties.symbol) { // if the symbol is defined\r\n      if (!(initialProperties.symbol instanceof Symbol))\r\n        throw new TypeError('\"initialProperties.symbol\" isn\\'t a Symbol instance');\r\n      // store the symbol\r\n      Object.defineProperty(this, 'symbol', {value: initialProperties.symbol, enumerable: true});\r\n    } else { // if the symbol isn't defined\r\n      if (typeof initialProperties.pattern !== 'string')\r\n        throw new TypeError('\"initialProperties.pattern\" isn\\'t a string');\r\n      // store the unrecognized pattern\r\n      Object.defineProperty(this, 'pattern', { value: initialProperties.pattern });\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the logical lexeme\r\n   * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get lexeme (): Lexeme | undefined {\r\n    \r\n    return this.symbol ? this.symbol.lexeme : undefined;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the symbol LaTeX pattern\r\n   * @return {string} the symbol pattern\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get pattern (): string {\r\n    return mustNotBeUndefined(this.symbol).pattern;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    let source = '';\r\n    let iParameter = 0; // the parameter iterator\r\n    \r\n    let pattern = this.pattern; // LaTeX input pattern\r\n    // for all the pattern chars\r\n    for (\r\n      let nPatternChars = pattern.length, iPatternChar = 0;\r\n      iPatternChar < nPatternChars;\r\n      ++iPatternChar\r\n    ) {\r\n      let patternChar = pattern[iPatternChar]; // the pattern char\r\n      if (patternChar === '#') { // if a parameter place\r\n        ++iPatternChar; // go to the next pattern char\r\n        let parameterToken = this.childNode(iParameter++); // try to get the parameter token\r\n        source += parameterToken ? parameterToken.toString(true) : '??';\r\n      } else { // if the ordinary pattern char\r\n        source += patternChar;\r\n      }\r\n    }\r\n    return skipNodeClass ?\r\n      source :\r\n      'SymbolToken' + (this.symbol ? '' : '[?]') + '{' + source + '}';\r\n  }\r\n};\r\nObject.defineProperties(SymbolToken.prototype, { // default properties\r\n  symbol: { value: undefined, enumerable: true } // no symbol token\r\n});\r\nObject.defineProperties(SymbolToken.prototype, { // make getters and setters enumerable\r\n  pattern: { enumerable: true }\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX parameter token properties\r\n * @interface ParameterTokenProperties\r\n * @extends TokenProperties\r\n * @property {boolean} hasBrackets - True if the parameter is bounded by the logical brackets, false otherwise\r\n * @property {boolean} hasSpacePrefix - True if the parameter is prefixed by a space, false otherwise\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface ParameterTokenProperties extends TokenProperties {\r\n  hasBrackets: boolean;\r\n  hasSpacePrefix: boolean;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX parameter token structure\r\n * @class\r\n * @extends Token\r\n * @property {boolean} hasBrackets -\r\n *           True if the parameter is bounded by the logical brackets, false otherwise\r\n * @property {boolean} hasSpacePrefix -\r\n *           True if the parameter is prefixed by a space, false otherwise\r\n * @property {?LatexStyle.Parameter} parameter - The corresponding LaTeX parameter\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class ParameterToken extends Token {\r\n  public parentNode: SymbolToken;\r\n\r\n  private hasBrackets: boolean;\r\n  hasSpacePrefix: boolean;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!ParameterTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: ParameterTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (!initialProperties.hasBrackets) // if there are no bounding brackets\r\n      // store this fact\r\n      Object.defineProperty(this, 'hasBrackets', { value: false, enumerable: true });\r\n    if (initialProperties.hasSpacePrefix) // if there is a space before\r\n      // store this fact\r\n      Object.defineProperty(this, 'hasSpacePrefix', { value: true, enumerable: true });\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the logical lexeme\r\n   * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get lexeme (): Lexeme | undefined {\r\n    if(this.parameter && this.parameter.lexeme) return this.parameter.lexeme;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the corresponding LaTeX parameter description\r\n   * @return {?LatexStyle.Parameter}\r\n   *         the LaTeX parameter or undefined of there is parent symbol or such a parameter\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get parameter (): Parameter | undefined {\r\n    /** @type {?SymbolToken} */\r\n    let symbolToken = this.parentNode; // get the symbol token\r\n    let symbol = mustNotBeUndefined(symbolToken.symbol);\r\n    let parameterIndex = symbolToken.childIndex(this);\r\n    if(symbolToken !== undefined && parameterIndex !== undefined && parameterIndex >= 0)\r\n      return symbol.parameter(parameterIndex);\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    let source = this.hasSpacePrefix ? ' ' : '';\r\n    source += this.hasBrackets ? '{' + super.toString(true) + '}' : super.toString(true);\r\n    return skipNodeClass ? source : 'ParameterToken{' + source + '}';\r\n  }\r\n};\r\nObject.defineProperties(ParameterToken.prototype, { // default properties\r\n  hasBrackets: { value: true, enumerable: true }, // there are bounding brackets\r\n  hasSpacePrefix: { value: false, enumerable: true }, // there is no space before\r\n  parentNodeClass_: { value: SymbolToken } // parent node must be a SymbolToken instance\r\n});\r\nObject.defineProperties(ParameterToken.prototype, { // make getters and setters enumerable\r\n  parameter: { enumerable: true }\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX command token properties\r\n * @interface CommandTokenProperties\r\n * @extends TokenProperties\r\n * @property {!LatexStyle.Command|undefined} command -\r\n *           The LaTeX command or undefined if the command is unrecognized\r\n * @property {string|undefined} name - The name that corresponds to the unrecognized command\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface CommandTokenProperties extends TokenProperties {\r\n  command?: Command;\r\n  name?: string;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX command token structure\r\n * @class\r\n * @extends SymbolToken\r\n * @property {!LatexStyle.Command} command -\r\n *           The corresponding LaTeX command or undefined if the command is unrecognized\r\n * @property {string|undefined} name - The LaTeX command name\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class CommandToken extends SymbolToken {\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!CommandTokenProperties} initialProperties the initial property values\r\n   */\r\n  constructor(initialProperties: CommandTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    // copy the initial properties for the superclass\r\n    let superInitialProperties = Object.create(initialProperties);\r\n    if (initialProperties.command) { // if the command is defined\r\n      if (!(initialProperties.command instanceof Command))\r\n        throw new TypeError('\"initialProperties.command\" isn\\'t a LatexStyle.Command instance');\r\n      // the command is the symbol for the superclass\r\n      superInitialProperties.symbol = initialProperties.command;\r\n      super(superInitialProperties); // the superclass constructor\r\n    } else { // if the command isn't defined\r\n      if (typeof initialProperties.name !== 'string')\r\n        throw new TypeError('\"initialProperties.name\" isn\\'t a string');\r\n      superInitialProperties.pattern = '';\r\n      super(superInitialProperties); // the superclass constructor\r\n      // store the unrecognized name\r\n      Object.defineProperty(this, 'name', { value: initialProperties.name });\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the LaTeX command\r\n   * @return {!LatexStyle.Command} the command description\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get command (): Command { return mustBeCommand(this.symbol) }\r\n\r\n\r\n  /**\r\n   * Get the LaTeX command name\r\n   * @return {string} the command name\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get name (): string { return this.command.name }\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n   let source = '\\\\' + this.name + super.toString(true);\r\n   return skipNodeClass ?\r\n     source :\r\n     'CommandToken' + (this.command ? '' : '[?]') + '{' + source + '}';\r\n  }\r\n};\r\n\r\nObject.defineProperties(CommandToken.prototype, { // make getters and setters enumerable\r\n  command: { enumerable: true },\r\n  name: {enumerable: true }\r\n});\r\n\r\nexport function isCommandToken(x: any): x is CommandToken {\r\n  return x && x instanceof CommandToken;\r\n}\r\n\r\n\r\n/**\r\n * LaTeX environment token properties\r\n * @interface EnvironmentTokenProperties\r\n * @extends TokenProperties\r\n * @property {!LatexStyle.Environment} environment - The LaTeX environment\r\n * @property\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\n\r\nexport interface EnvironmentTokenPropertiesWithEnvironment\r\n  extends EnvironmentTokenProperties {\r\n  environment: Environment;\r\n  name: undefined;\r\n}\r\n\r\nexport interface EnvironmentTokenPropertiesWithName\r\n  extends EnvironmentTokenProperties {\r\n  environment: undefined;\r\n  name: string;\r\n}\r\n\r\nexport interface EnvironmentTokenProperties\r\n  extends TokenProperties {\r\n  environment?: Environment;\r\n  name?: string;\r\n}\r\n\r\n/**\r\n * LaTeX environment token structure\r\n * @class\r\n * @extends Token\r\n * @property {!Environment} environment - The corresponding LaTeX environment\r\n * @property {?CommandToken} beginCommandToken -\r\n *           The environment begin command token or undefined is there is no such a token\r\n * @property {?CommandToken} endCommandToken -\r\n *           The environment end command token or undefined is there is no such a token\r\n * @property {?EnvironmentBodyToken} bodyToken -\r\n *           The environment body token or undefined is there is no such a token\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class EnvironmentToken extends Token {\r\n  environment: Environment;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!EnvironmentTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: EnvironmentTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (!(initialProperties.environment instanceof Environment))\r\n      throw new TypeError(\r\n        '\"initialProperties.environment\" isn\\'t a LatexStyle.Environment instance');\r\n    // store the environment\r\n    Object.defineProperty(this, 'environment', {\r\n      value: initialProperties.environment,\r\n      enumerable: true\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the logical lexeme\r\n   * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get lexeme () { return this.environment.lexeme }\r\n\r\n\r\n  /**\r\n   * Get the begin command token\r\n   * @return {?CommandToken} the command token or undefined if there is no begin command\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get beginCommandToken () {\r\n    let beginCommandToken = this.childNode(0);\r\n    return beginCommandToken instanceof CommandToken ? beginCommandToken : undefined;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the end command token\r\n   * @return {?CommandToken} the command token or undefined if there is no end command\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get endCommandToken () {\r\n    let endCommandToken = this.childNode(2);\r\n    return endCommandToken instanceof CommandToken ? endCommandToken : undefined;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get the environment body token\r\n   * @return {?EnvironmentBodyToken} the body or undefined if there is no body\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get bodyToken () {\r\n    let bodyToken = this.childNode(1);\r\n    return bodyToken instanceof EnvironmentBodyToken ? bodyToken : undefined;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass:boolean=false) {\r\n    let beginCommandToken = this.beginCommandToken; // the begin command token\r\n    let endCommandToken = this.endCommandToken; // the end command token\r\n    let bodyToken = this.bodyToken; // the environment body token\r\n    let source = '\\\\begin{' + this.environment.name + '}';\r\n    source += beginCommandToken ?\r\n      SymbolToken.prototype.toString.call(beginCommandToken, true) :\r\n      '??';\r\n    source += bodyToken ? bodyToken.toString(true) : '??';\r\n    source += '\\\\end{' + this.environment.name + '}';\r\n    source += endCommandToken ? SymbolToken.prototype.toString.call(endCommandToken, true) : '??';\r\n    return skipNodeClass ? source : 'EnvironmentToken{' + source + '}';\r\n  }\r\n};\r\nObject.defineProperties(EnvironmentToken.prototype, { // make getters and setters enumerable\r\n  beginToken: { enumerable: true },\r\n  endToken: { enumerable: true }\r\n});\r\n\r\nexport function mustBeEnvironmentToken(x: any): EnvironmentToken {\r\n  if(!isEnvironmentToken(x)) throw new Error();\r\n  return x;\r\n}\r\n\r\nexport function isEnvironmentToken(x: any): x is EnvironmentToken {\r\n  return x instanceof EnvironmentToken;\r\n}\r\n\r\n\r\nfunction getBeginCommandToken(x: any): CommandToken | undefined {\r\n  if(isCommandToken(x.beginCommandToken))\r\n    return x.beginCommandToken;\r\n}\r\n\r\nfunction getEndCommandToken(x: any): CommandToken | undefined {\r\n  if(isCommandToken(x.endCommandToken))\r\n    return x.endCommandToken;\r\n}\r\n\r\nfunction getEnvironment(x: any): Environment | undefined {\r\n  if(x.environment && isEnvironment(x.environment))\r\n    return x.environment;\r\n}\r\n\r\n/**\r\n * LaTeX environment body token structure\r\n * @class\r\n * @extends Token\r\n * @property {?LatexStyle.Environment} environment -\r\n *           The LaTeX environment or undefined if there is no parent environment\r\n * @property {?EnvironmentToken} environmentToken - The parent environment token\r\n * @property {?CommandToken} beginCommandToken -\r\n *           The environment begin command token or undefined is there is no such a token\r\n * @property {?CommandToken} endCommandToken -\r\n *           The environment end command token or undefined is there is no such a token\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class EnvironmentBodyToken extends Token {\r\n\r\n  /**\r\n   * Get the LaTeX environment\r\n   * @return {?LatexStyle.Environment} the environment or undefined if there is no parent environment\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get environment (): Environment | undefined { return this.parentNode && getEnvironment(this.parentNode) }\r\n\r\n\r\n\r\n  //noinspection JSUnusedGlobalSymbols\r\n  /**\r\n   * Get the parent environment token\r\n   * @return {?EnvironmentToken} the environment or undefined if there is no parent environment\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get environmentToken (): EnvironmentToken | undefined { return this.parentNode && mustBeEnvironmentToken(this.parentNode); }\r\n\r\n\r\n\r\n  /**\r\n   * Get the environment begin command token\r\n   * @return {?CommandToken} the command token or undefined if there is no begin command\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get beginCommandToken () { return this.parentNode && getBeginCommandToken(this.parentNode) }\r\n\r\n\r\n\r\n  /**\r\n   * Get the environment end command token\r\n   * @return {(CommandToken|undefined)} the command token or undefined if there is no end command\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get endCommandToken () { return this.parentNode && getEndCommandToken(this.parentNode) }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    return skipNodeClass ?\r\n      super.toString(true) :\r\n      'EnvironmentBodyToken{' + super.toString(true) + '}';\r\n  }\r\n};\r\nObject.defineProperties(EnvironmentBodyToken.prototype, { // default properties\r\n  parentNodeClass_: { value: EnvironmentToken } // parent node must be an EnvironmentToken instance\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX space token properties\r\n * @interface SpaceTokenProperties\r\n * @extends TokenProperties\r\n * @property {number|undefined} lineBreakCount - The number of line breaks\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface SpaceTokenProperties\r\n  extends TokenProperties {\r\n  lineBreakCount?: number;\r\n}\r\n\r\n/**\r\n * LaTeX space token structure\r\n * @class\r\n * @extends Token\r\n * @property {number} lineBreakCount - The number of line breaks\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class SpaceToken extends Token {\r\n  lineBreakCount: number;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!SpaceTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: SpaceTokenProperties) {\r\n    if (initialProperties === undefined) {\r\n      super();\r\n      return;\r\n    }\r\n    else if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (initialProperties.lineBreakCount) { // if the line break number is defined\r\n      if (!isFinite(initialProperties.lineBreakCount) || initialProperties.lineBreakCount < 0)\r\n        throw new TypeError('\"initialProperties.lineBreakCount\" isn\\'t a non-negative number');\r\n      // store the line break number\r\n      Object.defineProperty(this, 'lineBreakCount', {\r\n        value: initialProperties.lineBreakCount,\r\n        enumerable: true\r\n      });\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the logical lexeme\r\n   * @return {(Lexeme|undefined)} the lexeme or undefined if the lexeme isn't defined\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get lexeme (): Lexeme {\r\n    return this.lineBreakCount <= 1 ? \"SPACE\" : \"PARAGRAPH_SEPARATOR\";\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false): string {\r\n    if (skipNodeClass) { // if the node class name must be skipped\r\n      switch (this.lineBreakCount) {\r\n      case 0:\r\n        return ' ';\r\n      case 1:\r\n        return '\\n';\r\n      default:\r\n        return '\\n\\n';\r\n      }\r\n    } else { // if the node class name must be included\r\n      switch (this.lineBreakCount) {\r\n      case 0:\r\n        return 'SpaceToken{ }';\r\n      case 1:\r\n        return 'SpaceToken{\\n}';\r\n      default:\r\n        return 'SpaceToken{\\n\\n}';\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nObject.defineProperties(SpaceToken.prototype, { // default properties\r\n  lineBreakCount: { value: 0, enumerable: true } // line break number\r\n});\r\n\r\n\r\n\r\n/**\r\n * LaTeX source fragment token properties\r\n * @interface SourceTokenProperties\r\n * @extends TokenProperties\r\n * @property {Lexeme} lexeme - The logical lexeme\r\n * @property {string} source - The source fragment\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface SourceTokenProperties\r\n  extends TokenProperties {\r\n  lexeme: Lexeme;\r\n  source: string;\r\n}\r\n\r\n/**\r\n * LaTeX source fragment token structure\r\n * @class\r\n * @extends Token\r\n * @property {string} source - The source fragment\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class SourceToken extends Token {\r\n  private source: string;\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!SourceTokenProperties} initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(initialProperties: SourceTokenProperties) {\r\n    if (!(initialProperties instanceof Object))\r\n      throw new TypeError ('\"initialProperties\" isn\\'t an Object instance');\r\n    super(initialProperties); // the superclass constructor\r\n    if (!Lexeme[initialProperties.lexeme])\r\n      throw new TypeError('\"initialProperties.lexeme\" isn\\'t known');\r\n    // store the lexeme\r\n    Object.defineProperty(this, 'lexeme', { value: initialProperties.lexeme, enumerable: true });\r\n    if (typeof initialProperties.source !== 'string')\r\n      throw new TypeError('\"initialProperties.sources\" isn\\'t a string');\r\n    // store the sources\r\n    Object.defineProperty(this, 'source', { value: initialProperties.source, enumerable: true });\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false) {\r\n    return skipNodeClass ? this.source : 'SourceToken[' + this.lexeme + ']{' + this.source + '}';\r\n  }\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexTree.ts","/**\r\n * @fileoverview Syntax tree structure elements\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\nimport {isNumber} from \"./Utils\";\r\n\r\n'use strict';\r\n\r\n/**@module */\r\n\r\n\r\n/**\r\n * Syntax tree structure\r\n * @class\r\n * @property {!Node} rootNode - The root node\r\n * @property {string} source - The source text\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class SyntaxTree {\r\n  //noinspection JSUnusedGlobalSymbols // TODO\r\n  readonly rootNode: Node;\r\n  readonly source: string;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!Node} rootNode the root node (must have no parent and no tree)\r\n   * @param {string} source the sources text that has this syntax tree\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(rootNode: Node, source: string) {\r\n    if (!(rootNode instanceof Node))\r\n      throw new TypeError('\"rootNode\" isn\\'t a SyntaxTree.Node instance');\r\n    if (rootNode.parentNode) throw new TypeError('\"rootNode\" has a parent node');\r\n    if (rootNode.tree) throw new TypeError('\"rootNode\" is a tree root');\r\n\r\n    if (typeof source !== 'string')  throw new TypeError('\"sources\" isn\\'t a string');\r\n    // store the root node\r\n    Object.defineProperty(this, 'rootNode', { value: rootNode, enumerable: true });\r\n    Object.defineProperty(this, 'source', { value: source, enumerable: true }); // store the sources\r\n    // update the root node tree\r\n    Object.defineProperty(rootNode, 'tree', { value: this, enumerable: true });\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * Syntax tree node properties\r\n * @interface NodeProperties\r\n * @property {(?Node|undefined)} parentNode - The parent node or undefined if there is no parent\r\n * @property {(!Array.<Node>|undefined)} childNodes - The list of the child nodes\r\n * @exports\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport interface NodeProperties {\r\n  parentNode?: Node;\r\n  childNodes?: Node[];\r\n}\r\n\r\n\r\n/**\r\n * Syntax tree node structure\r\n * @class\r\n * @property {?SyntaxTree} tree - The tree or undefined if this node isn't in any tree\r\n * @property {?Node} parentNode - The parent node or undefined if there is no parent\r\n * @property {!Array.<Node>} childNodes - The child node list\r\n * @property {number} subtreeSize - The size of the subtree formed by this node\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class Node {\r\n  tree: SyntaxTree;\r\n  public parentNode: Node;\r\n  private subtreeSize: number;\r\n  private childNodes_:Node[];\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {!NodeProperties=} opt_initialProperties the initial property values\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(opt_initialProperties?: NodeProperties) {\r\n    if (opt_initialProperties !== undefined) { // if the initial properties are defined\r\n      if (!(opt_initialProperties instanceof Object))\r\n        throw new TypeError('initialProperties isn\\'t an Object instance');\r\n      if (opt_initialProperties.childNodes !== undefined) { // if the child node list is set\r\n        if (!(opt_initialProperties.childNodes instanceof Array))\r\n          throw new TypeError('initialProperties.childNodes isn\\'t an Array instance');\r\n        opt_initialProperties.childNodes.forEach(this.insertChildSubtree, this);\r\n      }\r\n      let optParentNode = opt_initialProperties.parentNode;\r\n      if (optParentNode !== undefined) { // if the parent node is set\r\n        if (!!optParentNode) {\r\n          //noinspection JSUnresolvedFunction\r\n          optParentNode.insertChildSubtree(this);\r\n        } else {\r\n          throw new TypeError('initialProperties.parentNode isn\\'t a SyntaxTree.Node instance');\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get the child nodes\r\n   * @return {!Array.<Node>} the child node list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  get childNodes(): Node[] {\r\n    return this.childNodes_.slice()\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get the child node\r\n   * @param {(!Node|number)} node the child node or its child index\r\n   * @return {?Node} the child node or undefined of there is no such a child node\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  childNode(node: Node | number): Node | undefined {\r\n    if (isNumber(node)) // if the node child index is given\r\n      return this.childNodes_[node] || undefined;\r\n    if (node instanceof Node) // if the child node is given\r\n      return node.parentNode === this ? node : undefined;\r\n    throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the child node index\r\n   * @param {(!Node|number)} node the child node or its child index\r\n   * @return {(number|undefined)} the child node or undefined of there is no such a child node\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  childIndex(node: Node | number): number | undefined {\r\n    if (isNumber(node)) // if the node child index is given\r\n      return this.childNodes_[node] ? node : undefined;\r\n    if (node instanceof Node) // if the child node is given\r\n      return node.parentNode === this ? this.childNodes_.indexOf(node) : undefined;\r\n    throw new TypeError('\"node\" is neither a number nor a SyntaxTree.Node instance');\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Insert a node to this child node list\r\n   * @param {!Node} node the node to insert (must have no parent and no child nodes)\r\n   * @param {number=undefined} childIndex\r\n   *        the position of the node for this child node list, the last by default\r\n   * @param {number=0} childNodesToCover\r\n   *        the number of this child nodes to become the child nodes of the new node\r\n   * @return {?Node} the inserted node or undefined if cannot insert\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  insertChildNode(node: Node, childIndex: number, childNodesToCover: number): Node {\r\n    if (!(node instanceof Node)) throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\r\n    if (node.parentNode) throw new TypeError('\"node\" has a parent');\r\n    if (node.tree) throw new TypeError('\"node\" is a tree root');\r\n\r\n    // TODO\r\n    // if (!(this instanceof node.parentNodeClass_))\r\n    //   throw new TypeError('\"this\" isn\\'t a suitable class instance');\r\n\r\n    if (node.childNodes_.length) throw new TypeError('\"node\" has child nodes');\r\n    if (!this.hasOwnProperty('childNodes_')) // if there was no child nodes\r\n    // init the property\r\n      Object.defineProperty(this, 'childNodes_', { value: [], configurable: true });\r\n    // use the last position by default\r\n    if (childIndex === undefined) childIndex = this.childNodes_.length;\r\n    // do not cover any child nodes by default\r\n    if (childNodesToCover === undefined) childNodesToCover = 0;\r\n    // replace the child nodes by the new node\r\n    let nodeChildNodes = this.childNodes_.splice(childIndex, childNodesToCover, node);\r\n    // update the size of the subtree formed by this node\r\n    Object.defineProperty(this, 'subtreeSize', {\r\n      value: this.subtreeSize + 1,\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n    // for all the parent nodes\r\n    for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\r\n      // update the size of the subtree formed by the parent node\r\n      Object.defineProperty(parentNode, 'subtreeSize', { value: parentNode.subtreeSize + 1 });\r\n    }\r\n    // update the parent node of the new node\r\n    Object.defineProperty(node, 'parentNode', {\r\n      value: this,\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n    if (nodeChildNodes.length) { // if there are child nodes for the new node\r\n      // store the child nodes\r\n      Object.defineProperty(node, 'childNodes_', { value: nodeChildNodes, configurable: true });\r\n      let subtreeSize = 1; // initiate the size of the subtree formed by the new node\r\n      // for all the child nodes of the new node\r\n      nodeChildNodes.forEach(nodeChildNode => { subtreeSize += nodeChildNode.subtreeSize });\r\n      // store the subtree size\r\n      Object.defineProperty(node, 'subtreeSize', {\r\n        value: subtreeSize,\r\n        enumerable: true,\r\n        configurable: true\r\n      });\r\n    }\r\n    return node;\r\n  }\r\n\r\n\r\n  /**\r\n   * Insert a subtree to this child node list.\r\n   * @param {!Node} node the subtree to insert root node (must have no parent)\r\n   * @param {number=} childIndex\r\n   *        the position of the subtree root for this child node list, the last by default\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  insertChildSubtree(node: Node, childIndex?: number) {\r\n    if (!(node instanceof Node))\r\n      throw new TypeError('\"node\" isn\\'t a SyntaxTree.Node instance');\r\n    if (node.parentNode) throw new TypeError('\"node\" has a parent');\r\n    if (node.tree) throw new TypeError('\"node\" is a tree root');\r\n\r\n    // todo check\r\n    // if (!(this instanceof node.parentNodeClass_))\r\n    //   throw new TypeError('\"this\" isn\\'t a suitable class instance');\r\n    // init child nodes property if not exists\r\n    if (!this.hasOwnProperty('childNodes_')) // if there was no child nodes\r\n    // init the property\r\n      Object.defineProperty(this, 'childNodes_', { value: [], configurable: true });\r\n    // use the last position by default\r\n    if (childIndex === undefined) childIndex = this.childNodes_.length;\r\n    this.childNodes_.splice(childIndex, 0, node); // insert the new node to the child list\r\n    let nodeSubtreeSize = node.subtreeSize; // the size of the subtree formed by the node\r\n    // update the size of the subtree formed by this node\r\n    Object.defineProperty(this, 'subtreeSize', {\r\n      value: this.subtreeSize + nodeSubtreeSize, enumerable: true, configurable: true\r\n    });\r\n    // for all the parent nodes\r\n    for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\r\n      // update the size of the subtree formed by the parent node\r\n      Object.defineProperty(parentNode, 'subtreeSize', {\r\n        value: parentNode.subtreeSize + nodeSubtreeSize\r\n      });\r\n    }\r\n    // update the parent node of the new node\r\n    Object.defineProperty(node, 'parentNode', {\r\n      value: this,\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n  }\r\n\r\n  \r\n\r\n  /**\r\n   * Remove a child node of this node. All its child nodes become the child nodes of this node\r\n   * @param {(!Node|number)} nodeOrNodeIndex the subtree root or its child index\r\n   * @return {?Node} the removed node or undefined of there is no such a child node\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  removeChildNode(nodeOrNodeIndex: number | Node): Node | undefined {\r\n    let nodeChildIndex: number | undefined = this.childIndex(nodeOrNodeIndex); // the child index of the node\r\n    if (nodeChildIndex === undefined) return undefined; // return if there is no such a child\r\n\r\n    const node: Node = this.childNodes_[nodeChildIndex]; // the child node to remove\r\n\r\n    // replace the node with its child nodes at this child node list\r\n    // todo could be more efficient?\r\n    this.childNodes_.splice(nodeChildIndex, 1, ...node.childNodes_);\r\n\r\n    if (this.childNodes_.length) { // if there are child nodes\r\n      // update this node subtree size\r\n      Object.defineProperty(this, 'subtreeSize', { value: this.subtreeSize - 1 });\r\n    } else { // if there are no child nodes\r\n      delete this.childNodes_; // this node has no child nodes anymore\r\n      delete this.subtreeSize; // this node has node subtree anymore\r\n    }\r\n    // for all the parent nodes\r\n    for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\r\n      // update the size of the subtree formed by the parent node\r\n      Object.defineProperty(parentNode, 'subtreeSize', { value: parentNode.subtreeSize - 1 });\r\n    }\r\n    delete node.parentNode; // the node has no parent node anymore\r\n\r\n    delete node.childNodes_; // the node has no child nodes anymore\r\n    delete node.subtreeSize; // the node has no subtree anymore\r\n    return node;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Remove a subtree formed by a child node of this node\r\n   * @param {(!Node|number)} node the subtree root or its child index\r\n   * @return {?Node} the removed subtree root node or undefined of there is no such a child node\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  removeChildSubtree(node: Node | number): Node | undefined {\r\n    let nodeChildIndex: number | undefined = this.childIndex(node); // the child index of the node\r\n    if (nodeChildIndex === undefined) return undefined; // return if there is no such a child\r\n\r\n    node = this.childNodes_.splice(nodeChildIndex, 1)[0]; // remove the node from the child list\r\n    let nodeSubtreeSize = node.subtreeSize; // the size of the subtree formed by the node\r\n    if (this.childNodes_.length) { // if there are child nodes\r\n      // update this node subtree size\r\n      Object.defineProperty(this, 'subtreeSize', { value: this.subtreeSize - nodeSubtreeSize });\r\n    } else { // if there are no child nodes\r\n      delete this.childNodes_; // this node has no child nodes anymore\r\n      delete this.subtreeSize; // this node has node subtree anymore\r\n    }\r\n    // for all the parent nodes\r\n    for (let parentNode = this.parentNode; parentNode; parentNode = parentNode.parentNode) {\r\n      // update the size of the subtree formed by the parent node\r\n      Object.defineProperty(parentNode, 'subtreeSize', {\r\n        value: parentNode.subtreeSize - nodeSubtreeSize\r\n      });\r\n    }\r\n    delete node.parentNode; // the node has no parent node anymore\r\n    return node;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the string representation of this node\r\n   * @param {boolean=false} skipNodeClass\r\n   *        true to not include the node class name into the output, false otherwise\r\n   * @return {string} the sources string\r\n   * @override\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  toString(skipNodeClass: boolean = false): string {\r\n    let source = ''; // the sources\r\n    // for all the child nodes\r\n    this.childNodes_.forEach(childNode => { source += childNode.toString(true) });\r\n    return skipNodeClass ? source : 'SourceTree.Node{' + source + '}';\r\n  }\r\n};\r\nObject.defineProperties(Node.prototype, { // make getters and setters enumerable\r\n  childNodes: { enumerable: true }\r\n});\r\nObject.defineProperties(Node.prototype, { // default property values\r\n  tree: { value: undefined, enumerable: true }, // no tree\r\n  parentNode: { value: undefined, enumerable: true }, // no parent node\r\n  subtreeSize: { value: 1, enumerable: true }, // only one node in the subtree\r\n  childNodes_: { value: [], enumerable: false }, // no child nodes\r\n  parentNodeClass_: { value: Node, enumerable: false } // parent node must be a Node instance\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/SyntaxTree.ts","/**\r\n * @fileoverview LaTeX parser class\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\n/**@module */\r\n\r\n\r\nimport LatexStyle, {Symbol as SymbolItem, Command, Parameter, Environment, EnvironmentAndPackage} from \"./LatexStyle\";\r\nimport {\r\n  ParameterToken,\r\n  CommandToken,\r\n  SymbolToken,\r\n  Token,\r\n  SpaceToken,\r\n  EnvironmentToken,\r\n  EnvironmentBodyToken\r\n} from \"./LatexTree\";\r\nimport {Directive, GROUP, Lexeme, ModeStates, Operation, State} from \"./Latex\";\r\nimport {isNumber, isString, mustNotBeUndefined} from \"./Utils\";\r\n\r\n\r\n/**\r\n * Parse a comment line\r\n * @param {!Context} context the parsing context\r\n * @return {boolean} true if there was a comment line, false otherwise\r\n * @private\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nfunction parseCommentLine_(context: Context): boolean {\r\n  // try to find a comment int the sources tail\r\n  let commentMatch = context.source.substring(context.position).match(/^%([^\\n]*)(\\n[ \\t]*)?/);\r\n  if (!commentMatch) return false; // return if there is no comment at this position\r\n\r\n  context.comments.push(commentMatch[1]); // store the comment string\r\n  context.position += commentMatch[0].length; // position just after the comment\r\n  if (!commentMatch[2]) { // if there were no line breaks\r\n    context.charNumber += commentMatch[0].length; // go to the last char\r\n  } else { // if there was a line break\r\n    ++context.lineNumber; // one more line\r\n    context.charNumber = commentMatch[2].length - 1; // skip all the space chars in the new line\r\n  }\r\n  return true;\r\n}\r\n\r\n\r\n/**\r\n * Fill the parsed token position, comments and parent\r\n * @param {!Context} context the parsing context\r\n * @param {!Token} token the token to process\r\n * @private\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nfunction processParsedToken_(context: Context, token: Token) {\r\n  // TODO process comments and position\r\n  if (context.currentToken) { // if there is a current token\r\n\r\n    // console.log(context.currentToken.toString())\r\n\r\n    //noinspection JSUnresolvedFunction\r\n    context.currentToken.insertChildSubtree(token); // store this token as a child of the current\r\n  }\r\n}\r\n\r\n/**\r\n * Parse space for a token (space or paragraph separator)\r\n * @param {!Context} context the parsing context\r\n * @return {?SpaceToken} the parsed token or undefined if cannot parse a space token\r\n * @private\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nfunction parseSpaceToken_(context: Context): SpaceToken | undefined {\r\n  let isSpace = false; // true is the sources fragment is a space token, false otherwise\r\n  let nLineBreaks = 0; // number of parsed line breaks\r\n  while (context.position < context.source.length) { // while there is something to parse\r\n    // go to the next iteration if there was a comment\r\n    if (parseCommentLine_(context)) continue;\r\n    switch (context.source[context.position]) { // depend on the sources current character\r\n      case ' ': case '\\t': // if a space or a tabular\r\n      isSpace = true; // and one more parsed char\r\n      ++context.position; // go to the next sources char\r\n      ++context.charNumber; // the next char of the sources line\r\n      continue;\r\n      case '\\n': // if a line break\r\n        isSpace = true; // and one more parsed char\r\n        ++nLineBreaks; // one more parsed line\r\n        ++context.position; // go to the next sources char\r\n        ++context.lineNumber; // the next sources line\r\n        context.charNumber = 0; // the first char of the line\r\n        continue; // go to the next iteration\r\n    }\r\n    break; // stop if not a space char\r\n  }\r\n  // create a space token if needed\r\n  return isSpace ? new SpaceToken({ lineBreakCount: nLineBreaks }) : undefined;\r\n}\r\n\r\n/**\r\n * LaTeX parser structure\r\n * @class\r\n * @property {!LatexStyle} latexStyle - The LaTeX style description to be used for parsing\r\n * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n */\r\nexport class LatexParser {\r\n  latexStyle: LatexStyle;\r\n\r\n\r\n  //noinspection JSUnusedGlobalSymbols\r\n  /**\r\n   * Constructor\r\n   * @param {!LatexStyle} latexStyle LaTeX style description to be used for parsing\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  constructor(latexStyle: LatexStyle) {\r\n    if (!(latexStyle instanceof LatexStyle))\r\n      throw new TypeError('\"latexStyle\" isn\\'t a LatexStyle instance');\r\n    // store the style description\r\n    Object.defineProperty(this, 'latexStyle', { value: latexStyle, enumerable: true });\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Parse LaTeX sources\r\n   * @param {string} source the sources to parse\r\n   * @param {(!Context|undefined)} opt_context the parsing context\r\n   * @return {!Array.<!Token>} the list of the parsed tokens\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parse(source: string, opt_context?: Context): Token[] {\r\n    if (typeof source !== 'string') throw new TypeError('\"sources\" isn\\'t a string');\r\n    let context;\r\n\r\n    if (opt_context === undefined) { // if the parsing context isn't defined\r\n      context = new Context(source); // create the context\r\n    } else if (opt_context instanceof Context) { // if the parsing context is defined\r\n      context = opt_context;\r\n      context.source += source; // update the sources\r\n    } else { // if unexpected context type\r\n      throw new TypeError('\"context\" isn\\'t a LatexParser.Context instance');\r\n    }\r\n    let parsedTokens: Token[] = []; // the list of the parsed tokens\r\n    while (true) {\r\n      let parsedToken = this.parseToken_(context);\r\n      if (parsedToken === undefined) break; // stop when cannot parse a token\r\n      parsedTokens.push(parsedToken); // store the parsed token\r\n    }\r\n    return parsedTokens;\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse the next token\r\n   * @param {!Context} context the parsing context\r\n   * @return {?Token} the parsed token or undefined if the token cannot be parsed\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseToken_(context: Context): Token | undefined {\r\n    let token: Token | undefined = parseSpaceToken_(context); // collect comments and try to parse a space token\r\n    if (!token) { // if cannot parse a space token\r\n      if (context.position >= context.source.length) return undefined;\r\n\r\n      let contextBackup = context.copy(); // backup the current context\r\n      if (!(token = this.parseEnvironmentToken_(context))) { // if cannot parse an environment token\r\n        contextBackup.copy(context); // restore the context\r\n        if (!(token = this.parseCommandToken_(context))) { // if cannot parse a command token\r\n          contextBackup.copy(context); // restore the context\r\n          if (!(token = this.parseSymbolsToken_(context))) { // if cannot parse a symbol token\r\n            return undefined; // no token can be parsed\r\n          }\r\n        }\r\n      }\r\n    }\r\n    //noinspection JSCheckFunctionSignatures\r\n    processParsedToken_(context, token);\r\n    //noinspection JSValidateTypes\r\n    return token; // return the parsed token\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse a parameter token\r\n   * @param {!Context} context the parsing context\r\n   * @param {!LatexStyle.Parameter} parameter the symbol or command parameter description\r\n   * @param {string=} opt_endLabel\r\n   *        the parameter end label or undefined if there should be a single token\r\n   * @return {?ParameterToken} the parsed parameter token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseParameterToken_(context: Context, parameter: Parameter, opt_endLabel?: string) {\r\n    let currentTokenBackup = context.currentToken; // store the current token\r\n    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\r\n    context.updateState(parameter.operations); // update the LaTeX state\r\n    if (opt_endLabel === undefined) { // if the parameter must be parsed as a single token\r\n      // has the param space prefix or not\r\n      let spacePrefixState = parseSpaceToken_(context) !== undefined;\r\n      if (context.source[context.position] === '{') { // if the parameter is bounded by brackets\r\n        // create the parameter token\r\n        context.currentToken =\r\n          new ParameterToken({ hasBrackets: true, hasSpacePrefix: spacePrefixState});\r\n        ++context.position; // go to the sources next char\r\n        ++context.charNumber; // go to the current line next char\r\n        // exit if cannot parse until the closing bracket\r\n\r\n        if (!this.parseUntilLabel_(context, '}', parameter.lexeme)) return undefined;\r\n        ++context.position; // skip the bracket in the sources\r\n        ++context.charNumber; // skip the bracket in the current line\r\n      } else { // if the parameter is't bounded by brackets\r\n        // create the parameter token\r\n        context.currentToken =\r\n          new ParameterToken({ hasBrackets: false, hasSpacePrefix: spacePrefixState});\r\n        // exit if cannot parse a parameter token\r\n        if (this.parseToken_(context) === undefined) return undefined;\r\n      }\r\n    } else { // if the parameter must be parsed until the end label\r\n      // create the parameter token\r\n      context.currentToken =\r\n        new ParameterToken({ hasBrackets: false, hasSpacePrefix: false});\r\n\r\n      // return if cannot parse\r\n      if (!this.parseUntilLabel_(context, opt_endLabel, parameter.lexeme)) return undefined;\r\n    }\r\n    let parameterToken = context.currentToken; // the parsed parameter token\r\n    context.currentToken = currentTokenBackup; // restore the current token\r\n    //noinspection JSCheckFunctionSignatures\r\n    processParsedToken_(context, parameterToken);\r\n    //noinspection JSValidateTypes\r\n    return parameterToken;\r\n  }\r\n\r\n\r\n\r\n\r\n  /**\r\n   * Parse an environment token\r\n   * @param {!Context} context the parsing context\r\n   * @return {?EnvironmentToken} the parsed token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseEnvironmentToken_(context: Context): EnvironmentToken | undefined {\r\n    if (!context.source.startsWith('\\\\begin', context.position)) return undefined;\r\n    context.position += 6; // just after \"\\begin\"\r\n    parseSpaceToken_(context); // skip spaces\r\n    // try to obtain the environment name\r\n    let nameMatch = context.source.substring(context.position).match(/^{([\\w@]+\\*?)}/);\r\n    if (!nameMatch) return undefined; // exit if cannot bet the environment name\r\n    let name = nameMatch[1]; // the environment name\r\n    context.position += nameMatch[0].length; // skip the environment name in the sources\r\n    context.charNumber += nameMatch[0].length; // skip the environment name in the current line\r\n    let currentTokenBackup = context.currentToken; // store the current token\r\n    // try to get the corresponding environment\r\n    let environment: Environment | EnvironmentAndPackage = this.latexStyle.environments(context.currentState, name)[0];\r\n    let environmentToken = context.currentToken = environment ? // the environment token\r\n      new EnvironmentToken({ environment: environment.environment }) :\r\n      new EnvironmentToken({ name: name });\r\n    // TODO unknown environment notification\r\n    // try to parse the environment begin command\r\n    let symbols: Command[] = this.latexStyle.commands(context.currentState, name);\r\n    let beginCommandToken: Token | undefined = this.parsePatterns_(context, symbols);\r\n    if (beginCommandToken === undefined) { // if cannot parse a command\r\n      // TODO notification about the unrecognized command\r\n      // generate unrecognized command token\r\n      beginCommandToken = new CommandToken({ name: name });\r\n    }\r\n    //noinspection JSCheckFunctionSignatures\r\n    processParsedToken_(context, beginCommandToken);\r\n    let environmentBodyToken = context.currentToken = new EnvironmentBodyToken();\r\n    let endFound = this.parseUntilLabel_(context, '\\\\end{' + name + '}'); // try to get to the end\r\n    context.currentToken = environmentToken;\r\n    processParsedToken_(context, environmentBodyToken); // process the body token\r\n    let endCommandToken: Token | undefined = undefined; // the environment end command token\r\n    if (endFound) { // if the environment end was reached\r\n      context.position += name.length + 6; // skip the environment name in the sources\r\n      context.charNumber += name.length + 6; // skip the environment name in the current line\r\n      endCommandToken = this.parsePatterns_(context, this.latexStyle.commands(context.currentState, 'end' + name));\r\n    } else { // if cannot find the end of the environment\r\n      // TODO no environment end notification\r\n    }\r\n    if (endCommandToken === undefined) { // if cannot parse a command\r\n      // TODO notification about the unrecognized command\r\n      // generate unrecognized command token\r\n      endCommandToken = new CommandToken({ name: 'end' + name });\r\n    }\r\n    processParsedToken_(context, endCommandToken); // process the end command token\r\n    context.currentToken = currentTokenBackup; // restore the current token\r\n    return environmentToken;\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse a command token\r\n   * @param {!Context} context the parsing context\r\n   * @return {?CommandToken} the parsed token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseCommandToken_(context: Context): Token | undefined {\r\n    // try to find a command name\r\n    const cmdMatch = context.source.substring(context.position).match(/^\\\\([\\w@]+\\*?)/);\r\n\r\n    if (!cmdMatch)\r\n      return undefined; // exit if cannot find a command name\r\n\r\n    context.position += cmdMatch[0].length; // set position just after the command name\r\n    context.charNumber += cmdMatch[0].length; // skip all the command name chars\r\n    \r\n    // try to parse a command token\r\n    \r\n    let token: Token | undefined = this.parsePatterns_(context, this.latexStyle.commands(context.currentState, cmdMatch[1]));\r\n    if (token === undefined) { // if cannot parse a command token\r\n      // TODO notification about the unrecognized command\r\n      // generate unrecognized command token\r\n      token = new CommandToken({ name: cmdMatch[1] });\r\n    }\r\n    //noinspection JSValidateTypes\r\n    return token;\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse symbols for a token\r\n   * @param {!Context} context the parsing context\r\n   * @return {?Token} the parsed token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseSymbolsToken_(context: Context) {\r\n    // get the available symbols\r\n    let sourceCharacter = context.source[context.position]; // the current sources character\r\n    // get the symbols started with the current sources character\r\n    //noinspection JSValidateTypes\r\n    let token =\r\n      this.parsePatterns_(context, this.latexStyle.symbols(context.currentState, sourceCharacter));\r\n    if (token === undefined) { // if cannot parse a symbol token\r\n      // TODO notification about the unrecognized symbol\r\n      ++context.position; // go to the next sources character\r\n      // go to the next line character (the line is the same, \\n was parsed for a space token)\r\n      ++context.charNumber;\r\n      // generate unrecognized symbol token\r\n      token = new SymbolToken({ pattern: sourceCharacter });\r\n    } else { // if the token was parsed\r\n      // TODO parse words and numbers\r\n    }\r\n    return token;\r\n  }\r\n\r\n\r\n  /**\r\n   * Try to parse a symbol pattern\r\n   * @param {!Context} context the parsing context// generate unrecognized symbol token\r\n   * @param {!Array.<!LatexStyle.Symbol>} symbols the symbol or command descriptions in the priority descending order\r\n   * @return {?Token} the parsed symbol or command token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parsePatterns_(context: Context, symbols: SymbolItem[]): Token | undefined {\r\n    let contextBackup = context.copy(); // backup the current context\r\n    let token: Token | undefined = undefined; // the parsed token\r\n\r\n    // TODO not how some() is meant to be used...?\r\n    symbols.some(symbol => { // for all the symbols until the parsing success\r\n      // stop if the token was parsed\r\n      if (token = this.parsePattern_(context, symbol)) {\r\n        return true;\r\n      } else {\r\n        contextBackup.copy(context); // restore the context\r\n        return false; // go to the next symbol\r\n      }\r\n    });\r\n    return token;\r\n  }\r\n\r\n\r\n  /**\r\n   * Try to parse a symbol pattern\r\n   * @param {!Context} context the parsing context\r\n   * @param {!Array.<!LatexStyle.Symbol>} symbol the symbol or command description\r\n   * @return {?Token} the parsed symbol or command token or undefined if cannot parse\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parsePattern_(context: Context, symbol: SymbolItem): Token | undefined {\r\n    let currentTokenBackup = context.currentToken; // store the current token\r\n    // if a command description is given\r\n    context.currentToken = symbol instanceof Command ?\r\n      new CommandToken({ command: symbol }) : // generate a command token\r\n      new SymbolToken({ symbol: symbol }); // generate a symbol token\r\n\r\n    let patternComponents = symbol.patternComponents; // the symbol pattern components\r\n    let nPatternComponents = patternComponents.length; // the pattern componen number\r\n    let iPatternComponent = 0; // the pattern component iterator\r\n    // for all the pattern components\r\n    for ( ; iPatternComponent < nPatternComponents; ++iPatternComponent) {\r\n      let patternComponent = patternComponents[iPatternComponent]; // the pattern component\r\n      if(isNumber(patternComponent)){ // if a parameter is expected\r\n        let parameter: Parameter | undefined = symbol.parameter(patternComponent); // the parameter description\r\n        // try to get the end label for the parameter\r\n        let parameterEndLabel = patternComponents[iPatternComponent + 1];\r\n        if (typeof parameterEndLabel === 'string') { // if there is a end label\r\n          // if can parse the parameter token\r\n          if (this.parseParameterToken_(context, mustNotBeUndefined(parameter), parameterEndLabel)) {\r\n            // exit if there is no the end label at the positions\r\n            if (!context.source.startsWith(parameterEndLabel, context.position)) return undefined;\r\n            context.position += parameterEndLabel.length; // skip the end label in the sources\r\n            context.charNumber += parameterEndLabel.length; // skip the end label in the line\r\n            ++iPatternComponent; // skip the end label in the pattern\r\n            continue; // go to the next pattern component\r\n          }\r\n        } else { // if there is no a end label\r\n          // go to the next pattern char if can parse the parameter token\r\n          if (this.parseParameterToken_(context, mustNotBeUndefined(parameter))) continue;\r\n        }\r\n      }\r\n      else if(isString(patternComponent)){\r\n          while (parseCommentLine_(context)) {\r\n          } // skip all the comments\r\n          // if the sources fragment is equal the pattern component\r\n          if (context.source.startsWith(patternComponent, context.position)) {\r\n            context.position += patternComponent.length; // skip the pattern component in the sources\r\n            context.charNumber += patternComponent.length; // skip the pattern component in the line\r\n            continue; // go to the next pattern component\r\n          }\r\n      } else if (parseSpaceToken_(context))\r\n        continue;\r\n      break; // stop parsing if there was no continue call\r\n    }\r\n    // return if the pattern parsing was broken\r\n    if (iPatternComponent < nPatternComponents) return undefined;\r\n    let parsedToken = context.currentToken; // the parsed token to return\r\n    context.currentToken = currentTokenBackup; // restore the current token\r\n    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\r\n    context.updateState(symbol.operations); // update the LaTeX state\r\n    return parsedToken;\r\n  }\r\n\r\n\r\n  /**\r\n   * Parse tokens until the label\r\n   * @param {!Context} context the parsing context\r\n   * @param {string} endLabel the label to parse until\r\n   * @param {Latex.Lexeme=} opt_lexeme the lexeme of the single token to parse\r\n   * @return {boolean} true if the parsing was successful, false otherwise\r\n   * @private\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  parseUntilLabel_(context: Context, endLabel: string, opt_lexeme?: Lexeme) {\r\n    switch (opt_lexeme) {\r\n      // TODO parse special lexemes\r\n    default: {\r\n      // while not reached the label\r\n      while (!context.source.startsWith(endLabel, context.position)) {\r\n        if (context.position >= context.source.length) { // if there is no more sources\r\n          // TODO notification about unexpected sources end\r\n          return false;\r\n        }\r\n        this.parseToken_(context);\r\n      }\r\n      return true;\r\n    }}\r\n  }\r\n};\r\n\r\n\r\n\r\n/**\r\n * The parsing context\r\n * @struct\r\n * @property {string} source - The source to parse\r\n * @property {number} position - The current position in the source\r\n * @property {?Token} currentToken - The currently parsing token\r\n * @property {!Latex.State} currentState - The current LaTeX state\r\n * @property {!Array.<!Latex.State>} stateStack - The stack of LaTeX sates\r\n * @property {!Array.<string>} comments - The comment list for the nex token\r\n * @property {number} lineNumber - The current line number\r\n * @property {number} charNumber - The current char number in the current line\r\n * @property {function} copy\r\n * @author Kirill Chuvilin <kirill.chuvilin@gmail.com>\r\n */\r\nexport class Context {\r\n  source: string;\r\n  position: number;\r\n  currentToken?: Token;\r\n  currentState: State;\r\n  stateStack: State[];\r\n  comments: string[];\r\n  lineNumber: number;\r\n  charNumber: number;\r\n\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {string=} opt_source the sources to parse (empty string by default)\r\n   */\r\n  constructor(opt_source: string = \"\") {\r\n    this.source = opt_source || ''; // store the sources\r\n    this.position = 0; // start from the beginning\r\n    this.lineNumber = 0; // start from the line 0\r\n    this.charNumber = 0; // start from the char 0\r\n    this.currentToken = undefined; // no tokens were parsed\r\n    this.currentState = new State(); // initial LaTeX state\r\n    this.stateStack = []; // no stored states\r\n    this.comments = []; // no comments for the next token\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Copy this context\r\n   * @param {!Context=} opt_target the context to copy to or undefined to create a new one\r\n   * @return {!Context} the context copy\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  copy(opt_target?: Context): Context {\r\n    let target = opt_target || new Context(); // the context to copy this context in\r\n    target.source = this.source;\r\n    target.position = this.position;\r\n    target.lineNumber = this.lineNumber;\r\n    target.charNumber = this.charNumber;\r\n    target.currentToken = this.currentToken;\r\n    target.currentState = this.currentState.copy();\r\n    target.stateStack = this.stateStack.slice();\r\n    target.comments = this.comments.slice();\r\n    return target;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Update the LaTeX state\r\n   * @param {!Array.<!Latex.Operation>} operations the LaTeX operation list\r\n   * @author Kirill Chuvilin <k.chuvilin@texnous.org>\r\n   */\r\n  updateState(operations: Operation[]) {\r\n    if (!(operations instanceof Array))\r\n      throw new TypeError('\"operations\" isn\\'t an Array instance');\r\n    let newModeStates: ModeStates = {}; // the modes to update\r\n    operations.forEach((operation: Operation) => {\r\n\r\n      switch (operation.directive) {\r\n      case Directive.BEGIN:\r\n\r\n        switch (operation.operand) {\r\n        case GROUP:\r\n          this.currentState.update(newModeStates); // store the mode states\r\n          newModeStates = {}; // no more states to update\r\n          this.stateStack.push(this.currentState.copy()); // store the current state\r\n          break;\r\n        default:\r\n\r\n          newModeStates[operation.operand] = true; // turn the state on\r\n        }\r\n        break;\r\n      case Directive.END:\r\n\r\n        switch (operation.operand) {\r\n        case GROUP:\r\n          newModeStates = {}; // no need to store the states\r\n          if (this.stateStack.length < 1) throw new Error('state stack is empty');\r\n          this.currentState = mustNotBeUndefined(this.stateStack.pop()); // restore the current state\r\n          break;\r\n        default:\r\n\r\n          newModeStates[operation.operand] = false; // turn the state off\r\n        }\r\n        break;\r\n      }\r\n    });\r\n    this.currentState.update(newModeStates); // store the mode states\r\n  }\r\n};\r\n\r\n//noinspection JSUnusedGlobalSymbols // TODO\r\nexport default LatexParser;\n\n\n// WEBPACK FOOTER //\n// ./sources/lib/LatexParser.ts","/**\r\n * @fileoverview Export file for LaTeX parser utilities.\r\n * This file is a part of TeXnous project.\r\n *\r\n * @copyright TeXnous project team (http://texnous.org) 2016\r\n * @license LGPL-3.0\r\n *\r\n * This library is free software; you can redistribute it and/or modify it under the terms of the\r\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 3\r\n * of the License, or (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without\r\n * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License along with this library;\r\n * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\r\n * 02111-1307, USA.\r\n */\r\n\r\nexport * from \"./lib/Utils\" // general JavaScript utils\r\nexport * from \"./lib/Latex\" // general LaTeX definitions\r\nexport * from \"./lib/LatexStyle\" // LaTeX style structures\r\nexport * from \"./lib/SyntaxTree\" // syntax tree structure elements\r\nexport * from \"./lib/LatexTree\" // LaTeX syntax tree structure elements\r\nexport * from \"./lib/LatexParser\"// LaTeX parser class\n\n\n// WEBPACK FOOTER //\n// ./sources/main.ts"],"sourceRoot":""}